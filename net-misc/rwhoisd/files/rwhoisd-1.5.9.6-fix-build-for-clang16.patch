Clang 16 will not allow implicit ints, implicit function declarations etc.
by default. This patch overhauls to whole package source to make it build
with clang16. It also gets rid of old K&R style function declaration.

Bug: https://bugs.gentoo.org/861830
Bug: https://bugs.gentoo.org/870940
PR to merge this upstream: https://github.com/arineng/rwhoisd/pull/2

Pascal JÃ¤ger <pascal.jaeger@leimstift.de> (2022-12-15)

--- a/common/attributes.c
+++ b/common/attributes.c
@@ -51,20 +51,18 @@ verify_attribute_defs PROTO((auth_area_struct *aa,
 /* -------------------- LOCAL FUNCTIONS ------------------------ */
 
 static attribute_struct *
-create_attribute(name, desc, format, index, type, is_hierarchical,
-                 is_required, is_repeatable, is_primary_key, is_multi_line,
-                 is_private)
-  char            *name;
-  char            *desc;
-  char            *format;
-  attr_index_type index;
-  attr_type       type;
-  int             is_hierarchical;
-  int             is_required;
-  int             is_repeatable;
-  int             is_primary_key;
-  int             is_multi_line;
-  int             is_private;
+create_attribute(
+  char            *name,
+  char            *desc,
+  char            *format,
+  attr_index_type index,
+  attr_type       type,
+  int             is_hierarchical,
+  int             is_required,
+  int             is_repeatable,
+  int             is_primary_key,
+  int             is_multi_line,
+  int             is_private)
 {
   attribute_struct  *attr;
 
@@ -100,11 +98,7 @@ create_attribute(name, desc, format, index, type, is_hierarchical,
    Check the alias list, if this alias already exits, return FALSE.
    This is spun off into its own routine to deal with the memory
    allocation. */
-static int
-add_attribute_alias(alias_array, num_aliases, alias)
-  char ***alias_array;
-  int  *num_aliases;
-  char *alias;
+static int add_attribute_alias (char ***alias_array, int *num_aliases, char *alias)
 {
   int   i;
   char  **array = *alias_array;
@@ -138,9 +132,9 @@ add_attribute_alias(alias_array, num_aliases, alias)
 /* writes/append a specific attribute definition to the class attribute 
    template file. */
 static int 
-write_attribute_defs(fp, attr)
-  FILE             *fp; 
-  attribute_struct *attr;
+write_attribute_defs(
+  FILE             *fp,
+  attribute_struct *attr)
 {
   int i;
 
@@ -178,9 +172,9 @@ write_attribute_defs(fp, attr)
 /* count the number of times a given attibute occurs in the attribute
    list */
 static int
-count_attribute_entries(attr_list, attr_name)
-  dl_list_type *attr_list;
-  char *attr_name;
+count_attribute_entries(
+  dl_list_type *attr_list,
+  char *attr_name)
 {
   int               i, not_done;
   int               count = 0;
@@ -220,10 +214,10 @@ count_attribute_entries(attr_list, attr_name)
 
 /* verifies the correctness of a class attribute definition */
 static int
-verify_attribute_defs(aa, class, attr)
-  auth_area_struct *aa;
-  class_struct     *class;
-  attribute_struct *attr;
+verify_attribute_defs(
+  auth_area_struct *aa,
+  class_struct     *class,
+  attribute_struct *attr)
 {
   int i;
   int ret;
@@ -298,8 +292,7 @@ verify_attribute_defs(aa, class, attr)
 /* returns how to index the word based on the attribute. If none
    declared, returns all words. */
 attr_index_type
-translate_index_type(itype)
-  char *itype;
+translate_index_type(char *itype)
 {
   if (STR_EQ(itype, A_INDEX_ALL))
   {
@@ -325,8 +318,7 @@ translate_index_type(itype)
 
 /* returns the description of the attribute */
 attr_type
-translate_attr_type(type)
-  char *type;
+translate_attr_type(char *type)
 {
   if (STR_EQ(type, A_SEE_ALSO))
   {
@@ -345,9 +337,9 @@ translate_attr_type(type)
 /* reads the attributes for the class; returns TRUE if ok, FALSE if
    not. */
 int
-read_attributes(class, attr_ref_list)
-  class_struct  *class;
-  dl_list_type  *attr_ref_list;
+read_attributes(
+  class_struct  *class,
+  dl_list_type  *attr_ref_list)
 {
   FILE              *fp                 = NULL;
   attribute_struct  *attr               = NULL;
@@ -492,10 +484,10 @@ read_attributes(class, attr_ref_list)
 }
 
 int
-add_attribute(attr, class, attr_ref_list)
-  attribute_struct      *attr;
-  class_struct          *class;
-  dl_list_type          *attr_ref_list;
+add_attribute(
+  attribute_struct      *attr,
+  class_struct          *class,
+  dl_list_type          *attr_ref_list)
 {
   attribute_struct  *tmp_attr;
   dl_list_type      *attr_list = &(class->attribute_list);
@@ -576,11 +568,11 @@ add_attribute(attr, class, attr_ref_list)
 
   
 int
-add_global_attribute(attr, class, attr_ref_list, global_id)
-  attribute_struct  *attr;
-  class_struct      *class;
-  dl_list_type      *attr_ref_list;
-  int               *global_id;
+add_global_attribute(
+  attribute_struct  *attr,
+  class_struct      *class,
+  dl_list_type      *attr_ref_list,
+  int               *global_id)
 {
   attribute_ref_struct  *ref;
   attribute_ref_struct  *alias_ref;
@@ -659,9 +651,9 @@ add_global_attribute(attr, class, attr_ref_list, global_id)
 
 
 int
-add_base_schema(class, attr_ref_list)
-  class_struct  *class;
-  dl_list_type  *attr_ref_list;
+add_base_schema(
+  class_struct  *class,
+  dl_list_type  *attr_ref_list)
 {
   attribute_struct  *attr;
 
@@ -855,9 +847,9 @@ add_base_schema(class, attr_ref_list)
 }
 
 attribute_struct *
-find_attribute_by_name(class, name)
-  class_struct  *class;
-  char          *name;
+find_attribute_by_name(
+  class_struct  *class,
+  char          *name)
 {
   int               not_done;
   attribute_struct  *val;
@@ -897,9 +889,9 @@ find_attribute_by_name(class, name)
 }
 
 attribute_struct *
-find_attribute_by_id(class, id)
-  class_struct  *class;
-  int           id;
+find_attribute_by_id(
+  class_struct  *class,
+  int           id)
 {
   int               not_done;
   attribute_struct  *val;
@@ -930,9 +922,9 @@ find_attribute_by_id(class, id)
 }
 
 attribute_struct *
-find_attribute_by_global_id(class, global_id)
-  class_struct  *class;
-  int           global_id;
+find_attribute_by_global_id(
+  class_struct  *class,
+  int           global_id)
 {
   int               not_done;
   attribute_struct  *val;
@@ -963,9 +955,9 @@ find_attribute_by_global_id(class, global_id)
 }
 
 attribute_ref_struct *
-find_global_attr_by_name(attr_ref_list, name)
-  dl_list_type  *attr_ref_list;
-  char          *name;
+find_global_attr_by_name(
+  dl_list_type  *attr_ref_list,
+  char          *name)
 {
   int                   not_done;
   attribute_ref_struct  *val;
@@ -1002,9 +994,9 @@ find_global_attr_by_name(attr_ref_list, name)
 }
 
 attribute_ref_struct *
-find_global_attr_by_id(attr_ref_list, id)
-  dl_list_type  *attr_ref_list;
-  int           id;
+find_global_attr_by_id(
+  dl_list_type  *attr_ref_list,
+  int           id)
 {
   int                   not_done;
   attribute_ref_struct  *val;
@@ -1034,8 +1026,7 @@ find_global_attr_by_id(attr_ref_list, id)
 
 /* returns the description of the attribute */
 char *
-show_attribute_type(type)
-  attr_type type;
+show_attribute_type(attr_type type)
 {
   switch (type)
   {
@@ -1052,8 +1043,7 @@ show_attribute_type(type)
 
 /* returns the description of index type */
 char *
-show_index_type(index)
-  attr_index_type index;
+show_index_type(attr_index_type index)
 {
   switch (index)
   {
@@ -1074,8 +1064,7 @@ show_index_type(index)
 
 
 void
-display_attribute(attr)
-  attribute_struct  *attr;
+display_attribute(attribute_struct  *attr)
 {
   int i;
   
@@ -1107,8 +1096,7 @@ display_attribute(attr)
 }
 
 void
-display_attribute_list(list)
-  dl_list_type  *list;
+display_attribute_list(dl_list_type  *list)
 {
   int   not_done;
 
@@ -1128,8 +1116,7 @@ display_attribute_list(list)
 /* destroy_attr_data: destroy function for the attribute_struct data
       type */
 int
-destroy_attr_data(attr)
-  attribute_struct  *attr;
+destroy_attr_data(attribute_struct  *attr)
 {
   int   i;
   
@@ -1171,8 +1158,7 @@ destroy_attr_data(attr)
 /* destroy_attr_ref_data: the destroy function for the
       attribute_ref_struct type. */
 int
-destroy_attr_ref_data(attr_ref)
-  attribute_ref_struct  *attr_ref;
+destroy_attr_ref_data(attribute_ref_struct  *attr_ref)
 {
   int   i;
   
@@ -1208,11 +1194,11 @@ destroy_attr_ref_data(attr_ref)
    was successful the file name is added to the 'paths_list'. It also
    creates the class database directory. */
 int 
-write_class_attributes(file, suffix, class, paths_list)
-  char         *file;
-  char         *suffix;
-  class_struct *class;
-  dl_list_type *paths_list;
+write_class_attributes(
+  char         *file,
+  char         *suffix,
+  class_struct *class,
+  dl_list_type *paths_list)
 {
   FILE             *fp;
   int              not_done;
@@ -1293,10 +1279,10 @@ write_class_attributes(file, suffix, class, paths_list)
 
 /* creates a class attribute and appends it to the attribute list */
 int 
-create_attribute_def(attr, class, aa)
-  attribute_struct *attr;
-  class_struct     *class;
-  auth_area_struct *aa;
+create_attribute_def(
+  attribute_struct *attr,
+  class_struct     *class,
+  auth_area_struct *aa)
 {
   int              i;
   dl_list_type     *attr_ref_list;
@@ -1343,8 +1329,7 @@ create_attribute_def(attr, class, aa)
 
 /* checks if the attribute specified is a base attribute - hard coded */
 int
-is_base_attr(attr)
-  attribute_struct *attr;
+is_base_attr(attribute_struct *attr)
 {
   if (STR_EQ(attr->name, BC_CLASS_NAME))
     return TRUE;
@@ -1381,9 +1366,9 @@ is_base_attr(attr)
 
 /* verify each attribute in the attribute list */
 int
-verify_attribute_list(aa, class)
-  auth_area_struct *aa;
-  class_struct     *class;
+verify_attribute_list(
+  auth_area_struct *aa,
+  class_struct     *class)
 {
   int              not_done;
   int              non_base;
@@ -1423,9 +1408,7 @@ verify_attribute_list(aa, class)
    examine the validity of an attribute name or its alias. Returns a
    non-zero value if failed.
 */
-int
-examin_attribute_name(name)
-  char *name;
+int examin_attribute_name (char *name)
 {
   if (NOT_STR_EXISTS(name)) return ERW_EMTYSTR;
   if (!is_id_str(name)) return ERW_IDSTR;
@@ -1436,9 +1419,7 @@ examin_attribute_name(name)
    examine the validity of attribute display format syntax. Returns a
    non-zero value if failed.
 */
-int
-examin_attribute_format(fmt)
-  char *fmt;
+int examin_attribute_format (char *fmt)
 {
   if (NOT_STR_EXISTS(fmt)) return ERW_EMTYSTR;
   return( 0 );
@@ -1448,11 +1429,11 @@ examin_attribute_format(fmt)
 /* add a new attibute to the list after making sure it is not a
    duplicate. */
 int
-add_new_attribute_alias(aa, class, attr, alias)
-  auth_area_struct *aa;
-  class_struct     *class;
-  attribute_struct *attr;
-  char             *alias;
+add_new_attribute_alias(
+  auth_area_struct *aa,
+  class_struct     *class,
+  attribute_struct *attr,
+  char             *alias)
 {
   /* bad parameters */
   if (!aa || !class || !attr || !alias || !*alias) return FALSE;
--- a/common/auth_area.c
+++ b/common/auth_area.c
@@ -22,6 +22,7 @@
 #include "misc.h"
 #include "schema.h"
 #include "strutil.h"
+#include "../regexp/regexp.h"
 
 /* local definations */
 #define DEFAULT_ATTRIB_DIR         "attribute_defs"
@@ -81,8 +82,7 @@ static dl_list_type *auth_area_list = NULL;
 /* check_soa: given an auth-area record, check for null or illegal
    values.  If found, log errors and return FALSE */
 static int
-check_soa(aa)
-  auth_area_struct *aa;
+check_soa(auth_area_struct *aa)
 {
   char hostname[MAX_LINE];
   char port[MAX_LINE];
@@ -169,9 +169,9 @@ check_soa(aa)
 
 /* compare the two auth-areas: just compare the name and the type */
 static int
-same_auth_area(aa,  bb)
-  auth_area_struct *aa;
-  auth_area_struct *bb;
+same_auth_area(
+  auth_area_struct *aa,
+  auth_area_struct *bb)
 {
 
   if (!aa || !bb) return FALSE;
@@ -189,11 +189,11 @@ same_auth_area(aa,  bb)
    a new temporary soa file name. If file was created on disk,
    add the file name to the paths_list. */
 static int
-write_new_soa_file(file, suffix, aa, paths_list)
-  char *file;
-  char *suffix;
-  auth_area_struct  *aa;
-  dl_list_type *paths_list;
+write_new_soa_file(
+  char *file,
+  char *suffix,
+  auth_area_struct  *aa,
+  dl_list_type *paths_list)
 {
   FILE *fp = NULL;
   char new_file[MAX_FILE];
@@ -230,10 +230,10 @@ write_new_soa_file(file, suffix, aa, paths_list)
 /* writes master/slave server entries to rwhois auth-area file if the list
    is not empty. */
 static int
-write_server_list(fp, type, serv_list)
-  FILE         *fp;
-  char         *type;
-  dl_list_type *serv_list;
+write_server_list(
+  FILE         *fp,
+  char         *type,
+  dl_list_type *serv_list)
 {
   int           not_done;
   server_struct *serv;
@@ -262,9 +262,9 @@ write_server_list(fp, type, serv_list)
 /* write guardian entries to the rwhois auth-area file, if the
    list is not empty */
 static int
-write_guardian_list(fp, guard_list)
-  FILE         *fp;
-  dl_list_type *guard_list;
+write_guardian_list(
+  FILE         *fp,
+  dl_list_type *guard_list)
 {
   int  not_done;
   char *guard_item;
@@ -291,10 +291,10 @@ write_guardian_list(fp, guard_list)
 /* creates authority area directory, its data and attribute-defs directories,
    and calls to write the auhority area schema, and soa file. */
 static int
-write_auth_area(suffix, aa, paths_list)
-  char             *suffix;
-  auth_area_struct *aa;
-  dl_list_type     *paths_list;
+write_auth_area(
+  char             *suffix,
+  auth_area_struct *aa,
+  dl_list_type     *paths_list)
 {
   char aa_dir[MAX_FILE];
   char attr_dir[MAX_FILE];
@@ -375,8 +375,7 @@ write_auth_area(suffix, aa, paths_list)
    function returns whichever(hostname/ip-addr) is defined for the
    server. */
 static char *
-get_server_hostaddr(serv)
-  server_struct *serv;
+get_server_hostaddr(server_struct *serv)
 {
   if (STR_EXISTS(serv->name)) return( serv->name );
 
@@ -386,9 +385,9 @@ get_server_hostaddr(serv)
 /* count the number of times a given server occurs in the server
    list. */
 static int
-count_server_entries(servlst, serv)
-  dl_list_type  *servlst;
-  server_struct *serv;
+count_server_entries(
+  dl_list_type  *servlst,
+  server_struct *serv)
 {
   int           not_done;
   int           n_serv;
@@ -427,9 +426,9 @@ count_server_entries(servlst, serv)
 
 /* verifies the contents of master/slave server info structure. */
 static int
-verify_server_data(server, aa_name)
-  server_struct *server;
-  char          *aa_name;
+verify_server_data(
+  server_struct *server,
+  char          *aa_name)
 {
   int ret;
 
@@ -458,9 +457,9 @@ verify_server_data(server, aa_name)
    area does not have master list empty, and make sure a primary does
    does not have any master servers defined. */
 static int
-verify_server_list(aa, list_type)
-  auth_area_struct *aa;
-  char             *list_type;
+verify_server_list(
+  auth_area_struct *aa,
+  char             *list_type)
 {
   int           n;
   int           not_done;
@@ -536,9 +535,9 @@ verify_server_list(aa, list_type)
 /* count the number of times a guardian string occurs in the guardian
    list of the authority area. */
 static int
-count_guardian_entries(guard_list, guard_str)
-  dl_list_type *guard_list;
-  char         *guard_str;
+count_guardian_entries(
+  dl_list_type *guard_list,
+  char         *guard_str)
 {
   int          not_done;
   int          n;
@@ -573,8 +572,7 @@ count_guardian_entries(guard_list, guard_str)
 /* verify the contents of guardian list of an authority area. Check
    for any duplicates. */
 static int
-verify_guardian_list(aa)
-  auth_area_struct *aa;
+verify_guardian_list(auth_area_struct *aa)
 {
   int  not_done;
   int  ret;
@@ -617,8 +615,7 @@ verify_guardian_list(aa)
    schema, server and guardian lists etc.. Take into consideration
    the authority area type (primary/secondary). */
 static int
-verify_auth_area(aa)
-  auth_area_struct *aa;
+verify_auth_area(auth_area_struct *aa)
 {
   int  ret;
   char directory[MAX_FILE];
@@ -758,9 +755,9 @@ verify_auth_area(aa)
 /* ------------------ Public Functions ----------------- */
 
 int
-add_auth_area_guardian(aa, id_str)
-  auth_area_struct *aa;
-  char             *id_str;
+add_auth_area_guardian(
+  auth_area_struct *aa,
+  char             *id_str)
 {
   if (!aa || !STR_EXISTS(id_str))
   {
@@ -781,8 +778,7 @@ add_auth_area_guardian(aa, id_str)
 /* translate_auth_area_type: given a string, translate it into one of
    the auth_area_type values */
 auth_area_type
-translate_auth_area_type(val)
-  char  *val;
+translate_auth_area_type(char  *val)
 {
   if (!val) return AUTH_AREA_PRIMARY;
 
@@ -795,8 +791,7 @@ translate_auth_area_type(val)
 }
 
 char *
-translate_auth_area_type_str(val)
-  auth_area_type    val;
+translate_auth_area_type_str(auth_area_type    val)
 {
   if (val == AUTH_AREA_PRIMARY)
   {
@@ -811,9 +806,7 @@ translate_auth_area_type_str(val)
  * return TRUE if it is valid (don't care its reachability)
  * else return FALSE;
  */
-int
-is_valid_hostname ( name)
-  char   *name;
+int is_valid_hostname (char *name)
 {
   char           *p;
   char           *op_str;
@@ -895,9 +888,7 @@ is_valid_hostname ( name)
 
 /* is_valid_port: check the port number. Return TRUE if a valid port
    number, else return FALSE */
-int
-is_valid_port(port)
-  char  *port;
+int is_valid_port (char *port)
 {
   char  *p;
 
@@ -919,9 +910,9 @@ is_valid_port(port)
 
 /* check to see if  aa is already in aa_list */
 int
-is_duplicate_aa(aa, aa_list)
-  auth_area_struct *aa;
-  dl_list_type     *aa_list;
+is_duplicate_aa(
+  auth_area_struct *aa,
+  dl_list_type     *aa_list)
 {
   int not_done;
 
@@ -950,9 +941,7 @@ is_duplicate_aa(aa, aa_list)
 /* read_auth_areas: given an auth-area conf file name, read the
    configuration file (and associated configuration files.  Return
    FALSE if a fatal error was detected */
-int
-read_auth_areas(file)
-  char *file;
+int read_auth_areas (char *file)
 {
   char              line[BUFSIZ];
   char              tag[MAX_TEMPLATE_DESC];
@@ -1153,8 +1142,7 @@ read_auth_areas(file)
      Checks for illegal variable conditions first, and refuse to add
      structures that fail.  Returns TRUE on success, otherwise FALSE */
 int
-add_auth_area(aa)
-  auth_area_struct  *aa;
+add_auth_area(auth_area_struct  *aa)
 {
   char               directory[MAX_FILE];
   log_context_struct local_context;
@@ -1255,10 +1243,7 @@ add_auth_area(aa)
 
 /* check_aa_syntax(): check auth_area syntax, also create auth_area directory.
    Return TRUE if valid auth-area else FALSE */
-int
-check_aa_syntax (aa_name, directory)
-  char *aa_name;
-  char *directory;
+int check_aa_syntax (char *aa_name, char *directory)
 {
   char      *p;
   char      *op_str;
@@ -1356,8 +1341,7 @@ check_aa_syntax (aa_name, directory)
    contained within, and fill out the record.  Returns FALSE if it
    discovered something wrong. */
 int
-read_soa_file(aa)
-  auth_area_struct  *aa;
+read_soa_file(auth_area_struct  *aa)
 {
   char              line[MAX_LINE + 1];
   char              tag[MAX_TEMPLATE_DESC];
@@ -1452,8 +1436,7 @@ read_soa_file(aa)
    contained within, and fill out the record.  Returns FALSE if it
    discovered something wrong. */
 int
-write_soa_file(aa)
-  auth_area_struct  *aa;
+write_soa_file(auth_area_struct  *aa)
 {
   FILE *fp = NULL;
   int   lock_fd;
@@ -1494,8 +1477,7 @@ write_soa_file(aa)
 
 /* destroy_soa_in_auth_area: destroy the soa related data in an auth_area */
 int
-destroy_soa_in_auth_area(aa)
-  auth_area_struct *aa;
+destroy_soa_in_auth_area(auth_area_struct *aa)
 {
   if (!aa) return TRUE;
 
@@ -1523,9 +1505,9 @@ destroy_soa_in_auth_area(aa)
 
 
 int
-add_server(srv_list_ptr, val)
-  dl_list_type      **srv_list_ptr;
-  char              *val;
+add_server(
+  dl_list_type      **srv_list_ptr,
+  char              *val)
 {
   dl_list_type    *list         = *srv_list_ptr;
   char            name[BUFSIZ];
@@ -1645,8 +1627,7 @@ add_server(srv_list_ptr, val)
 }
 
 void
-display_auth_area(aa)
-  auth_area_struct  *aa;
+display_auth_area(auth_area_struct  *aa)
 {
   if (!aa)
   {
@@ -1670,8 +1651,7 @@ display_auth_area(aa)
   display_schema(aa->schema);
 }
 
-void
-display_all_auth_areas()
+void display_all_auth_areas (void)
 {
   int   not_done;
 
@@ -1695,8 +1675,7 @@ display_all_auth_areas()
 
 
 int
-destroy_server_data(server)
-  server_struct *server;
+destroy_server_data(server_struct *server)
 {
   if (!server) return TRUE;
 
@@ -1715,16 +1694,14 @@ destroy_server_data(server)
   return TRUE;
 }
 
-void
-destroy_auth_area_list()
+void destroy_auth_area_list (void)
 {
   dl_list_destroy(auth_area_list);
   auth_area_list = NULL;
 }
 
 int
-destroy_auth_area_data(aa)
-  auth_area_struct  *aa;
+destroy_auth_area_data(auth_area_struct  *aa)
 {
   if (!aa) return TRUE;
 
@@ -1790,8 +1767,7 @@ get_auth_area_list()
 
 
 auth_area_struct *
-find_auth_area_by_name(name)
-  char *name;
+find_auth_area_by_name(char *name)
 {
   auth_area_struct  *auth_area;
   int               not_done;
@@ -1817,8 +1793,7 @@ find_auth_area_by_name(name)
 
 
 attribute_ref_struct *
-find_truly_global_attr_by_name(name)
-  char *name;
+find_truly_global_attr_by_name(char *name)
 {
   dl_list_type         *auth_area_list;
   dl_list_type         *attr_ref_list;
@@ -1862,9 +1837,7 @@ find_truly_global_attr_by_name(name)
  * format: <hostname>:<port>:<protocol>
  * return TRUE if not error, else return FALSE
  */
-int
-check_root_referral(file)
-  char *file;
+int check_root_referral (char *file)
 {
   FILE         *fp                = NULL;
   char         *pound             = NULL;
@@ -1968,17 +1941,14 @@ check_root_referral(file)
 }
 
 /* check to see if it is a country-code */
-int
-is_country_code(p)
-  char  *p;
+int is_country_code (char *p)
 {
   /* FIXME: need the country-code database */
   return TRUE;
 }
 
 char *
-get_default_aa_directory(aa)
-  auth_area_struct *aa;
+get_default_aa_directory(auth_area_struct *aa)
 {
   struct netinfo prefix;
   char           buf[MAX_LINE];
@@ -1994,8 +1964,7 @@ get_default_aa_directory(aa)
 }
 
 char *
-get_aa_schema_directory(aa)
-  auth_area_struct *aa;
+get_aa_schema_directory(auth_area_struct *aa)
 {
   char  dir[MAX_FILE];
   char  file[MAX_FILE];
@@ -2022,10 +1991,10 @@ get_aa_schema_directory(aa)
    authority area file while going through the auth-area list. Saves
    any directory and file names created into paths_list structure. */
 int
-write_all_auth_areas(file, suffix, paths_list)
-  char         *file;
-  char         *suffix;
-  dl_list_type *paths_list;
+write_all_auth_areas(
+  char         *file,
+  char         *suffix,
+  dl_list_type *paths_list)
 {
   int              not_done;
   auth_area_struct *aa;
@@ -2108,8 +2077,7 @@ write_all_auth_areas(file, suffix, paths_list)
    defined by the user. And finally appends the created authority area
    to the list. */
 int
-create_auth_area(aa)
-  auth_area_struct *aa;
+create_auth_area(auth_area_struct *aa)
 {
   char             aa_dir[MAX_FILE];
   char             buffer[MAX_FILE];
@@ -2269,9 +2237,7 @@ create_auth_area(aa)
 }
 
 /* deletes an authority area (by name) from the configuration */
-int
-delete_auth_area(name)
-  char *name;
+int delete_auth_area (char *name)
 {
   if (!find_auth_area_by_name(name))
   {
@@ -2291,9 +2257,7 @@ delete_auth_area(name)
 /* examine the format of email address string. Currently excuses the
    hostname to have an non-dns hostname. Returns non-zero value if
    some error was found. */
-int
-examin_email_address(addr)
-  char *addr;
+int examin_email_address (char *addr)
 {
   static regexp  *email_exp = NULL;
 
@@ -2316,18 +2280,14 @@ examin_email_address(addr)
 
 /* examine the format of x-fer arguments. Returns non-zero value on
    failure. */
-int
-examin_aa_xfer_arg(path)
-  char *path;
+int examin_aa_xfer_arg (char *path)
 {
   return ( 0 );
 }
 
 /* examine the validity of authority area directory. Returns non-zero
    value on failure. */
-int
-examin_aa_data_dir(path)
-  char *path;
+int examin_aa_data_dir (char *path)
 {
   int ret;
 
@@ -2340,9 +2300,7 @@ examin_aa_data_dir(path)
 
 /* examine the validity of authority area schema file name. Returns
    non-zero value on failure. */
-int
-examin_aa_schema_file(path)
-  char *path;
+int examin_aa_schema_file (char *path)
 {
   int ret;
 
@@ -2355,9 +2313,7 @@ examin_aa_schema_file(path)
 
 /* examine the validity of authority area soa file name. Returns non-zero
    value on failure. */
-int
-examin_aa_soa_file(path)
-  char *path;
+int examin_aa_soa_file (char *path)
 {
   int ret;
 
@@ -2370,9 +2326,7 @@ examin_aa_soa_file(path)
 
 /* examine the validity of authority area hostmaster e-mail address.
    Returns non-zero value on failure. */
-int
-examin_aa_hostmaster_str(contact)
-  char *contact;
+int examin_aa_hostmaster_str (char *contact)
 {
   int ret;
 
@@ -2384,9 +2338,7 @@ examin_aa_hostmaster_str(contact)
 
 /* examine the vailidity of authority area serial number. Makes sure
    it is a number string. Returns non-zero value on failure. */
-int
-examin_serial_num(num)
-  char *num;
+int examin_serial_num (char *num)
 {
   int ret;
 
@@ -2397,9 +2349,7 @@ examin_serial_num(num)
 
 /* examine the validity of guardian item string. Returns non-zero value
    on failure. */
-int
-examin_guardian_item(guard_str)
-  char *guard_str;
+int examin_guardian_item (char *guard_str)
 {
   if (NOT_STR_EXISTS(guard_str)) return ERW_EMTYSTR;
 
@@ -2410,9 +2360,7 @@ examin_guardian_item(guard_str)
 /* examins the validity of a host name. It logs a warning if the hostname
    is not a complete dns host name. Returns non-zero value on
    error. */
-int
-examin_hostname(name)
-  char *name;
+int examin_hostname (char *name)
 {
   if (NOT_STR_EXISTS(name)) return ERW_EMTYSTR;
 
@@ -2431,9 +2379,7 @@ examin_hostname(name)
 
 /* examins the validity of a port number string. Returns non-zero
    value on error. */
-int
-examin_port_str(portstr)
-  char *portstr;
+int examin_port_str (char *portstr)
 {
   if (NOT_STR_EXISTS(portstr)) return ERW_EMTYSTR;
   if (!is_number_str(portstr)) return ERW_NUMSTR;
@@ -2444,9 +2390,7 @@ examin_port_str(portstr)
 
 /* examine the validity of authority area primary server string. Returns
    non-zero value if failed. */
-int
-examin_primary_server_str(server)
-  char *server;
+int examin_primary_server_str (char *server)
 {
   char hostname[BUFSIZ];
   char port[BUFSIZ];
@@ -2482,9 +2426,7 @@ examin_primary_server_str(server)
 /* examine the validity of master or slave server string. Returns
    a non-zero value if failed. Calls functions to examine hostname and
    port number string separately. */
-int
-examin_server_str(server)
-  char *server;
+int examin_server_str (char *server)
 {
   int             ret;
   char            name[BUFSIZ];
@@ -2508,8 +2450,7 @@ examin_server_str(server)
 
 
 /* verify all authority area definitions in the server configuration. */
-int
-verify_all_auth_areas()
+int verify_all_auth_areas (void)
 {
   int              not_done;
   auth_area_struct *aa;
@@ -2534,8 +2475,7 @@ verify_all_auth_areas()
    already in the list. Logs an error if a path name is already used in
    the configuration. */
 int
-verify_all_auth_area_paths(paths_list)
-  dl_list_type *paths_list;
+verify_all_auth_area_paths(dl_list_type *paths_list)
 {
   int              ret = 0;
   char             buffer[MAX_LINE];
@@ -2580,8 +2520,7 @@ verify_all_auth_area_paths(paths_list)
    classes are used as configuration path names (contents of
    paths_list). */
 int
-verify_aa_parse_progs(paths_list)
-  dl_list_type *paths_list;
+verify_aa_parse_progs(dl_list_type *paths_list)
 {
   int              ret = 0;
   auth_area_struct *aa;
--- a/common/client_msgs.c
+++ b/common/client_msgs.c
@@ -83,8 +83,7 @@ static FILE *out;
 static int  printed_error_flag = FALSE;
 
 void
-set_out_fp(fp)
-  FILE *fp;
+set_out_fp(FILE *fp)
 {
   out = fp;
 }
@@ -97,8 +96,7 @@ get_out_fp()
 
 /* FIXME: this entire solution, which attempts to reliably prevent the
    printing of multiple "%error" codes in succession is a hack. */
-void
-clear_printed_error_flag()
+void clear_printed_error_flag (void)
 {
   printed_error_flag = FALSE;
 }
@@ -108,10 +106,7 @@ clear_printed_error_flag()
 
 /* prints to stdout the error messages. Format: %error ### message
      text, where ### follows rfc 640 */
-void
-print_error(err_no, str)
-  int   err_no;
-  char *str;
+void print_error (int err_no, char *str)
 {
   int   i;
   
@@ -140,7 +135,7 @@ print_error(err_no, str)
 }
 
 /* prints to stdout the ok message */
-void print_ok ()
+void print_ok (void)
 {
   printf ("%%ok\n");
 }
--- a/common/compat.c
+++ b/common/compat.c
@@ -17,8 +17,7 @@
  *    is used in order to get local FQDN name. I think it has no need to
  *    modify only in order to get local FQDN.
  */
-char *
-sys_gethostname()
+char *sys_gethostname (void)
 {
   static char       hostname[MAX_HOSTNAME + 1];
   struct hostent    *hp;
@@ -61,9 +60,9 @@ sys_gethostname()
 }
 
 int
-sys_file_lock(fd, op)
-  int           fd;
-  file_lock_t   op;
+sys_file_lock(
+  int           fd,
+  file_lock_t   op)
 {
   /* we should have one or the other (flock or lockf) always */
 #ifdef HAVE_LOCKF
--- a/common/dir_security.c
+++ b/common/dir_security.c
@@ -27,9 +27,9 @@ static int count_dir_security_entries PROTO((dl_list_type *wrap_list,
 /* counts the number of times a tcp wrapper occurs in the given allow or
    deny list. */
 static int
-count_dir_security_entries(wrap_list, wrapper)
-  dl_list_type *wrap_list;
-  char         *wrapper;
+count_dir_security_entries(
+  dl_list_type *wrap_list,
+  char         *wrapper)
 {
   int                 not_done;
   int                 count     = 0;
@@ -59,9 +59,9 @@ count_dir_security_entries(wrap_list, wrapper)
 
 /* verify the contents of directive security entry. */
 static int
-verify_dir_security(wrap_item, wrap_type)
-  dir_security_struct *wrap_item;
-  char                *wrap_type;
+verify_dir_security(
+  dir_security_struct *wrap_item,
+  char                *wrap_type)
 {
   int ret;
 
@@ -80,9 +80,9 @@ verify_dir_security(wrap_item, wrap_type)
 
 /* allocate/create the directive security list head */
 static int
-create_dir_security(wrap_list, wrap_type)
-  dl_list_type **wrap_list;
-  char         *wrap_type;
+create_dir_security(
+  dl_list_type **wrap_list,
+  char         *wrap_type)
 {
   *wrap_list = xcalloc(1, sizeof(**wrap_list));
 
@@ -100,9 +100,7 @@ create_dir_security(wrap_list, wrap_type)
 
 /* verifies the format of allow/deny tcp wrapper. Returns non-zero value
    on failure. */
-int
-examin_tcp_wrapper(wrapper)
-  char *wrapper;
+int examin_tcp_wrapper (char *wrapper)
 {
   if (NOT_STR_EXISTS(wrapper)) return ERW_EMTYSTR;
 
@@ -112,10 +110,10 @@ examin_tcp_wrapper(wrapper)
 /* reads allow/deny tcp wrapper file into the allow/deny wrapper
    list. */
 int
-read_dir_security_file(file, wrap_list, wrap_type)
-  char         *file;
-  dl_list_type **wrap_list;
-  char         *wrap_type;
+read_dir_security_file(
+  char         *file,
+  dl_list_type **wrap_list,
+  char         *wrap_type)
 {
   FILE *fp;
   char line[BUFSIZ];
@@ -181,12 +179,12 @@ read_dir_security_file(file, wrap_list, wrap_type)
 /* writes the allow/deny tcp wrapper file. Appends the file name to paths_list
    if this function was able to create the file on disk. */
 int
-write_dir_security_file(file, suffix, wrap_list, wrap_type, paths_list)
-  char         *file;
-  char         *suffix;
-  dl_list_type *wrap_list;
-  char         *wrap_type;
-  dl_list_type *paths_list;
+write_dir_security_file(
+  char         *file,
+  char         *suffix,
+  dl_list_type *wrap_list,
+  char         *wrap_type,
+  dl_list_type *paths_list)
 {
   FILE                *fp = NULL;
   int                 not_done;
@@ -223,9 +221,9 @@ write_dir_security_file(file, suffix, wrap_list, wrap_type, paths_list)
 /* checks the validity of the tcp wrapper list and its entries. It verifies
    that there are no duplicates in the list. */
 int
-verify_dir_security_list(wrap_list, wrap_type)
-  dl_list_type *wrap_list;
-  char         *wrap_type;
+verify_dir_security_list(
+  dl_list_type *wrap_list,
+  char         *wrap_type)
 {
   int                 not_done;
   dir_security_struct *wrap_item;
@@ -256,8 +254,7 @@ verify_dir_security_list(wrap_list, wrap_type)
 
 /* destroy the given wrapper list. */
 void
-destroy_dir_security_list(wrap_list)
-  dl_list_type **wrap_list;
+destroy_dir_security_list(dl_list_type **wrap_list)
 {
   if (!wrap_list) return;
   dl_list_destroy(*wrap_list);
@@ -266,8 +263,7 @@ destroy_dir_security_list(wrap_list)
 
 /* initialize the directive allow tcp wrapper list. */
 int
-def_dir_allow_security_list(wrap_list)
-  dl_list_type **wrap_list;
+def_dir_allow_security_list(dl_list_type **wrap_list)
 {
   if (!wrap_list) return FALSE;
 
@@ -283,8 +279,7 @@ def_dir_allow_security_list(wrap_list)
 
 /* initialize the directive deny tcp wrapper list. */
 int
-def_dir_deny_security_list(wrap_list)
-  dl_list_type **wrap_list;
+def_dir_deny_security_list(dl_list_type **wrap_list)
 {
   if (!wrap_list) return FALSE;
 
@@ -301,10 +296,10 @@ def_dir_deny_security_list(wrap_list)
 /* create and append a directive tcp wrapper to the list after checking to
    make sure it is not already in the list. */
 int
-add_dir_security(wrap_list, wrap_str, wrap_type)
-  dl_list_type **wrap_list;
-  char         *wrap_str;
-  char         *wrap_type;
+add_dir_security(
+  dl_list_type **wrap_list,
+  char         *wrap_str,
+  char         *wrap_type)
 {
   dir_security_struct *wrap_item;
 
@@ -338,9 +333,9 @@ add_dir_security(wrap_list, wrap_str, wrap_type)
 /* find the given tcp wrapper string in the wrapper list. Return NULL if
    not in the list. */
 dir_security_struct *
-find_dir_security(wrap_list, wrap_str)
-  dl_list_type *wrap_list;
-  char         *wrap_str;
+find_dir_security(
+  dl_list_type *wrap_list,
+  char         *wrap_str)
 {
   int                 not_done;
   dir_security_struct *wrap_item;
@@ -361,10 +356,10 @@ find_dir_security(wrap_list, wrap_str)
 
 /* delete the given directive security wrapper from the wrapper list. */
 int
-del_dir_security(wrap_list, wrap_str, wrap_type)
-  dl_list_type **wrap_list;
-  char         *wrap_str;
-  char         *wrap_type;
+del_dir_security(
+  dl_list_type **wrap_list,
+  char         *wrap_str,
+  char         *wrap_type)
 {
   if (!wrap_list || !wrap_str || !*wrap_str || !wrap_type) return FALSE;
 
@@ -390,8 +385,7 @@ del_dir_security(wrap_list, wrap_str, wrap_type)
 
 /* free up the memory used by directive security wrapper item. */
 int
-destroy_dir_security_data(dir_wrap)
-  dir_security_struct *dir_wrap;
+destroy_dir_security_data(dir_security_struct *dir_wrap)
 {
   if (!dir_wrap) return TRUE;
 
--- a/common/directive_conf.c
+++ b/common/directive_conf.c
@@ -29,8 +29,7 @@ static int is_extended_directive PROTO((char *name));
 /* --------------------- Local Functions ---------------- */
 
 static int
-destroy_directive_data(data)
-  directive_struct  *data;
+destroy_directive_data(directive_struct  *data)
 {
   if (!data)
   {
@@ -60,8 +59,7 @@ destroy_directive_data(data)
    extended directive path. Checks if the essential directives are
    enabled. */
 static int
-verify_directive(dir)
-  directive_struct *dir;
+verify_directive(directive_struct *dir)
 {
   int ret;
 
@@ -98,9 +96,7 @@ verify_directive(dir)
 }
 
 /* check if the given directive name is an extended directive */
-static int
-is_extended_directive(name)
-  char *name;
+static int is_extended_directive (char *name)
 {
   return( STR_EXISTS(name) &&
           is_no_whitespace_str(name) &&
@@ -113,8 +109,7 @@ is_extended_directive(name)
 /* default_directive_list: set the default directive list according to
    protocol and implementation.  Return TRUE if success, FALSE
    otherwise */
-int
-default_directive_list()
+int default_directive_list (void)
 {
   initialize_directive_list();
 
@@ -208,9 +203,7 @@ default_directive_list()
  *              places them into directive structure 
  *  format:  <directive>:<enabled>
  */
-int
-read_directive_file(file)
-  char *file;
+int read_directive_file (char *file)
 {
   FILE          *fp;
   char          line[MAX_LINE];
@@ -277,9 +270,7 @@ read_directive_file(file)
 
 /* read_extended_directive_file: reads the extended directives from a
       file and places them into a data structure */
-int
-read_extended_directive_file(file)
-  char *file;
+int read_extended_directive_file (char *file)
 {
   FILE  *fp;
   char  line[MAX_LINE];
@@ -366,8 +357,7 @@ read_extended_directive_file(file)
 }
 
 
-void
-initialize_directive_list()
+void initialize_directive_list (void)
 {
   if (!dl_list_empty(&directive_list))
   {
@@ -379,8 +369,7 @@ initialize_directive_list()
 
 
 directive_struct *
-find_directive(name)
-  char  *name;
+find_directive(char  *name)
 {
   directive_struct  *di;
   int               not_done;
@@ -408,14 +397,15 @@ find_directive(name)
 }
 
 
-int
-add_directive(name, len, description, func, program, disabled_flag)
-  char  *name;
-  int   len;
-  char  *description;
-  int   (*func)();
-  char  *program;
-  int   disabled_flag;      /* when "off", this flag is "TRUE" */
+int 
+add_directive (
+    char *name,
+    int len,
+    char *description,
+    int (*func)(void),
+    char *program,
+    int disabled_flag      /* when "off", this flag is "TRUE" */
+)
 {
   directive_struct  *item;
 
@@ -475,8 +465,7 @@ add_directive(name, len, description, func, program, disabled_flag)
 }
 
 
-void
-destroy_directive_list()
+void destroy_directive_list (void)
 {
   dl_list_destroy(&directive_list);
 }
@@ -491,9 +480,7 @@ get_directive_list()
 
 
 
-long 
-find_cap(directive)
-  char  *directive;
+long find_cap (char *directive)
 {
   if (STR_EQ(directive, "class"))
   {
@@ -565,12 +552,8 @@ find_cap(directive)
 /* write the directive enable/disable information. Adds the file name to
    paths_list if successful in creating a file on disk. */
 int 
-write_directive_file(file, suffix, paths_list)
-  char         *file;
-  char         *suffix;
-  dl_list_type *paths_list;
+write_directive_file(char *file, char *suffix, dl_list_type *paths_list)
 {
-
   FILE             *fp = NULL;
   int              not_done;
   directive_struct *dir;
@@ -629,10 +612,7 @@ write_directive_file(file, suffix, paths_list)
    paths_list if it was created on disk. Strips the 'X-' prefix of 
    extended directives before writing. */
 int 
-write_extended_directive_file(file, suffix, paths_list)
-  char         *file;
-  char         *suffix;
-  dl_list_type *paths_list;
+write_extended_directive_file(char *file,char *suffix,dl_list_type *paths_list)
 {
   FILE             *fp = NULL;
   int              not_done;
@@ -686,9 +666,7 @@ write_extended_directive_file(file, suffix, paths_list)
    in the path specified, looks in bin-path of rwhois server. Also
    checks for if the program is on disk and executable. Returns
    non-zero value on failure. */
-int
-examin_xdirective_program(path)
-  char *path;
+int examin_xdirective_program (char *path)
 {
   int  ret = 0;
   char new_path[MAX_FILE];
@@ -717,8 +695,7 @@ examin_xdirective_program(path)
 
 /* verifies all the directives in the directives list. Makes sure
    at least one normal directive is defined in the list. */
-int 
-verify_all_directives()
+int verify_all_directives (void)
 {
   int              not_done;
   int              n_dir;
--- a/common/dl_list.c
+++ b/common/dl_list.c
@@ -15,8 +15,7 @@
    malloc()s a new node into existance, and defaults the member
    variables. */
 static dl_node_type *
-create_new_node(data)
-  void  *data;
+create_new_node(void  *data)
 {
   dl_node_type  *node;
   
@@ -30,10 +29,10 @@ create_new_node(data)
   return node;
 }
 int
-dl_list_default(list, destroy_head_flag, destroy_data)
-  dl_list_type  *list;
-  int           destroy_head_flag;
-  int           (*destroy_data)();
+dl_list_default(
+  dl_list_type  *list,
+  int           destroy_head_flag,
+  int           (*destroy_data)())
 {
   if (list) {
     list->head              = NULL;
@@ -48,8 +47,7 @@ dl_list_default(list, destroy_head_flag, destroy_data)
 }
 
 void *
-dl_list_value(list)
-  dl_list_type  *list;
+dl_list_value(dl_list_type  *list)
 {
   if (!list) return NULL;
   if (!(list->current)) return NULL;
@@ -58,9 +56,9 @@ dl_list_value(list)
 }   
 
 void *
-dl_list_next_value(list, n)
-  dl_list_type  *list;
-  int           n;
+dl_list_next_value(
+  dl_list_type  *list,
+  int           n)
 {
   dl_node_type  *p;
   int               i;
@@ -79,9 +77,9 @@ dl_list_next_value(list, n)
 }
 
 void *
-dl_list_prev_value(list, n)
-  dl_list_type  *list;
-  int           n;
+dl_list_prev_value(
+  dl_list_type  *list,
+  int           n)
 {
   dl_node_type  *p;
   int               i;
@@ -100,8 +98,7 @@ dl_list_prev_value(list, n)
 }
 
 int
-dl_list_empty(list)
-  dl_list_type  *list;
+dl_list_empty(dl_list_type  *list)
 {
   /* if any of the standard position fields are NULL, then the list is
      empty, or it has been generated incorrectly, in which case, we
@@ -117,8 +114,7 @@ dl_list_empty(list)
 
 
 int
-dl_list_first(list)
-  dl_list_type  *list;
+dl_list_first(dl_list_type  *list)
 {
   if (!list) return FALSE;
   if (!(list->head)) return FALSE;
@@ -129,8 +125,7 @@ dl_list_first(list)
 }
 
 int
-dl_list_last(list)
-  dl_list_type  *list;
+dl_list_last(dl_list_type  *list)
 {
   if (!list) return FALSE;
 
@@ -143,8 +138,7 @@ dl_list_last(list)
 }
 
 int
-dl_list_next(list)
-  dl_list_type  *list;
+dl_list_next(dl_list_type  *list)
 {
   if (!list) return FALSE;
 
@@ -158,8 +152,7 @@ dl_list_next(list)
 }
 
 int
-dl_list_prev(list)
-  dl_list_type  *list;
+dl_list_prev(dl_list_type  *list)
 {
   if (!list) return FALSE;
 
@@ -173,9 +166,9 @@ dl_list_prev(list)
 }
     
 int
-dl_list_insert(list, data)
-  dl_list_type  *list;
-  void          *data;
+dl_list_insert(
+  dl_list_type  *list,
+  void          *data)
 {
   dl_node_type  *node;
     
@@ -208,9 +201,9 @@ dl_list_insert(list, data)
 }
 
 int
-dl_list_insert_before(list, data)
-  dl_list_type  *list;
-  void          *data;
+dl_list_insert_before(
+  dl_list_type  *list,
+  void          *data)
 {
   dl_node_type  *node;
 
@@ -244,9 +237,9 @@ dl_list_insert_before(list, data)
 
 
 int
-dl_list_append(list, data)
-  dl_list_type  *list;
-  void          *data;
+dl_list_append(
+  dl_list_type  *list,
+  void          *data)
 {
   dl_node_type  *old_pos;
 
@@ -268,9 +261,9 @@ dl_list_append(list, data)
 
 
 int
-dl_list_prepend(list, data)
-  dl_list_type  *list;
-  void          *data;
+dl_list_prepend(
+  dl_list_type  *list,
+  void          *data)
 {
   dl_node_type  *old_pos;
 
@@ -291,9 +284,9 @@ dl_list_prepend(list, data)
 }
 
 int
-dl_list_append_list(list1, list2)
-  dl_list_type  *list1;
-  dl_list_type  *list2;
+dl_list_append_list(
+  dl_list_type  *list1,
+  dl_list_type  *list2)
 {
   dl_node_type  *pos1;
   dl_node_type  *pos2;
@@ -319,17 +312,16 @@ dl_list_append_list(list1, list2)
 }
 
 dl_node_type *
-dl_list_get_pos(list)
-  dl_list_type *list;
+dl_list_get_pos(dl_list_type *list)
 {
   if (!list) return NULL;
   return(list->current);
 }
 
 int
-dl_list_put_pos(list, pos)
-  dl_list_type  *list;
-  dl_node_type  *pos; 
+dl_list_put_pos(
+  dl_list_type  *list,
+  dl_node_type  *pos)
 {
   if (!pos) return FALSE;
 
@@ -338,9 +330,9 @@ dl_list_put_pos(list, pos)
 }
 
 dl_node_type *
-dl_list_exchange_pos(list, pos)
-  dl_list_type  *list;
-  dl_node_type  *pos; 
+dl_list_exchange_pos(
+  dl_list_type  *list,
+  dl_node_type  *pos)
 {
   dl_node_type  *p;
 
@@ -352,8 +344,7 @@ dl_list_exchange_pos(list, pos)
 }
     
 int
-dl_list_delete(list)
-  dl_list_type  *list;
+dl_list_delete(dl_list_type  *list)
 {
   dl_node_type  *current;
     
@@ -395,8 +386,7 @@ dl_list_delete(list)
 }
 
 int
-dl_list_destroy(list)
-  dl_list_type  *list;
+dl_list_destroy(dl_list_type  *list)
 {
   int   status;
 
@@ -427,9 +417,7 @@ dl_list_destroy(list)
   return TRUE;
 }
 
-int
-simple_destroy_data(data)
-  void  *data;
+int simple_destroy_data (void *data)
 {
   if (data) {
     free(data);
@@ -437,9 +425,7 @@ simple_destroy_data(data)
   return TRUE;
 }   
 
-int
-null_destroy_data(data)
-  void  *data;
+int null_destroy_data (void *data)
 {
   return TRUE;
 }
--- a/common/fileutils.c
+++ b/common/fileutils.c
@@ -36,9 +36,9 @@ static char cwd[MAX_FILE + 1];
 /* ----------------------- LOCAL FUNCTIONS --------------------- */
 
 static int
-get_path_status(path, mode)
-  char      *path;
-  mode_t    *mode;
+get_path_status(
+  char      *path,
+  mode_t    *mode)
 {
   struct stat   sb;
   int           status;
@@ -55,10 +55,7 @@ get_path_status(path, mode)
 }
 
 
-static int
-generate_dot_lock_name(filename, lockname)
-  char  *filename;
-  char  *lockname;
+static int generate_dot_lock_name (char *filename, char *lockname)
 {
   char  dir[MAX_FILE];
   char  file[MAX_FILE];
@@ -92,10 +89,7 @@ generate_dot_lock_name(filename, lockname)
   return TRUE;
 }
 
-static int
-generate_uniq_dot_lock_name(filename, lockname)
-  char *filename;
-  char *lockname;
+static int generate_uniq_dot_lock_name (char *filename, char *lockname)
 {
   char  dir[MAX_FILE];
   char  file[MAX_FILE];
@@ -123,9 +117,7 @@ generate_uniq_dot_lock_name(filename, lockname)
 
 /* file_exists: tests to see if a file exists.  Note: does not test
       for access. */
-int
-file_exists(file)
-  char  *file;
+int file_exists (char *file)
 {
   mode_t    mode;
 
@@ -135,9 +127,7 @@ file_exists(file)
   return FALSE;
 }
 
-int
-directory_exists(dir)
-  char  *dir;
+int directory_exists (char *dir)
 {
   mode_t    mode;
 
@@ -147,9 +137,7 @@ directory_exists(dir)
   return FALSE;
 }
 
-int
-is_rel_path(path)
-  char  *path;
+int is_rel_path (char *path)
 {
   if (path && *path != '/') {
     return TRUE;
@@ -157,8 +145,7 @@ is_rel_path(path)
   return FALSE;
 }
 
-int
-store_current_wd()
+int store_current_wd (void)
 {
   bzero(cwd, sizeof(cwd));
   if (getcwd(cwd, sizeof(cwd)) == NULL)
@@ -171,8 +158,7 @@ store_current_wd()
   return TRUE;
 }
 
-int
-restore_current_wd()
+int restore_current_wd (void)
 {
   if (chdir(cwd) < 0)
   {
@@ -185,8 +171,7 @@ restore_current_wd()
 }
 
 time_t
-get_path_mod_time(path)
-  char  *path;
+get_path_mod_time(char  *path)
 {
   struct stat   sb;
   int           status;
@@ -204,11 +189,7 @@ get_path_mod_time(path)
 /* split_path: splits path into the directory and file components; if
    there is no directory component, then it just returns the file
    component. */
-int
-split_path(path, dir, file)
-  char  *path;
-  char  *dir;
-  char  *file;
+int split_path (char *path, char *dir, char *file)
 {
   char  **argv;
   int   argc;
@@ -247,10 +228,7 @@ split_path(path, dir, file)
       root.  Returns NULL if the directory wasn't in the root
       directory, otherwise, return a pointer to the reduced path
       within the full path */
-char *
-path_full_to_rel(full_path, root_dir)
-  char *full_path;
-  char *root_dir;
+char *path_full_to_rel (char *full_path, char *root_dir)
 {
   int   root_dir_len  = strlen(root_dir);
   int   full_path_len = strlen(full_path);
@@ -281,12 +259,7 @@ path_full_to_rel(full_path, root_dir)
 /* path_rel_to_full: basically just concatenates root_dir and
    rel_path; returns NULL if bad data.  It copies the original path
    into the new path if the 'rel_path' isn't actually relative. */
-char *
-path_rel_to_full(new_path, new_path_len, rel_path, root_dir)
-  char *new_path;
-  int  new_path_len;
-  char *rel_path;
-  char *root_dir;
+char *path_rel_to_full (char *new_path, int new_path_len, char *rel_path, char *root_dir)
 {
   int   root_len;
 
@@ -315,15 +288,7 @@ path_rel_to_full(new_path, new_path_len, rel_path, root_dir)
       convert it to a relative path, and, if chrooted is TRUE, will
       return FALSE if the path isn't under the root directory. It will
       copy the new path into "new_path" */
-int
-canonicalize_path(new_path, new_path_len, path, root_dir, chrooted,
-                  null_allowed)
-  char  *new_path;
-  int   new_path_len;
-  char  *path;
-  char  *root_dir;
-  int   chrooted;
-  int   null_allowed;
+int canonicalize_path (char *new_path, int new_path_len, char *path, char *root_dir, int chrooted, int null_allowed)
 {
   char      *p;
 
@@ -377,8 +342,7 @@ canonicalize_path(new_path, new_path_len, path, root_dir, chrooted,
 }
 
 /* Returns current date/time in yymmddhhmmss string  */
-char *
-make_timestamp()
+char *make_timestamp (void)
 {
   static char   buffer[18];
   struct tm     *tm;
@@ -393,11 +357,7 @@ make_timestamp()
 }
 
 /* Returns a temp filename */
-char *
-create_filename(fname, template, spool_directory)
-  char *fname;
-  char *template;
-  char *spool_directory;
+char *create_filename (char *fname, char *template, char *spool_directory)
 
 {
   sprintf(fname, template, spool_directory, make_timestamp());
@@ -410,12 +370,7 @@ create_filename(fname, template, spool_directory)
 }
 
 /* Returns a data text filename */
-char *
-create_db_filename(fname, template, spool_directory, postfix)
-  char *fname;
-  char *template;
-  char *spool_directory;
-  char *postfix;
+char *create_db_filename (char *fname, char *template, char *spool_directory, char *postfix)
 {
   sprintf(fname, template, spool_directory, make_timestamp(), postfix);
   /* FIXME: should use mkstemp. see above. */
@@ -429,10 +384,10 @@ create_db_filename(fname, template, spool_directory, postfix)
    option. */
 
 FILE *
-get_file_lock(filename, mode, block)
-  char  *filename;
-  char  *mode;
-  int   block;
+get_file_lock(
+  char  *filename,
+  char  *mode,
+  int   block)
 {
   FILE  *fp;
 
@@ -481,9 +436,9 @@ get_file_lock(filename, mode, block)
 }
 
 int
-release_file_lock(filename, fp)
-  char  *filename;
-  FILE  *fp;
+release_file_lock(
+  char  *filename,
+  FILE  *fp)
 {
 
 #ifndef USE_SYS_LOCK
@@ -506,10 +461,7 @@ release_file_lock(filename, fp)
 }
 
 
-int
-get_dot_lock(filename, block)
-  char  *filename;
-  int   block;
+int get_dot_lock (char *filename, int block)
 {
   char  lockname[MAX_FILE + 1];
   char  tmplockname[MAX_FILE + 1];
@@ -583,9 +535,7 @@ get_dot_lock(filename, block)
   return TRUE;
 }
 
-int
-release_dot_lock(filename)
-  char  *filename;
+int release_dot_lock (char *filename)
 {
   char  lockname[MAX_FILE + 1];
 
@@ -603,9 +553,7 @@ release_dot_lock(filename)
   return TRUE;
 }
 
-int
-dot_lock_exists(filename)
-  char  *filename;
+int dot_lock_exists (char *filename)
 {
   char  lockname[MAX_FILE + 1];
 
@@ -619,11 +567,7 @@ dot_lock_exists(filename)
   return FALSE;
 }
 
-int
-get_placeholder_lock(filename, block, lock_fd)
-  char *filename;
-  int  block;
-  int  *lock_fd;
+int get_placeholder_lock (char *filename, int block, int *lock_fd)
 {
 #ifndef USE_SYS_LOCK
   return get_dot_lock(filename, block);
@@ -678,10 +622,7 @@ get_placeholder_lock(filename, block, lock_fd)
 #endif
 }
 
-int
-release_placeholder_lock(filename, lock_fd)
-  char *filename;
-  int  lock_fd;
+int release_placeholder_lock (char *filename, int lock_fd)
 {
 #ifndef USE_SYS_LOCK
   return release_dot_lock(filename);
@@ -695,9 +636,7 @@ release_placeholder_lock(filename, lock_fd)
 #endif
 }
 
-int
-placeholder_lock_exists(filename)
-  char *filename;
+int placeholder_lock_exists (char *filename)
 {
 #ifndef USE_SYS_LOCK
   return dot_lock_exists(filename);
@@ -730,8 +669,7 @@ placeholder_lock_exists(filename)
 }
 
 time_t
-get_path_mtime(path)
-  char      *path;
+get_path_mtime(char      *path)
 {
   struct stat   sb;
   int           status;
@@ -748,10 +686,7 @@ get_path_mtime(path)
 
 /* compares two files line-by-line, returns true if same and false if
    different. */
-int
-file_cmpr(file1, file2)
-  char *file1;
-  char *file2;
+int file_cmpr (char *file1, char *file2)
 {
   FILE        *fptr1;
   FILE        *fptr2;
@@ -820,10 +755,7 @@ file_cmpr(file1, file2)
 
 /* compare two timestamps, currently just uses strcmp(). Returns
    1 if stamp1 is newer than stamp2, 0 if equal, and -1 if older. */
-int
-timestamp_cmpr(stamp1, stamp2)
-  char *stamp1;
-  char *stamp2;
+int timestamp_cmpr (char *stamp1, char *stamp2)
 {
   return( strcmp(stamp1, stamp2) );
 }
@@ -831,9 +763,7 @@ timestamp_cmpr(stamp1, stamp2)
 /* increments a given timestamp to a larger value, but does not care about
    the month, year, seconds, minutes etc.. ranges while incrementing.
    - this should not go beyond all 99999..99s */
-static void
-increment_timestamp(stamp)
-  char *stamp;
+static void increment_timestamp (char *stamp)
 {
   int i;
 
@@ -854,9 +784,7 @@ increment_timestamp(stamp)
 
 /* increments a given timestamp if equal or greater than current time stamp,
    else returns the current time stamp. */
-char *
-get_updated_timestamp(orig_stamp)
-  char *orig_stamp;
+char *get_updated_timestamp (char *orig_stamp)
 {
   static char new_stamp[18];
   int         ret;
@@ -883,9 +811,7 @@ get_updated_timestamp(orig_stamp)
 /* examine the path if it is writable, if not split the paths, and again
    check if the directory section is writable. Returns a non-zero
    value on failure. */
-int
-examin_directory_writable(path)
-  char  *path;
+int examin_directory_writable (char *path)
 {
   char dir[MAX_FILE];
   char file[MAX_FILE];
@@ -918,9 +844,7 @@ examin_directory_writable(path)
 
 /* checks for the validity of timestamp string. Returns non-zero value
    on failure. */
-int
-examin_timestamp(stamp)
-  char *stamp;
+int examin_timestamp (char *stamp)
 {
   if (NOT_STR_EXISTS(stamp)) return ERW_EMTYSTR;
   if (!is_number_str(stamp)) return ERW_NUMSTR;
@@ -931,9 +855,7 @@ examin_timestamp(stamp)
 
 /* examine file name string format, make sure there is no directory by
    that name. Returns non-zero on failure. */
-int
-examin_file_name(value)
-  char *value;
+int examin_file_name (char *value)
 {
   if (NOT_STR_EXISTS(value)) return ERW_EMTYSTR;
   if (!is_no_whitespace_str(value)) return ERW_SPACESTR;
@@ -944,9 +866,7 @@ examin_file_name(value)
 
 /* examine directory name string format, make sure there is no file by
    that name. Returns non-zero on failure. */
-int
-examin_directory_name(value)
-  char *value;
+int examin_directory_name (char *value)
 {
   if (NOT_STR_EXISTS(value)) return ERW_EMTYSTR;
   if (!is_no_whitespace_str(value)) return ERW_SPACESTR;
@@ -957,9 +877,7 @@ examin_directory_name(value)
 
 /* examin if the given file name is a file on disk with executable
    file mode. */
-int
-examin_executable_name(value)
-  char *value;
+int examin_executable_name (char *value)
 {
   mode_t mode;
 
@@ -974,10 +892,10 @@ examin_executable_name(value)
 /* returns true if the given path is already in the paths_list. Otherwise
    it adds the path to the paths_list and returns false. */
 int
-dup_config_path_name(paths_list, path, var_name)
-  dl_list_type *paths_list;
-  char         *path;
-  char         *var_name;
+dup_config_path_name(
+  dl_list_type *paths_list,
+  char         *path,
+  char         *var_name)
 {
   int  not_done;
   char *item;
@@ -1009,8 +927,7 @@ dup_config_path_name(paths_list, path, var_name)
 }
 
 static dl_list_type *
-split_path_into_list(path)
-  char *path;
+split_path_into_list(char *path)
 {
   char         *token;
   dl_list_type *path_list;
@@ -1031,9 +948,9 @@ split_path_into_list(path)
 }
 
 static char *
-join_list_into_path(path_list, abs_path)
-  dl_list_type *path_list;
-  int          abs_path;
+join_list_into_path(
+  dl_list_type *path_list,
+  int          abs_path)
 {
   static char path[MAX_FILE];
   char        *str;
@@ -1065,8 +982,7 @@ join_list_into_path(path_list, abs_path)
 }
 
 static int
-reduce_path_list(path_list)
-  dl_list_type *path_list;
+reduce_path_list(dl_list_type *path_list)
 {
   char *token;
   int  not_done;
@@ -1095,9 +1011,7 @@ reduce_path_list(path_list)
 }
 
 /* removes any '..' in the given path */
-static char *
-get_reduced_path(path)
-  char *path;
+static char *get_reduced_path (char *path)
 {
   char         *newpath;
   dl_list_type *path_list;
@@ -1131,10 +1045,7 @@ get_reduced_path(path)
    root dir to check if the path is under root directory of the
    server. */
 
-int
-path_under_root_dir(path, rootdir)
-  char *path;
-  char *rootdir;
+int path_under_root_dir (char *path, char *rootdir)
 {
   char *newpath, fullpath[MAX_FILE];
 
@@ -1163,10 +1074,10 @@ path_under_root_dir(path, rootdir)
 
 /* returns true if it found the given path in the paths_list. */
 int
-in_config_path_list(paths_list, path, var_name)
-  dl_list_type *paths_list;
-  char         *path;
-  char         *var_name;
+in_config_path_list(
+  dl_list_type *paths_list,
+  char         *path,
+  char         *var_name)
 {
   int  not_done;
   char *item;
@@ -1195,10 +1106,10 @@ in_config_path_list(paths_list, path, var_name)
 
 /* Works on paths without '..' in them. */
 static int
-make_path_dirs(path, mode, paths_list)
-  char         *path;
-  int          mode;
-  dl_list_type *paths_list;
+make_path_dirs(
+  char         *path,
+  int          mode,
+  dl_list_type *paths_list)
 {
   int          not_done;
   char         *dirname;
@@ -1249,10 +1160,10 @@ make_path_dirs(path, mode, paths_list)
 
 /* open given filename for writing */
 FILE *
-open_file_to_write(filename, blk_time, paths_list)
-  char         *filename;
-  int          blk_time;
-  dl_list_type *paths_list;
+open_file_to_write(
+  char         *filename,
+  int          blk_time,
+  dl_list_type *paths_list)
 {
   char dir[MAX_FILE];
   char file[MAX_FILE];
@@ -1277,10 +1188,10 @@ open_file_to_write(filename, blk_time, paths_list)
 }
 
 int
-make_config_dir(dirname, mode, paths_list)
-  char         *dirname;
-  int          mode;
-  dl_list_type *paths_list;
+make_config_dir(
+  char         *dirname,
+  int          mode,
+  dl_list_type *paths_list)
 {
   char *newdir;
 
--- a/common/ip_network.c
+++ b/common/ip_network.c
@@ -12,12 +12,11 @@
 #include "common_regexps.h"
 #include "misc.h"
 #include "defines.h"
+#include "../regexp/regexp.h"
 
 /* Given an ipv4 string, remove zero padding (in place).  If this
    doesn't look like an IPv4 string, it will do nothing. */
-static void
-clean_ipv4_addr( str )
-  char *str;
+static void clean_ipv4_addr (char *str)
 {
   int o[4];
   int n;
@@ -49,10 +48,7 @@ clean_ipv4_addr( str )
 }
 
 /* address convert from ascii ip network string to netinfo structure */
-int
-addrstring_to_ni( addstr, ni )
-  char *addstr;
-  struct netinfo *ni;
+int addrstring_to_ni (char *addstr, struct netinfo *ni)
 {
 #ifdef HAVE_IPV6
   /* neither inet_pton nor inet_addr will convert zero-padded ipv4
@@ -92,10 +88,7 @@ addrstring_to_ni( addstr, ni )
 }
 
 /* Mask addr to prefix */
-void
-mask_addr_to_len( ni, len )
-  struct netinfo *ni;
-  int           len;
+void mask_addr_to_len (struct netinfo *ni, int len)
 {
   int numbytes, i;
 
@@ -122,10 +115,7 @@ mask_addr_to_len( ni, len )
                 
 /* compares two numerical IP addresses in network byte order (big endian)
    (-2 if address family mismatch, -1 if a < b, 0 if a = b, 1 if a > b) */
-int
-compare_addr(a, b)
-  struct netinfo *a;
-  struct netinfo *b;
+int compare_addr (struct netinfo *a, struct netinfo *b)
 {
   int i, numbytes;
 
@@ -148,9 +138,7 @@ compare_addr(a, b)
   return(0);
 }
 
-int
-is_network_valid_for_searching(value)
-  char *value;
+int is_network_valid_for_searching (char *value)
 {
   static regexp *net_prog = NULL;
 
@@ -169,9 +157,7 @@ is_network_valid_for_searching(value)
   }
 }
 
-int
-is_network_valid_for_index(line)
-  char *line;
+int is_network_valid_for_index (char *line)
 {
   static regexp *strict_net_prog = NULL;
   struct netinfo prefix;
@@ -192,9 +178,7 @@ is_network_valid_for_index(line)
   return FALSE;
 }
 
-int
-is_cidr_network(value)
-  char *value;
+int is_cidr_network (char *value)
 {
   static regexp *net_prog = NULL;
 
@@ -216,9 +200,7 @@ is_cidr_network(value)
 /* determine_network_len_from_policy: given a network IP number
    without an explicit prefix length, determine the prefix length by
    the first octet and presence of 0 octets. */
-int
-determine_network_len_from_policy(addr)
-  struct netinfo *addr;
+int determine_network_len_from_policy (struct netinfo *addr)
 {
   uint32_t *prefix;
   int      len = 32;
@@ -253,9 +235,7 @@ determine_network_len_from_policy(addr)
    low-order non-zero octets.  128.0.0.0 would yield 8, 128.1.0.0 would
    yield 16, 128.0.1.0 would yield 24, and so on */
 
-int
-determine_network_len_from_octets(addr)
-  struct netinfo *addr;
+int determine_network_len_from_octets (struct netinfo *addr)
 {
   int len = 32;
   int i;
@@ -274,10 +254,7 @@ determine_network_len_from_octets(addr)
 /* get_network_prefix_prefix_len_and_mask: This function parses
    network prefix and prefix length, given a string in quad-octet
    prefix/prefix length format */
-int
-get_network_prefix_and_len( str, ni )
-  char          *str;
-  struct netinfo *ni;
+int get_network_prefix_and_len (char *str, struct netinfo *ni)
 {
   char *buf;
   char *p;
@@ -329,10 +306,7 @@ get_network_prefix_and_len( str, ni )
   return(TRUE);
 }
 
-int
-write_network( str, ni )
-  char *str;
-  struct netinfo *ni;
+int write_network (char *str, struct netinfo *ni)
 {
   if (!str)
   {
@@ -345,11 +319,7 @@ write_network( str, ni )
 }
 
 
-char *
-ni_to_addrstring(ni, str, str_len)
-  struct netinfo        *ni;
-  char                  *str;
-  int                    str_len;
+char *ni_to_addrstring (struct netinfo *ni, char *str, int str_len)
 {
   if (ni->af == AF_INET)
   {
@@ -388,9 +358,7 @@ ni_to_addrstring(ni, str, str_len)
   return NULL;
 }
 
-char *
-natop( ni )
-  struct netinfo *ni;
+char *natop (struct netinfo *ni)
 {
   static char str[MAX_LINE];
 
--- a/common/log.c
+++ b/common/log.c
@@ -66,10 +66,10 @@ get_log_context()
 }
 
 int
-set_log_context(file, line_num, section)
-  char          *file;
-  long          line_num;
-  log_section   section;
+set_log_context(
+  char          *file,
+  long          line_num,
+  log_section   section)
 {
   if (STR_EXISTS(file))
   {
@@ -89,8 +89,7 @@ set_log_context(file, line_num, section)
   return TRUE;
 }
 
-void
-clear_log_context()
+void clear_log_context (void)
 {
   bzero(&context, sizeof(context));
 }
@@ -107,15 +106,12 @@ restore_log_context(log_context_struct *save)
   bcopy(save, &context, sizeof(context));
 }
 
-void
-inc_log_context_line_num(inc)
-  int inc;
+void inc_log_context_line_num (int inc)
 {
   context.cur_line_num += inc;
 }
 
-char *
-file_context_str()
+char *file_context_str (void)
 {
   static char buf[MAX_LINE];
 
@@ -203,8 +199,9 @@ log_warning(char *format, ...)
 
 /* gets hostname of the *client* */
 char *
-get_client_hostname(sock)
-  int sock;             /* peer socket */
+get_client_hostname (
+    int sock             /* peer socket */
+)
 {
   static char           buf[MAX_LINE];
   static int            tried_once = FALSE;
@@ -225,7 +222,7 @@ get_client_hostname(sock)
 
   tried_once = TRUE;
 
-  if (getpeername(sock, (struct sockaddr *)&name, &namelen) != 0)
+  if (getpeername(sock, (struct sockaddr *)&name, (socklen_t*)&namelen) != 0)
   {
     if( errno == EBADF || 
         errno == ENOTCONN || 
@@ -268,8 +265,7 @@ get_client_hostname(sock)
 }
 
 /* logs time of query */
-char *
-timestamp()
+char *timestamp (void)
 {
   time_t        now;
   struct tm     *ts;
@@ -290,8 +286,7 @@ timestamp()
 }
  
 char *
-section_to_name(section)
-  log_section  section;
+section_to_name(log_section  section)
 {
   char  *ret_val;
  
@@ -348,8 +343,7 @@ section_to_name(section)
 }
  
 char *
-level_to_name(local_level)
-  internal_log_levels local_level;
+level_to_name(internal_log_levels local_level)
 {
   switch(local_level)
   {
@@ -375,8 +369,7 @@ level_to_name(local_level)
 }
 
 int
-local_to_syslog(local_level)
-  internal_log_levels local_level;
+local_to_syslog(internal_log_levels local_level)
 {
   switch(local_level)
   {
@@ -405,8 +398,7 @@ local_to_syslog(local_level)
  
  
 char *
-get_log_filename(level)
-  internal_log_levels level;
+get_log_filename(internal_log_levels level)
 {
   char *ret;
 
@@ -455,8 +447,7 @@ get_log_filename(level)
   }
 }
  
-void
-setup_logging()
+void setup_logging (void)
 {
 #ifndef NO_SYSLOG
   openlog("rwhoisd", LOG_PID, get_log_facility());
@@ -470,8 +461,7 @@ setup_logging()
 /*
     get the value of log_setup variable
  */
-int
-get_log_setup()
+int get_log_setup (void)
 {       
   return( log_setup );
 }
@@ -479,9 +469,7 @@ get_log_setup()
 /* this function returns the error string corresponding to the error number
    given. It stuffs the error number into the string before returning. 
    The error numbers correspond to return values of examin_?? functions. */
-char *
-examin_error_string(err_num)
-  int err_num;
+char *examin_error_string (int err_num)
 {
   int         i;
   static char buff[BUFSIZ]; 
--- a/common/main_config.c
+++ b/common/main_config.c
@@ -36,12 +36,7 @@ static server_state_struct    save_server_state_data;
 /* canonicalize_conf_path: a wrapper around canonicalize path that
       fills in much of the required data, and changes the path "in
       place". */
-static int
-canonicalize_conf_path(path, path_len, is_file, null_allowed)
-  char  *path;
-  int   path_len;
-  int   is_file;
-  int   null_allowed;
+static int canonicalize_conf_path (char *path, int path_len, int is_file, int null_allowed)
 {
   int   status;
   char  canon_path[MAX_FILE + 1];
@@ -105,10 +100,7 @@ canonicalize_conf_path(path, path_len, is_file, null_allowed)
 
 /* read_main_config_file: read the main configuration file.  Does not
       take care of second pass validation (for now). */
-int
-read_main_config_file(config_file, chrooted)
-  char  *config_file;
-  int   chrooted;
+int read_main_config_file (char *config_file, int chrooted)
 {
   FILE  *fp;
   char  line[BUFSIZ + 1];
@@ -330,8 +322,7 @@ read_main_config_file(config_file, chrooted)
 }
 
 /* clean and default config data */
-void
-init_server_config_data()
+void init_server_config_data (void)
 {
   /* clear everything */
   bzero(&server_config_data, sizeof(server_config_data));
@@ -385,8 +376,7 @@ init_server_config_data()
 }
 
 /* initialize server state */
-void
-init_server_state()
+void init_server_state (void)
 {
 
   bzero(&server_state_data, sizeof(server_state_data));
@@ -401,8 +391,7 @@ init_server_state()
      canonicalize paths, and detect errors that can not be detected
      immediately; it will return TRUE if there were no fatal errors,
      FALSE if not. */
-int
-verify_server_config_data()
+int verify_server_config_data (void)
 {
   int   status;
 
@@ -478,8 +467,7 @@ verify_server_config_data()
 
 
 void
-display_server_config_data(file)
-  FILE  *file;
+display_server_config_data(FILE  *file)
 {
   fprintf(file, "--------------------------------\n");
 
@@ -613,8 +601,7 @@ display_server_config_data(file)
 }
 
 
-int
-save_server_state()
+int save_server_state (void)
 {
   bcopy(&server_state_data, &save_server_state_data,
         sizeof(save_server_state_data));
@@ -622,8 +609,7 @@ save_server_state()
   return TRUE;
 }
 
-int
-restore_server_state()
+int restore_server_state (void)
 {
   bcopy(&save_server_state_data, &server_state_data,
         sizeof(server_state_data));
@@ -635,9 +621,7 @@ restore_server_state()
 /* ---------------- The Guard Functions ----------------- */
 
 /* set_root_dir: We can actually detect errors on this one. */
-int
-set_root_dir(dir)
-  char  *dir;
+int set_root_dir (char *dir)
 {
   if (dir && *dir)
   {
@@ -663,14 +647,12 @@ set_root_dir(dir)
   return TRUE;
 }
 
-char *
-get_root_dir()
+char *get_root_dir (void)
 {
   return(server_config_data.root_dir);
 }
 
-int
-chdir_root_dir()
+int chdir_root_dir (void)
 {
   char  *dir = get_root_dir();
 
@@ -685,51 +667,40 @@ chdir_root_dir()
   return TRUE;
 }
 
-int
-set_bin_path(path)
-  char  *path;
+int set_bin_path (char *path)
 {
   strncpy(server_config_data.bin_path, path, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_bin_path()
+char *get_bin_path (void)
 {
   return(server_config_data.bin_path);
 }
 
-int
-set_notify_log(log)
-  char  *log;
+int set_notify_log (char *log)
 {
   strncpy(server_config_data.notify_log, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_notify_log()
+char *get_notify_log (void)
 {
   return(server_config_data.notify_log);
 }
 
-int
-set_log_default(file)
-  char *file;
+int set_log_default (char *file)
 {
   strncpy(server_config_data.log_default_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_log_default()
+char *get_log_default (void)
 {
   return(server_config_data.log_default_file);
 }
 
-int
-set_log_facility(facility)
-   char *facility;
+int set_log_facility (char *facility)
 {
   if (STR_EQ(facility,"LOG_KERN"))
   {
@@ -820,286 +791,224 @@ set_log_facility(facility)
   return(-1);
 }
 
-int
-get_log_facility()
+int get_log_facility (void)
 {
    return(server_config_data.log_facility);
 }
 
-int
-set_log_emerg(log)
-  char  *log;
+int set_log_emerg (char *log)
 {
   strncpy(server_config_data.log_emerg_file, log, MAX_FILE);
   return TRUE;
 }
-char *
-get_log_emerg()
+char *get_log_emerg (void)
 {
   return(server_config_data.log_emerg_file);
 }
 
-int
-set_log_alert(log)
-  char  *log;
+int set_log_alert (char *log)
 {
   strncpy(server_config_data.log_alert_file, log, MAX_FILE);
   return TRUE;
 }
-char *
-get_log_alert()
+char *get_log_alert (void)
 {
   return(server_config_data.log_alert_file);
 }
 
-int
-set_log_crit(log)
-  char  *log;
+int set_log_crit (char *log)
 {
   strncpy(server_config_data.log_crit_file, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_log_crit()
+char *get_log_crit (void)
 {
   return(server_config_data.log_crit_file);
 }
 
-int
-set_log_err(log)
-  char  *log;
+int set_log_err (char *log)
 {
   strncpy(server_config_data.log_err_file, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_log_err()
+char *get_log_err (void)
 {
   return(server_config_data.log_err_file);
 }
 
-int
-set_log_warn(log)
-  char  *log;
+int set_log_warn (char *log)
 {
   strncpy(server_config_data.log_warn_file, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_log_warn()
+char *get_log_warn (void)
 {
   return(server_config_data.log_warn_file);
 }
 
-int
-set_log_notice(log)
-  char  *log;
+int set_log_notice (char *log)
 {
   strncpy(server_config_data.log_notice_file, log, MAX_FILE);
   return TRUE;
 }
-char *
-get_log_notice()
+char *get_log_notice (void)
 {
   return(server_config_data.log_notice_file);
 }
 
-int
-set_log_info(log)
-  char  *log;
+int set_log_info (char *log)
 {
   strncpy(server_config_data.log_info_file, log, MAX_FILE);
   return TRUE;
 }
-char *
-get_log_info()
+char *get_log_info (void)
 {
   return(server_config_data.log_info_file);
 }
 
-int
-set_log_debug(log)
-  char  *log;
+int set_log_debug (char *log)
 {
   strncpy(server_config_data.log_debug_file, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_log_debug()
+char *get_log_debug (void)
 {
   return(server_config_data.log_debug_file);
 }
 
-int
-set_directive_file(file)
-  char *file;
+int set_directive_file (char *file)
 {
   strncpy(server_config_data.directive_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_directive_file()
+char *get_directive_file (void)
 {
   return(server_config_data.directive_file);
 }
 
-int
-set_x_directive_file(file)
-  char *file;
+int set_x_directive_file (char *file)
 {
   strncpy(server_config_data.x_directive_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_x_directive_file()
+char *get_x_directive_file (void)
 {
   return(server_config_data.x_directive_file);
 }
 
-int
-set_auth_area_file(file)
-  char  *file;
+int set_auth_area_file (char *file)
 {
   strncpy(server_config_data.auth_area_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_auth_area_file()
+char *get_auth_area_file (void)
 {
   return(server_config_data.auth_area_file);
 }
 
-int
-set_register_log(log)
-  char  *log;
+int set_register_log (char *log)
 {
   strncpy(server_config_data.register_log, log, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_register_log()
+char *get_register_log (void)
 {
   return(server_config_data.register_log);
 }
 
-int
-set_register_spool(spool)
-  char  *spool;
+int set_register_spool (char *spool)
 {
   strncpy(server_config_data.register_spool, spool, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_register_spool()
+char *get_register_spool (void)
 {
   return(server_config_data.register_spool);
 }
 
-int
-set_punt_file(file)
-  char  *file;
+int set_punt_file (char *file)
 {
   strncpy(server_config_data.punt_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_punt_file()
+char *get_punt_file (void)
 {
   return(server_config_data.punt_file);
 }
 
-int
-set_security_allow(file)
-  char  *file;
+int set_security_allow (char *file)
 {
   strncpy(server_config_data.security_allow, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_security_allow()
+char *get_security_allow (void)
 {
   return(server_config_data.security_allow);
 }
 
-int
-set_security_deny(file)
-  char  *file;
+int set_security_deny (char *file)
 {
   strncpy(server_config_data.security_deny, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_security_deny()
+char *get_security_deny (void)
 {
   return(server_config_data.security_deny);
 }
 
-int
-set_local_hostname(name)
-  char  *name;
+int set_local_hostname (char *name)
 {
   strncpy(server_config_data.hostname, name, MAX_LINE);
   return TRUE;
 }
 
-char *
-get_local_hostname()
+char *get_local_hostname (void)
 {
   return(server_config_data.hostname);
 }
 
-int
-set_process_userid(id)
-  char  *id;
+int set_process_userid (char *id)
 {
   strncpy(server_config_data.process_userid, id, MAX_LINE);
   return TRUE;
 }
 
-char *
-get_process_userid()
+char *get_process_userid (void)
 {
   return(server_config_data.process_userid);
 }
 
-int
-set_chrooted(val)
-  int   val;
+int set_chrooted (int val)
 {
   server_config_data.chrooted = val;
   return TRUE;
 }
 
-int
-set_chrooted_str(str)
-  char  *str;
+int set_chrooted_str (char *str)
 {
   server_config_data.chrooted = true_false(str);
   return TRUE;
 }
 
-int
-is_chrooted()
+int is_chrooted (void)
 {
   return(server_config_data.chrooted);
 }
 
 
-int
-set_use_syslog(str)
-  char  *str;
+int set_use_syslog (char *str)
 {
 #ifndef NO_SYSLOG
   server_config_data.use_syslog = FALSE;
@@ -1108,101 +1017,80 @@ set_use_syslog(str)
   return TRUE;
 }
 
-int
-is_syslog_used()
+int is_syslog_used (void)
 {
   return(server_config_data.use_syslog);
 }
 
-int
-set_default_deadman_time(sec)
-  int   sec;
+int set_default_deadman_time (int sec)
 {
   server_config_data.default_deadman_time = sec;
   return TRUE;
 }
 
-int
-get_default_deadman_time()
+int get_default_deadman_time (void)
 {
   return(server_config_data.default_deadman_time);
 }
 
-int
-set_max_hits_ceiling(hits)
-  int   hits;
+int set_max_hits_ceiling (int hits)
 {
   server_config_data.max_hits_ceiling = hits;
   return TRUE;
 }
 
-int
-get_max_hits_ceiling()
+int get_max_hits_ceiling (void)
 {
   return(server_config_data.max_hits_ceiling);
 }
 
-int
-set_max_hits_default(hits)
-  int   hits;
+int set_max_hits_default (int hits)
 {
   server_config_data.max_hits_default = hits;
   return TRUE;
 }
 
-int
-get_max_hits_default()
+int get_max_hits_default (void)
 {
   return(server_config_data.max_hits_default);
 }
 
-int
-set_port(p)
-  int   p;
+int set_port (int p)
 {
   server_config_data.port = p;
   return TRUE;
 }
 
-int
-get_port()
+int get_port (void)
 {
   return(server_config_data.port);
 }
 
-int
-set_root_server(val)
-  int   val;
+int set_root_server (int val)
 {
   server_config_data.root_server = val;
   return TRUE;
 }
 
-int
-set_root_server_str(str)
-  char  *str;
+int set_root_server_str (char *str)
 {
   server_config_data.root_server = true_false(str);
   return TRUE;
 }
 
-int
-is_root_server()
+int is_root_server (void)
 {
   return(server_config_data.root_server);
 }
 
 int
-set_server_type(type)
-  rwhois_server_type type;
+set_server_type(rwhois_server_type type)
 {
   server_config_data.server_type = type;
   return TRUE;
 }
 
-int
-set_server_type_str(str)
-  char *str;
+int set_server_type_str (char *str)
 
 {
   if (STR_EQ(str, "INETD") ) {
@@ -1222,8 +1110,7 @@ get_server_type()
 }
 
 /* is_daemon_server: true if DAEMON, false if not */
-int
-is_daemon_server()
+int is_daemon_server (void)
 {
   if (get_server_type() == DAEMON_SERVER) {
     return (TRUE);
@@ -1231,59 +1118,47 @@ is_daemon_server()
   return (FALSE);
 }
 
-int
-set_background(val)
-  int   val;
+int set_background (int val)
 {
   server_config_data.background = val;
   return TRUE;
 }
 
-int
-get_background()
+int get_background (void)
 {
   return server_config_data.background;
 }
 
-int
-set_verbosity(val)
-  int   val;
+int set_verbosity (int val)
 {
   server_config_data.verbose = val;
   return TRUE;
 }
 
-int
-get_verbosity()
+int get_verbosity (void)
 {
   return server_config_data.verbose;
 }
 
-int
-set_pid_file(file)
-  char  *file;
+int set_pid_file (char *file)
 {
   strncpy(server_config_data.pid_file, file, MAX_FILE);
   return TRUE;
 }
 
-char *
-get_pid_file()
+char *get_pid_file (void)
 {
   return(server_config_data.pid_file);
 }
 
-int
-set_server_contact(contact)
-  char *contact;
+int set_server_contact (char *contact)
 {
   strncpy(server_config_data.server_contact, contact, MAX_LINE);
 
   return TRUE;
 }
 
-char *
-get_server_contact()
+char *get_server_contact (void)
 {
   return(server_config_data.server_contact);
 }
@@ -1291,23 +1166,18 @@ get_server_contact()
 
 /* sever_state functions. */
 
-int
-set_hit_limit(limit)
-  int   limit;
+int set_hit_limit (int limit)
 {
   server_state_data.limit = limit;
   return TRUE;
 }
 
-int
-get_hit_limit()
+int get_hit_limit (void)
 {
   return(server_state_data.limit);
 }
 
-int
-set_holdconnect(val)
-  char *val;
+int set_holdconnect (char *val)
 {
   if(STR_EQ(val, "OFF")){
     server_state_data.holdconnect = FALSE;
@@ -1322,16 +1192,13 @@ set_holdconnect(val)
   return TRUE;
 }
 
-int
-get_holdconnect()
+int get_holdconnect (void)
 {
   return(server_state_data.holdconnect);
 }
 
 
-int
-set_forward(val)
-  char *val;
+int set_forward (char *val)
 {
   if (STR_EQ(val, "OFF"))
   {
@@ -1350,65 +1217,52 @@ set_forward(val)
   return TRUE;
 }
 
-int
-get_forward()
+int get_forward (void)
 {
   return(server_state_data.forward);
 }
 
 
-int
-set_display(mode)
-  char *mode;
+int set_display (char *mode)
 {
   strncpy(server_state_data.display, mode, MAX_LINE);
 
   return TRUE;
 }
 
-char *
-get_display()
+char *get_display (void)
 {
   return server_state_data.display;
 }
 
-int
-set_query_allow_wild(val)
-  int val;
+int set_query_allow_wild (int val)
 {
   server_config_data.query_allow_wild = val;
   return TRUE;
 }
 
-int
-get_query_allow_wild()
+int get_query_allow_wild (void)
 {
   return(server_config_data.query_allow_wild);
 }
 
-int
-set_query_allow_substr(val)
-  int val;
+int set_query_allow_substr (int val)
 {
   server_config_data.query_allow_substr = val;
   return TRUE;
 }
 
-int
-get_query_allow_substr()
+int get_query_allow_substr (void)
 {
   return(server_config_data.query_allow_substr);
 }
 
-int
-get_max_children()
+int get_max_children (void)
 {
   return(server_config_data.max_children);
 }
 
-int
-set_max_children(val)
-  int val;
+int set_max_children (int val)
 {
   server_config_data.max_children = val;
 
@@ -1416,45 +1270,36 @@ set_max_children(val)
 }
 
 
-int
-get_skip_referral_search()
+int get_skip_referral_search (void)
 {
   return(server_config_data.skip_referral_search);
 }
 
-int
-set_skip_referral_search(val)
-  int val;
+int set_skip_referral_search (int val)
 {
   server_config_data.skip_referral_search = val;
   return TRUE;
 }
 
 
-int
-get_listen_queue_length()
+int get_listen_queue_length (void)
 {
   return(server_config_data.listen_queue_length);
 }
 
-int
-set_listen_queue_length(val)
-  int val;
+int set_listen_queue_length (int val)
 {
   server_config_data.listen_queue_length = val;
   return TRUE;
 }
 
 
-int
-get_child_priority()
+int get_child_priority (void)
 {
   return(server_config_data.child_priority_offset);
 }
 
-int
-set_child_priority(val)
-  int val;
+int set_child_priority (int val)
 {
   server_config_data.child_priority_offset = val;
   return TRUE;
@@ -1462,8 +1307,7 @@ set_child_priority(val)
 
 /* returns the server type string associated with the server type */
 char *
-get_server_type_str(serv_type)
-  rwhois_server_type serv_type;
+get_server_type_str(rwhois_server_type serv_type)
 {
   switch (serv_type)
   {
@@ -1479,9 +1323,7 @@ get_server_type_str(serv_type)
 
 /* returns the server log facility string associated with the server log
    facility type */
-char *
-get_log_facility_str(facility_val)
-  int facility_val;
+char *get_log_facility_str (int facility_val)
 {
   char *facility_str = NULL;
 
@@ -1551,11 +1393,11 @@ get_log_facility_str(facility_val)
    configuration parameters. Also appends the main config file name
    to paths_list if it was successful in creating a file on disk. */
 int
-write_main_config_file(file, suffix, rwconf, paths_list)
-  char                  *file;
-  char                  *suffix;
-  rwhois_configs_struct *rwconf;
-  dl_list_type          *paths_list;
+write_main_config_file(
+  char                  *file,
+  char                  *suffix,
+  rwhois_configs_struct *rwconf,
+  dl_list_type          *paths_list)
 {
   FILE *fptr;
   char new_file[MAX_FILE];
@@ -1733,9 +1575,7 @@ write_main_config_file(file, suffix, rwconf, paths_list)
 }
 
 /* examine the format of user id string. Returns non-zero value if failed. */
-int
-examin_userid(uid)
-  char *uid;
+int examin_userid (char *uid)
 {
   if (NOT_STR_EXISTS(uid)) return ERW_EMTYSTR;
   if (!is_id_str(uid)) return ERW_IDSTR;
@@ -1745,9 +1585,7 @@ examin_userid(uid)
 
 /* examine the rwhois log file name format. Check if it is under the
    root directory. Returns non-zero value on failure. */
-int
-examin_rwlog_file(file)
-  char *file;
+int examin_rwlog_file (char *file)
 {
   int ret;
 
@@ -1759,9 +1597,7 @@ examin_rwlog_file(file)
 
 /* examine the rwhois config file name format. Check if it is under the
    root directory. Returns non-zero value on failure. */
-int
-examin_rwconf_file(file)
-  char *file;
+int examin_rwconf_file (char *file)
 {
   int ret;
 
@@ -1773,9 +1609,7 @@ examin_rwconf_file(file)
 
 /* examine the rwhois config directory name format. Check if it is under the
    root directory. Returns non-zero value on failure. */
-int
-examin_rwconf_dir(dir)
-  char *dir;
+int examin_rwconf_dir (char *dir)
 {
   int ret;
 
@@ -1787,9 +1621,7 @@ examin_rwconf_dir(dir)
 
 /* examine the rwhois executable program format. Check if it is
    an executable on disk. Returns non-zero value on failure. */
-int
-examin_rwexe_file(file)
-  char *file;
+int examin_rwexe_file (char *file)
 {
   int ret;
 
@@ -1801,9 +1633,7 @@ examin_rwexe_file(file)
 
 /* examine the rwhois executable program format. Check if it is
    an executable on disk. Returns non-zero value on failure. */
-int
-examin_server_contact(contact)
-  char *contact;
+int examin_server_contact (char *contact)
 {
   int ret;
 
@@ -1815,8 +1645,7 @@ examin_server_contact(contact)
 
 /* verify the contents of main server configuration variables.
    Returns false if any errors encountered. */
-int
-verify_main_config()
+int verify_main_config (void)
 {
   int errnum;
 
@@ -2054,8 +1883,7 @@ verify_main_config()
    to the paths_list. Class parse-programs, log file names are no added
    considered here. */
 int
-verify_main_config_paths(paths_list)
-  dl_list_type *paths_list;
+verify_main_config_paths(dl_list_type *paths_list)
 {
   int ret = 0;
 
@@ -2093,8 +1921,7 @@ verify_main_config_paths(paths_list)
    are already in the configuration paths_list. Returns non-zero value
    on failure. */
 int
-verify_non_admin_paths(paths_list)
-  dl_list_type *paths_list;
+verify_non_admin_paths(dl_list_type *paths_list)
 {
   int ret = 0;
 
--- a/common/misc.c
+++ b/common/misc.c
@@ -19,10 +19,10 @@
       trailing terminating characters from the line. Returns a pointer
       to the buffer itself */
 char *
-readline(fp, buffer, size)
-  FILE *fp;
-  char *buffer;
-  int  size;
+readline(
+  FILE *fp,
+  char *buffer,
+  int  size)
 {
   if (! fgets(buffer, size, fp))
   {
@@ -43,9 +43,7 @@ readline(fp, buffer, size)
 
 /* new_record: tests to see if 'line' is a record separator.  Returns
       TRUE if it is, FALSE if not */
-int
-new_record(line)
-  char *line;
+int new_record (char *line)
 {
   if (!line || !*line)
   {
@@ -64,11 +62,7 @@ new_record(line)
 
 /* parse_line: splits a <tag>: <datum> line into its respective
       components. */
-int
-parse_line(line, tag, datum)
-  char *line;
-  char *tag;
-  char *datum;
+int parse_line (char *line, char *tag, char *datum)
 {
   char *colon = NULL;
   char *d_ptr = NULL;
@@ -110,12 +104,7 @@ parse_line(line, tag, datum)
 
 /* delimstr: retrieves 'cnt' delimiters from mainbuf into
       cpbuf. Returns TRUE if successful, FALSE if not. */
-int
-delimstr(mainbuf, delim, cpbuf, cnt)
-  char *mainbuf;
-  char *delim;
-  char *cpbuf;
-  int  cnt;
+int delimstr (char *mainbuf, char *delim, char *cpbuf, int cnt)
 {
   int           i           = 0;
   char          *token;
@@ -162,10 +151,7 @@ delimstr(mainbuf, delim, cpbuf, cnt)
     next_cp is set to point to after the word, and the function
     returns the word if found, else NULL (with the dest buffer
     unchanged). */
-char *
-get_word(cp, buf)
-  char *cp;
-  char *buf;
+char *get_word (char *cp, char *buf)
 {
   char *original_buf = buf;
 
@@ -194,12 +180,7 @@ get_word(cp, buf)
 
 
 /* paste: pastes the new info into the query string */
-void
-paste(line, cut_start, cut_end, rpl)
-  char *line;
-  char *cut_start;
-  char *cut_end;
-  char *rpl;
+void paste (char *line, char *cut_start, char *cut_end, char *rpl)
 
 {
   char  *cp             = line;
@@ -218,9 +199,7 @@ paste(line, cut_start, cut_end, rpl)
 }
 
 /* on_off: return the ascii equivalents to the boolean argument */
-char *
-on_off(b)
-  int b;
+char *on_off (int b)
 {
   static char *on  = "ON";
   static char *off = "OFF";
@@ -237,9 +216,7 @@ on_off(b)
 
 /* true_false: returns TRUE if the string is set to an acceptable true
       value: "true", "yes", 'on".  FALSE otherwise. */
-int
-true_false(b)
-  char *b;
+int true_false (char *b)
 {
   trim(b);
   
@@ -253,9 +230,7 @@ true_false(b)
   }
 }
 
-char *
-true_false_str(b)
-  int   b;
+char *true_false_str (int b)
 {
   if (b)
     return "TRUE";
@@ -265,12 +240,7 @@ true_false_str(b)
 
 /* get_tuple: parses a <tag1>:<tag2>:<datum> line. Returns TRUE if it
       succeeded, FALSE if not */
-int
-get_tuple(tag1, tag2, data, line)
-  char *tag1;
-  char *tag2;
-  char *data;
-  char *line;
+int get_tuple (char *tag1, char *tag2, char *data, char *line)
 {
   char str[MAX_LINE];
 
@@ -285,11 +255,7 @@ get_tuple(tag1, tag2, data, line)
 }
 
 
-int
-split_arg_list(list, argcptr, argvptr)
-  char *list;
-  int  *argcptr;
-  char ***argvptr;
+int split_arg_list (char *list, int *argcptr, char ***argvptr)
 {
     char            **argv;
     register char   *p;
@@ -383,13 +349,7 @@ split_arg_list(list, argcptr, argvptr)
      will avoid adding NULL elements to the middle of the list and
      terminate the list with a NULL array element.  free argv[0] and
      argv when done (free_arg_list). */
-int
-split_list(list, sep, max_fields, argcptr, argvptr)
-  char  *list;
-  char  sep;
-  int   max_fields;
-  int   *argcptr;
-  char  ***argvptr;
+int split_list (char *list, int sep, int max_fields, int *argcptr, char ***argvptr)
 {
   char          **argv;
   register char *p;
@@ -452,9 +412,7 @@ split_list(list, sep, max_fields, argcptr, argvptr)
   return TRUE;
 }
 
-void
-free_arg_list(argv)
-  char **argv;
+void free_arg_list (char **argv)
 {
   /* first, if possible, free argv[0], which should be the start of
      the copied list string */
@@ -474,8 +432,7 @@ free_arg_list(argv)
 /* The "safe" memory routines */
 
 void *
-xmalloc(bytes)
-  size_t bytes;
+xmalloc(size_t bytes)
 {
   char *cp;
  
@@ -495,9 +452,9 @@ xmalloc(bytes)
 }
 
 void *
-xcalloc(nelem, size)
-  size_t nelem;
-  size_t size;
+xcalloc(
+  size_t nelem,
+  size_t size)
 {
   char  *cp;
 
@@ -521,9 +478,9 @@ xcalloc(nelem, size)
 }
 
 void *
-xrealloc(ptr, bytes)
-  void      *ptr;
-  size_t    bytes;
+xrealloc(
+  void      *ptr,
+  size_t    bytes)
 {
   char *cp;
  
@@ -546,9 +503,7 @@ xrealloc(ptr, bytes)
   return(cp);
 }
 
-char *
-xstrdup (str)
-  const char *str;
+char *xstrdup (const char *str)
 {
   char *s;
  
@@ -564,9 +519,9 @@ xstrdup (str)
 }
 
 void *
-xmemdup(buf, bytes)
-  const void    *buf;
-  size_t        bytes;
+xmemdup(
+  const void    *buf,
+  size_t        bytes)
 {
   void  *b;
   
@@ -583,11 +538,11 @@ xmemdup(buf, bytes)
 
 
 char *
-regncpy(result, prog, item, len)
-  char   *result;
-  regexp *prog;
-  int    item;
-  int    len;
+regncpy(
+  char   *result,
+  regexp *prog,
+  int    item,
+  int    len)
 {
   int   slice_length;
   
@@ -600,8 +555,7 @@ regncpy(result, prog, item, len)
   return(result);
 }
 
-void
-randomize()
+void randomize (void)
 {
   int seed;
 
@@ -609,8 +563,7 @@ randomize()
   srand(seed);
 }
 
-char *
-generate_salt()
+char *generate_salt (void)
 {
   int         r[2]; 
   static char s[3];
--- a/common/misc.h
+++ b/common/misc.h
@@ -37,8 +37,7 @@ int get_tuple PROTO((char *tag1, char *tag2, char *data, char *line));
 
 int split_arg_list PROTO((char *list, int *argcptr, char ***argvptr));
 
-int split_list PROTO((char *list, char sep, int max_fields,
-                      int *argcptr, char ***argvptr));
+int split_list (char *list, int sep, int max_fields, int *argcptr, char ***argvptr);
 
 void free_arg_list PROTO((char **argv));
 
--- a/common/procutils.c
+++ b/common/procutils.c
@@ -19,10 +19,7 @@
 #define MAX_PATH_LEN    1024
 #define PATH_STR        "PATH"
 
-int
-initialize_environment_list(envptr, env_size)
-  char  ***envptr;
-  int   env_size;
+int initialize_environment_list (char ***envptr, int env_size)
 {
   char  **env;
 
@@ -33,12 +30,7 @@ initialize_environment_list(envptr, env_size)
   return TRUE;
 }
 
-int
-add_env_value(env, env_size, var, value)
-  char  **env;
-  int   env_size;
-  char  *var;
-  char  *value;
+int add_env_value (char **env, int env_size, char *var, char *value)
 {
   int   i;
   char  buf[MAX_LINE];
@@ -69,9 +61,7 @@ add_env_value(env, env_size, var, value)
 }
 
 
-void
-free_environment_list(env)
-  char  **env;
+void free_environment_list (char **env)
 {
   int   i = 0;
   
@@ -85,10 +75,7 @@ free_environment_list(env)
 
 /* run_program: runs the program 'program', using parameters 'param'.
    It also passes on the environment. */
-int
-run_program(program, param)
-  char *program;
-  char *param;
+int run_program (char *program, char *param)
 {
   extern char   **environ;
   char          **myenv;
@@ -183,10 +170,7 @@ run_program(program, param)
 /* run_env_program: like "run_program", but explicitly sets additional
    environment variables; also, it will take the arguments in argv,
    argc format. */
-int
-run_env_program(argv, envargv)
-  char  **argv;
-  char  **envargv;
+int run_env_program (char **argv, char **envargv)
 {
   char          **myenv;
   extern char   **environ;
--- a/common/punt_ref.c
+++ b/common/punt_ref.c
@@ -27,8 +27,7 @@ static int count_punt_ref_entries PROTO((dl_list_type *ref_list, char *punt));
 
 /* create and setup punt-referral list. */
 static int
-create_punt_ref(ref_list)
-  dl_list_type **ref_list;
+create_punt_ref(dl_list_type **ref_list)
 {
   if (!ref_list || *ref_list) return FALSE;
 
@@ -45,8 +44,7 @@ create_punt_ref(ref_list)
 
 /* verifies the contents of punt referral structure. */
 static int
-verify_punt_ref(referral)
-  punt_ref_struct *referral;
+verify_punt_ref(punt_ref_struct *referral)
 {
   int ret;
 
@@ -64,9 +62,9 @@ verify_punt_ref(referral)
 
 /* count the number of times a punt-referral was found in the list. */
 static int
-count_punt_ref_entries(ref_list, punt)
-  dl_list_type *ref_list;
-  char *punt;
+count_punt_ref_entries(
+  dl_list_type *ref_list,
+  char *punt)
 {
   int not_done, count;
   punt_ref_struct *referral;
@@ -101,9 +99,7 @@ count_punt_ref_entries(ref_list, punt)
 
 /* examins punt referal string format. Looks for two formats of
    punt-referral. Returns non-zero value on failure. */
-int
-examin_punt_ref(punt_str)
-  char *punt_str;
+int examin_punt_ref (char *punt_str)
 {
   static regexp *old_ref_exp = NULL;
   static regexp *url_exp     = NULL;
@@ -131,9 +127,9 @@ examin_punt_ref(punt_str)
 /* reads punt referral information from file. Creates the punt-referral
    list. */
 int
-read_punt_file (file, ref_list)
-  char         *file;
-  dl_list_type **ref_list;
+read_punt_file (
+  char         *file,
+  dl_list_type **ref_list)
 {
   FILE         *fp              = NULL;
   char         line[BUFSIZ];
@@ -194,11 +190,11 @@ read_punt_file (file, ref_list)
 /* write punt referral information to a file on disk. Uses suffix to create
    a new file name. Adds the created file name to the paths_list. */
 int
-write_punt_file(file, suffix, ref_list, paths_list)
-  char         *file;
-  char         *suffix;
-  dl_list_type *ref_list;
-  dl_list_type *paths_list;
+write_punt_file(
+  char         *file,
+  char         *suffix,
+  dl_list_type *ref_list,
+  dl_list_type *paths_list)
 {
   FILE            *fp;
   int             not_done;
@@ -237,8 +233,7 @@ write_punt_file(file, suffix, ref_list, paths_list)
 /* verify the contents of the rwhois punt-referral list. Check for any
    duplicates in the list. */
 int
-verify_punt_ref_list(ref_list)
-  dl_list_type *ref_list;
+verify_punt_ref_list(dl_list_type *ref_list)
 {
   int             not_done;
   punt_ref_struct *referral;
@@ -275,8 +270,7 @@ verify_punt_ref_list(ref_list)
 
 /* initialize the punt-referral list with defaults. */
 int
-def_init_punt_ref(ref_list)
-  dl_list_type **ref_list;
+def_init_punt_ref(dl_list_type **ref_list)
 {
   if (!ref_list) return FALSE;
 
@@ -294,8 +288,7 @@ def_init_punt_ref(ref_list)
 
 /* free-up punt referral information structure */
 int
-destroy_punt_ref_data(referral)
-  punt_ref_struct *referral;
+destroy_punt_ref_data(punt_ref_struct *referral)
 {
 
   if (!referral) return TRUE;
@@ -312,8 +305,7 @@ destroy_punt_ref_data(referral)
 
 /* free-up the complete punt-referral list. */
 void
-destroy_punt_ref_list(ref_list)
-  dl_list_type **ref_list;
+destroy_punt_ref_list(dl_list_type **ref_list)
 {
   if (!ref_list) return;
 
@@ -323,9 +315,9 @@ destroy_punt_ref_list(ref_list)
 
 /* add punt-referral (if not already in the list) to the list. */
 int
-add_punt_ref(ref_list, punt_str)
-  dl_list_type **ref_list;
-  char         *punt_str;
+add_punt_ref(
+  dl_list_type **ref_list,
+  char         *punt_str)
 {
   int             ret;
   punt_ref_struct *referral;
@@ -365,9 +357,9 @@ add_punt_ref(ref_list, punt_str)
 /* searches for a punt-referral in the list. Returns the punt-referral
    structure that matched else returns NULL. */
 punt_ref_struct *
-find_punt_ref(ref_list, punt)
-  dl_list_type *ref_list;
-  char         *punt;
+find_punt_ref(
+  dl_list_type *ref_list,
+  char         *punt)
 {
   int             not_done;
   punt_ref_struct *referral = NULL;
@@ -392,9 +384,9 @@ find_punt_ref(ref_list, punt)
 
 /* delete a punt referral from the list. */
 int
-del_punt_ref(ref_list, punt)
-  dl_list_type **ref_list;
-  char         *punt;
+del_punt_ref(
+  dl_list_type **ref_list,
+  char         *punt)
 {
   if (!ref_list || !punt || !*punt) return FALSE;
 
--- a/common/read_config.c
+++ b/common/read_config.c
@@ -33,10 +33,7 @@ static void remove_tmp_config PROTO((char *suffix, dl_list_type *paths_list));
 /* ------------------- Public Functions -------------------- */
 
 /* read_all_config_files: get all the possible configuration */
-int
-read_all_config_files(config_file, chrooted)
-  char *config_file;
-  int  chrooted;
+int read_all_config_files (char *config_file, int chrooted)
 {
   
   /* read the main config file (rwhois.conf) to get the every location */
@@ -93,10 +90,10 @@ read_all_config_files(config_file, chrooted)
    directive allow and deny files. Does a check on the configuration after
    it is read-in. */
 int
-read_rwhois_config_files(config_file, rwconf, chrooted)
-  char                  *config_file; 
-  rwhois_configs_struct *rwconf;
-  int                   chrooted;
+read_rwhois_config_files(
+  char                  *config_file,
+  rwhois_configs_struct *rwconf,
+  int                   chrooted)
 {
   char         *punt_file;
   char         *allow_file;
@@ -166,10 +163,10 @@ read_rwhois_config_files(config_file, rwconf, chrooted)
    backup of the old configuration ofcourse. Removes temporary
    configuration if unsuccessful. */
 int
-write_all_config_files(config_file, suffix, rwconf)
-  char                  *config_file; 
-  char                  *suffix;
-  rwhois_configs_struct *rwconf;
+write_all_config_files(
+  char                  *config_file,
+  char                  *suffix,
+  rwhois_configs_struct *rwconf)
 {
   char         *dir_file;
   char         *xdir_file;
@@ -293,8 +290,7 @@ write_all_config_files(config_file, suffix, rwconf)
    complete rwhois configuration. Also calls a function to verify that
    there is no repeated usage of file names in the configuration. */
 int
-verify_all_config(rwconf)
-  rwhois_configs_struct *rwconf;
+verify_all_config(rwhois_configs_struct *rwconf)
 {
   dl_list_type *dir_allow = rwconf->dir_allow;
   dl_list_type *dir_deny  = rwconf->dir_deny;
@@ -361,8 +357,7 @@ verify_all_config(rwconf)
    destroy/free-up all rwhois configuration.
 */
 void
-destroy_all_config(rwconf)
-  rwhois_configs_struct *rwconf;
+destroy_all_config(rwhois_configs_struct *rwconf)
 {
   /* destroy directive and extended directive list list */
   destroy_directive_list();
@@ -385,8 +380,7 @@ destroy_all_config(rwconf)
 
 /* initialize the rwhois configuration with defaults */
 int
-def_init_all_config(rwconf)
-  rwhois_configs_struct *rwconf;
+def_init_all_config(rwhois_configs_struct *rwconf)
 {
   /* destroy all configuration first */
   destroy_all_config(rwconf);
@@ -432,8 +426,7 @@ def_init_all_config(rwconf)
    admin server do not overwrite files written-out by rwhois server.
    Since the log files are opened in append mode, the log file names need
    not be unique. */
-static int
-verify_all_path_names()
+static int verify_all_path_names (void)
 {
   int          ret = 0;
   dl_list_type *paths_list = NULL;
@@ -467,9 +460,9 @@ verify_all_path_names()
    use of the temporary configurations file list 'paths_list' in 
    deciding which files need to be renamed for new configuration. */
 static int 
-moveto_new_configuration(suffix, paths_list)
-  char *suffix;
-  dl_list_type *paths_list;
+moveto_new_configuration(
+  char *suffix,
+  dl_list_type *paths_list)
 {
   int not_done, idx, len;
   char *path, file[MAX_FILE], bkp_file[MAX_FILE];
@@ -562,9 +555,9 @@ moveto_new_configuration(suffix, paths_list)
 /* remove all temorary (new) configuration files/directories 
    (in the paths_list) from disk. */
 static void
-remove_tmp_config(suffix, paths_list)
-  char         *suffix;
-  dl_list_type *paths_list;
+remove_tmp_config(
+  char         *suffix,
+  dl_list_type *paths_list)
 {
   int  idx;
   int  len;
--- a/common/schema.c
+++ b/common/schema.c
@@ -38,11 +38,7 @@ static dl_list_type *class_ref_list = NULL;
 
 /* -------------------- LOCAL FUNCTIONS ------------------- */
 
-static int
-add_class_alias(alias_array, num_aliases, alias)
-  char ***alias_array;
-  int  *num_aliases;
-  char *alias;
+static int add_class_alias (char ***alias_array, int *num_aliases, char *alias)
 {
   int   i;
   char  **array = *alias_array;
@@ -77,9 +73,9 @@ add_class_alias(alias_array, num_aliases, alias)
    any duplicate use of class names and class aliases across the authority
    area. */
 static int 
-verify_class(aa, class)
-  auth_area_struct *aa;
-  class_struct *class;
+verify_class(
+  auth_area_struct *aa,
+  class_struct *class)
 {
   int i, errnum; 
  
@@ -168,9 +164,9 @@ verify_class(aa, class)
 /* count the number of times a class name occurs in the authority area
    class list. Looks at the aliases as well. */
 static int
-count_class_entries(class_list, class_name)
-  dl_list_type *class_list;
-  char *class_name;
+count_class_entries(
+  dl_list_type *class_list,
+  char *class_name)
 {
   int          not_done;
   int          i, count = 0;
@@ -211,9 +207,9 @@ count_class_entries(class_list, class_name)
 
 /* append a valid class to the authority area class list. */
 static int
-append_class( class, aa )
-  class_struct     *class;
-  auth_area_struct *aa;
+append_class(
+  class_struct     *class,
+  auth_area_struct *aa)
 {
   dl_list_type *class_list;
   class_struct *tmp_class;
@@ -245,8 +241,8 @@ append_class( class, aa )
 /* reads the main schema/object configuration file.  Returns TRUE if
      successful, FALSE otherwise.  */
 int
-read_schema(aa)
-  auth_area_struct *aa;
+read_schema(
+  auth_area_struct *aa)
 {
   char                  line[MAX_LINE];
   char                  tag[MAX_TEMPLATE_DESC];
@@ -435,10 +431,10 @@ read_schema(aa)
 }
 
 int
-add_class(schema, class, aa)
-  schema_struct    *schema;
-  class_struct     *class;
-  auth_area_struct *aa;
+add_class(
+  schema_struct    *schema,
+  class_struct     *class,
+  auth_area_struct *aa)
 {
   class_struct       *tmp_class;
   dl_list_type       *class_list = &(schema->class_list);
@@ -503,9 +499,9 @@ add_class(schema, class, aa)
 
 /* add class to class_ref_list */
 int
-add_global_class(class, aa)
-  class_struct      *class;
-  auth_area_struct  *aa;
+add_global_class(
+  class_struct      *class,
+  auth_area_struct  *aa)
 {
   class_ref_struct  *ref;
   class_ref_struct  *alias_ref;
@@ -588,25 +584,25 @@ add_global_class(class, aa)
 
 
 dl_list_type *
-get_class_list(schema)
-  schema_struct *schema;
+get_class_list(
+  schema_struct *schema)
 {
   return(&(schema->class_list));
 }
 
 
 dl_list_type *
-get_schema_attribute_ref_list(schema)
-  schema_struct *schema;
+get_schema_attribute_ref_list(
+  schema_struct *schema)
 {
   return(&(schema->attribute_ref_list));
 }
 
 
 class_struct *
-find_class_by_name(schema, name)
-  schema_struct  *schema;
-  char           *name;
+find_class_by_name(
+  schema_struct  *schema,
+  char           *name)
 {
   dl_list_type  *list;
   class_struct  *class;
@@ -648,9 +644,9 @@ find_class_by_name(schema, name)
 
 
 class_struct *
-find_class_by_id(schema, id)
-  schema_struct *schema;
-  int           id;
+find_class_by_id(
+  schema_struct *schema,
+  int           id)
 {
   dl_list_type  *list;
   class_struct  *class;
@@ -682,8 +678,8 @@ find_class_by_id(schema, id)
 
 
 void
-display_class(class)
-  class_struct  *class;
+display_class(
+  class_struct  *class)
 {
   if (!class) return ;
 
@@ -700,8 +696,8 @@ display_class(class)
 
 
 void
-display_schema(schema)
-  schema_struct *schema;
+display_schema(
+  schema_struct *schema)
 {
   int   not_done;
 
@@ -718,14 +714,14 @@ display_schema(schema)
       printf("   --------------------\n");
     }
   }
-  /* don't have to display attribute_ref_list */ 
+  /* don't have to display attribute_ref_list */
 }
 
 
 /* search class_ref_list */
 class_ref_struct *
-find_global_class_by_name(name)
-  char    *name;
+find_global_class_by_name(
+  char    *name)
 {
   int                   not_done;
   int                   i;
@@ -764,8 +760,8 @@ find_global_class_by_name(name)
 /* ---------------- Destructor Components ------------- */
 
 int
-destroy_class_data(class)
-  class_struct  *class;
+destroy_class_data(
+  class_struct  *class)
 {
   int i;
 
@@ -823,8 +819,8 @@ destroy_class_data(class)
 
 
 int
-destroy_schema_data(schema)
-  schema_struct *schema;
+destroy_schema_data(
+  schema_struct *schema)
 {
   if (!schema) return TRUE;
 
@@ -839,9 +835,9 @@ destroy_schema_data(schema)
 
 /* destroy_class_ref_data:
  */
-int 
-destroy_class_ref_data( class_ref )
-  class_ref_struct      *class_ref;
+int
+destroy_class_ref_data(
+  class_ref_struct      *class_ref)
 {
   int    i;
 
@@ -872,8 +868,7 @@ destroy_class_ref_data( class_ref )
   return TRUE;
 }
 
-int
-destroy_class_ref_list()
+int destroy_class_ref_list (void)
 {
   dl_list_destroy(class_ref_list);
   class_ref_list = NULL;
@@ -883,11 +878,11 @@ destroy_class_ref_list()
 /* write authority area schema file, and class attributes. Add the file
    names to 'paths_list' if created on disk. */
 int 
-write_schema_file(file, suffix, aa, paths_list)
-  char             *file;
-  char             *suffix;
-  auth_area_struct *aa;
-  dl_list_type     *paths_list;
+write_schema_file(
+  char             *file,
+  char             *suffix,
+  auth_area_struct *aa,
+  dl_list_type     *paths_list)
 {
   int           i;
   int           not_done;
@@ -976,9 +971,7 @@ write_schema_file(file, suffix, aa, paths_list)
 
 /* examine the validity of schema version string. Returns non-zero value
    on failure */
-int
-examin_schema_version(version)
-  char *version;
+int examin_schema_version (char *version)
 {
   int ret;
 
@@ -989,9 +982,7 @@ examin_schema_version(version)
 
 /* examine the validity of class name string. 
    Returns non-zero value on failure */
-int
-examin_class_name(name)
-  char *name;
+int examin_class_name (char *name)
 {
   if (NOT_STR_EXISTS(name)) return ERW_EMTYSTR;
   if (!is_id_str(name)) return ERW_IDSTR;
@@ -1001,9 +992,7 @@ examin_class_name(name)
 
 /* examine the validity of class data directory. Returns non-zero value on
    failure */
-int
-examin_class_db_dir(path)
-  char *path;
+int examin_class_db_dir (char *path)
 {
   int ret;
 
@@ -1017,9 +1006,7 @@ examin_class_db_dir(path)
 /* examine the validity of attribute file name. Also checks if the
    file name is under the root directory. Returns non-zero value on
    failure. */
-int
-examin_class_attr_file(path)
-  char *path;
+int examin_class_attr_file (char *path)
 {
   int ret;
 
@@ -1033,9 +1020,7 @@ examin_class_attr_file(path)
 /* examine the validity of class parse program. If not found at the given
    path search in the bin-path of the server. Also checks if the program
    is an executable file on disk. Returns non-zero value on failure. */
-int
-examin_class_parse_prog(path)
-  char *path;
+int examin_class_parse_prog (char *path)
 {
   int  ret = 0;
   char new_path[MAX_FILE];
@@ -1066,9 +1051,9 @@ examin_class_parse_prog(path)
 
 /* verify the authority area schema. Makes sure atleast one class is
    defined in the schema. */
-int 
-verify_schema(aa)
-  auth_area_struct *aa;
+int
+verify_schema(
+  auth_area_struct *aa)
 {
   int           not_done;
   class_struct  *class;
@@ -1103,9 +1088,9 @@ verify_schema(aa)
    then appends the created class to the class list of authority
    area. */
 int 
-create_class(class, aa)
-  class_struct     *class;
-  auth_area_struct *aa;
+create_class(
+  class_struct     *class,
+  auth_area_struct *aa)
 {
   int              not_done;
   int              i;
@@ -1229,8 +1214,8 @@ create_class(class, aa)
 
 /* sets a new class schema version */
 int
-update_schema_version(class)
-  class_struct *class;
+update_schema_version(
+  class_struct *class)
 {
   char *tmp_ver;
 
@@ -1249,10 +1234,10 @@ update_schema_version(class)
 /* add a new class after making sure the name does not clash with any
    other class name or class alias. */
 int
-add_new_class_alias(aa, class, alias)
-  auth_area_struct *aa;
-  class_struct     *class;
-  char             *alias;
+add_new_class_alias(
+  auth_area_struct *aa,
+  class_struct     *class,
+  char             *alias)
 {
   /* bad parameters */
   if (!aa || !class || !alias || !*alias) return FALSE;
@@ -1273,9 +1258,9 @@ add_new_class_alias(aa, class, alias)
    Log error if path already in the list. Returns non-zero value on
    failure. */
 int
-verify_all_class_paths(paths_list, aa)
-  dl_list_type     *paths_list;
-  auth_area_struct *aa;
+verify_all_class_paths(
+  dl_list_type     *paths_list,
+  auth_area_struct *aa)
 {
   int          ret = 0;
   int          not_done;
@@ -1318,9 +1303,9 @@ verify_all_class_paths(paths_list, aa)
    configuration. Don't want to overwrite something not written out
    by admin server. */
 int
-verify_class_parse_progs(paths_list, aa)
-  dl_list_type     *paths_list;
-  auth_area_struct *aa;
+verify_class_parse_progs(
+  dl_list_type     *paths_list,
+  auth_area_struct *aa)
 {
   int          ret = 0;
   int          not_done;
--- a/common/strerror.c
+++ b/common/strerror.c
@@ -500,8 +500,7 @@ BUGS
 
 */
 
-static void
-init_error_tables ()
+static void init_error_tables (void)
 {
   const struct error_info *eip;
   int nbytes;
@@ -586,8 +585,7 @@ DESCRIPTION
 
 */
 
-int
-errno_max ()
+int errno_max (void)
 {
   int maxsize;
 
@@ -629,9 +627,7 @@ DESCRIPTION
 
 */
 
-char *
-strerror (errnoval)
-  int errnoval;
+char *strerror (int errnoval)
 {
   char *msg;
   static char buf[32];
@@ -698,9 +694,7 @@ BUGS
 
 */
 
-char *
-strerrno (errnoval)
-  int errnoval;
+char *strerrno (int errnoval)
 {
   char *name;
   static char buf[32];
@@ -747,9 +741,7 @@ DESCRIPTION
 
 */
 
-int
-strtoerrno (name)
-  char *name;
+int strtoerrno (char *name)
 {
   int errnoval = 0;
 
@@ -781,7 +773,7 @@ strtoerrno (name)
 
 #ifdef MAIN
 
-main ()
+int main (void)
 {
   int errn;
   int errnmax;
--- a/common/strutil.c
+++ b/common/strutil.c
@@ -20,10 +20,7 @@ static int is_id_char PROTO((char value));
 
 /* stripchar: Strips out all occurences of a specific character (in
    place) */
-char *
-stripchar(str, ch)
-  char *str;
-  char ch;
+char *stripchar (char *str, char ch)
 {
   int i;
   int j;
@@ -50,10 +47,7 @@ stripchar(str, ch)
 
 /* strip_trailing: strips any characters matching ch off of the end of
    a string. */
-char *
-strip_trailing(str, ch)
-  char *str;
-  char ch;
+char *strip_trailing (char *str, char ch)
 {
   int i;
   int len;
@@ -75,10 +69,7 @@ strip_trailing(str, ch)
 
 /* strip_leading: strips any characters matching ch off the front of a
    string. */
-char *
-strip_leading(str, ch)
-  char *str;
-  char ch;
+char *strip_leading (char *str, char ch)
 {
   char *p1;
   char *p2;
@@ -105,9 +96,7 @@ strip_leading(str, ch)
   return(str);
 }
 
-char *
-strip_control(str)
-  char *str;
+char *strip_control (char *str)
 {
   int i;
   int j;
@@ -133,9 +122,7 @@ strip_control(str)
 }
 
 /* rtrim: strips whitespace off of the end of a string. */
-char *
-rtrim(str)
-  char *str;
+char *rtrim (char *str)
 {
   int i;
 
@@ -153,9 +140,7 @@ rtrim(str)
 }
 
 /* ltrim: strips the whitespace off the the front of a string */
-char *
-ltrim(str)
-  char *str;
+char *ltrim (char *str)
 {
   char *p1;
   char *p2;
@@ -184,9 +169,7 @@ ltrim(str)
 }
 
 /* trim: trim whitespace off of both ends of a string (in place) */
-char *
-trim(str)
-  char *str;
+char *trim (char *str)
 {
   if (!str)
   {
@@ -201,9 +184,7 @@ trim(str)
 
 
 /* reverses the string */
-char *
-strrev(str)
-  char *str;
+char *strrev (char *str)
 {
   char *head;
   char *tail;
@@ -224,9 +205,7 @@ strrev(str)
   return(str);
 }
 
-char *
-skip_whitespace(str)
-  char  *str;
+char *skip_whitespace (char *str)
 {
   char  *p = str;
 
@@ -239,10 +218,7 @@ skip_whitespace(str)
   return(p);
 }
 
-int
-count_char(str, c)
-  char  *str;
-  char  c;
+int count_char (char *str, char c)
 {
   char  *s;
   int   count;
@@ -260,9 +236,7 @@ count_char(str, c)
   return(count);
 }
 
-int
-count_spaces(str)
-  char  *str;
+int count_spaces (char *str)
 {
   char  *s;
   int   count;
@@ -283,9 +257,10 @@ count_spaces(str)
 
 /* strSTR: does a case-insensitve sub-string search */
 char *
-strSTR(str1, str2)       /*  by Jeff Odum  09/91  */
-  char *str1;
-  char *str2;
+strSTR (       /*  by Jeff Odum  09/91  */
+    char *str1,
+    char *str2
+)
 {
   int i;
   int j;
@@ -319,9 +294,7 @@ strSTR(str1, str2)       /*  by Jeff Odum  09/91  */
 }
 
 /* strupr: Upcases a string. */
-char *
-strupr(a)
-  char *a;
+char *strupr (char *a)
 {
   char *b;
 
@@ -337,9 +310,7 @@ strupr(a)
   return (b);
 }
 
-char *
-compact_whitespace(str)
-  char *str;
+char *compact_whitespace (char *str)
 {
   int i;
   int j;
@@ -377,9 +348,7 @@ compact_whitespace(str)
 }
 
 /* check if the string has any whitespaces (space, tab ..) */
-int
-is_no_whitespace_str( str )
-  char *str;
+int is_no_whitespace_str (char *str)
 {
   if (!str) return FALSE;
 
@@ -394,9 +363,7 @@ is_no_whitespace_str( str )
 }
 
 /* check if the given character string is just made of digits. */
-int
-is_number_str( str )
-  char *str;
+int is_number_str (char *str)
 {
   if (!str) return FALSE;
 
@@ -411,9 +378,7 @@ is_number_str( str )
 }
 
 /* check if the given character is an id character */
-static int
-is_id_char( value )
-  char value;
+static int is_id_char (char value)
 {
   return( isalnum(value) || 
           (value == '-') || 
@@ -421,9 +386,7 @@ is_id_char( value )
 }
 
 /* check if the given string is made of only id characters */
-int
-is_id_str( value )
-  char *value;
+int is_id_str (char *value)
 {
   int i;
 
--- a/common/test_driver.c
+++ b/common/test_driver.c
@@ -3,9 +3,7 @@
 
 #define NETWORK_REGEXP "^[0-9]+([.][0-9]+)*(/[0-9]+)?$"
 
-int
-is_network(value)
-  char *value;
+int is_network (char *value)
 {
   static regexp *net_prog = NULL;
 
@@ -24,9 +22,7 @@ is_network(value)
   }
 }
 
-void main(argc, argv)
-  int argc;
-  char **argv;
+void main (int argc, char **argv)
 {
   printf("checking: %s\n", argv[1]);
   
--- a/common/validate_rec.c
+++ b/common/validate_rec.c
@@ -23,10 +23,7 @@
 
      NOTE: currently returns true on all but tagged regular
      expressions, i.e., format string = "re: <regular expression>" */
-static int
-validate_format(format_str, value)
-  char  *format_str;
-  char  *value;
+static int validate_format (char *format_str, char *value)
 {
   regexp    *prog;
   char      tag[MAX_LINE];
@@ -54,11 +51,7 @@ validate_format(format_str, value)
 
 /* ----------------- Public Functions ----------------- */
 
-int
-encode_validate_flag(quiet_mode_flag, protocol_error_flag, find_all_flag)
-  int   quiet_mode_flag;
-  int   protocol_error_flag;
-  int   find_all_flag;
+int encode_validate_flag (int quiet_mode_flag, int protocol_error_flag, int find_all_flag)
 {
   int   result  = VALIDATE_ON;
 
@@ -80,13 +73,7 @@ encode_validate_flag(quiet_mode_flag, protocol_error_flag, find_all_flag)
   return(result);
 }
 
-void
-decode_validate_flag(validate_flag, quiet_mode_flag, protocol_error_flag,
-                     find_all_flag)
-  int   validate_flag;
-  int   *quiet_mode_flag;
-  int   *protocol_error_flag;
-  int   *find_all_flag;
+void decode_validate_flag (int validate_flag, int *quiet_mode_flag, int *protocol_error_flag, int *find_all_flag)
 {
   if (quiet_mode_flag)
   {
@@ -128,9 +115,9 @@ decode_validate_flag(validate_flag, quiet_mode_flag, protocol_error_flag,
 /* find_record_attr_by_id: given a rec, return the av_pair that
      matches local_id 'id', NULL if not found. */
 av_pair_struct *
-find_record_attr_by_id(record, id)
-  record_struct *record;
-  int           id;
+find_record_attr_by_id(
+  record_struct *record,
+  int           id)
 {
   av_pair_struct    *av;
   int               not_done;
@@ -156,9 +143,9 @@ find_record_attr_by_id(record, id)
 }
 
 int
-count_record_attr_by_id(record, id)
-  record_struct *record;
-  int           id;
+count_record_attr_by_id(
+  record_struct *record,
+  int           id)
 {
   av_pair_struct    *av;
   dl_list_type      *av_pair_list;
@@ -196,9 +183,9 @@ count_record_attr_by_id(record, id)
      'find_all_flag' controls whether the detection of an error
      short-circuits the process. */
 int
-check_required(record, validate_flag)
-  record_struct *record;
-  int           validate_flag;
+check_required(
+  record_struct *record,
+  int           validate_flag)
 {
   attribute_struct  *attr;
   av_pair_struct    *av;
@@ -263,9 +250,9 @@ check_required(record, validate_flag)
 }
 
 int
-check_repeated(record, validate_flag)
-  record_struct *record;
-  int           validate_flag;
+check_repeated(
+  record_struct *record,
+  int           validate_flag)
 {
   attribute_struct  *attr;
   dl_list_type      *attr_list;
@@ -327,9 +314,9 @@ check_repeated(record, validate_flag)
 }
 
 int
-check_formats(record, validate_flag)
-  record_struct *record;
-  int           validate_flag;
+check_formats(
+  record_struct *record,
+  int           validate_flag)
 {
   av_pair_struct    *av;
   dl_list_type      *av_pair_list;
@@ -392,9 +379,9 @@ check_formats(record, validate_flag)
 }
   
 int
-check_record(record, validate_flag)
-  record_struct *record;
-  int           validate_flag;
+check_record(
+  record_struct *record,
+  int           validate_flag)
 {   
   int           find_all_flag;
   int           found_error   = FALSE;
--- a/mkdb/anon_record.c
+++ b/mkdb/anon_record.c
@@ -18,10 +18,10 @@
 #include "validate_rec.h"
 
 anon_av_pair_struct *
-get_anon_av_pair(line, validate_flag, status)
-  char            *line;
-  int             validate_flag;
-  av_parse_result *status;
+get_anon_av_pair(
+  char            *line,
+  int             validate_flag,
+  av_parse_result *status)
 {
   anon_av_pair_struct *av_pair = NULL;
   char                attr_name[MAX_LINE];
@@ -59,11 +59,11 @@ get_anon_av_pair(line, validate_flag, status)
    file pointer set at the beginning of a record in a data file, read
    the anonymous record into the structure. */
 anon_record_struct *
-mkdb_read_anon_record(data_file_no, validate_flag, status, fp)
-  int              data_file_no;
-  int              validate_flag;
-  rec_parse_result *status;
-  FILE             *fp;
+mkdb_read_anon_record(
+  int              data_file_no,
+  int              validate_flag,
+  rec_parse_result *status,
+  FILE             *fp)
 {
   anon_record_struct  *rec;
   anon_av_pair_struct *av;
@@ -150,9 +150,9 @@ mkdb_read_anon_record(data_file_no, validate_flag, status, fp)
 }
 
 anon_av_pair_struct *
-find_anon_attr_in_rec(anon_rec, attr_name)
-  anon_record_struct *anon_rec;
-  char               *attr_name;
+find_anon_attr_in_rec(
+  anon_record_struct *anon_rec,
+  char               *attr_name)
 {
   anon_av_pair_struct *av;
   dl_list_type        *av_list;
@@ -181,8 +181,8 @@ find_anon_attr_in_rec(anon_rec, attr_name)
 }
 
 anon_av_pair_struct *
-find_anon_auth_area_in_rec(anon_rec)
-  anon_record_struct *anon_rec;
+find_anon_auth_area_in_rec(
+  anon_record_struct *anon_rec)
 {
   anon_av_pair_struct *av;
   dl_list_type        *av_list;
@@ -214,8 +214,8 @@ find_anon_auth_area_in_rec(anon_rec)
 }
 
 anon_av_pair_struct *
-find_anon_class_in_rec(anon_rec)
-  anon_record_struct *anon_rec;
+find_anon_class_in_rec(
+  anon_record_struct *anon_rec)
 {
   anon_av_pair_struct *av;
   dl_list_type        *av_list;
@@ -249,8 +249,8 @@ find_anon_class_in_rec(anon_rec)
 }
 
 anon_av_pair_struct *
-find_anon_updated_in_rec(anon_rec)
-  anon_record_struct *anon_rec;
+find_anon_updated_in_rec(
+  anon_record_struct *anon_rec)
 {
   anon_av_pair_struct *av;
   dl_list_type        *av_list;
@@ -283,8 +283,8 @@ find_anon_updated_in_rec(anon_rec)
 
 
 int
-destroy_anon_record_data(rec)
-  anon_record_struct    *rec;
+destroy_anon_record_data(
+  anon_record_struct    *rec)
 {
   if (!rec) return TRUE;
   
@@ -296,8 +296,8 @@ destroy_anon_record_data(rec)
 }
 
 int
-destroy_anon_av_pair_data(av)
-  anon_av_pair_struct   *av;
+destroy_anon_av_pair_data(
+  anon_av_pair_struct   *av)
 {
   if (!av) return TRUE;
 
--- a/mkdb/delete.c
+++ b/mkdb/delete.c
@@ -28,8 +28,8 @@ static int mkdb_delete_data_entry PROTO((dl_list_type  *fi_list,
                                          dl_list_type  *changed_fi_list));
 
 int
-mkdb_delete_record_list (record_list)
-  dl_list_type *record_list;
+mkdb_delete_record_list (
+  dl_list_type *record_list)
 {
   record_struct *record;
   dl_list_type  all_file_list;
@@ -72,10 +72,10 @@ mkdb_delete_record_list (record_list)
 }
 
 int
-mkdb_delete_record(file_list, hit_item, changed_fi_list)
-  dl_list_type  *file_list;
-  record_struct *hit_item;
-  dl_list_type  *changed_fi_list;
+mkdb_delete_record(
+  dl_list_type  *file_list,
+  record_struct *hit_item,
+  dl_list_type  *changed_fi_list)
 {
   int   status;
 
@@ -92,13 +92,12 @@ mkdb_delete_record(file_list, hit_item, changed_fi_list)
 }
 
 static int
-mkdb_delete_index_entry(fi_list, index_file_index, data_file_index, offset,
-                        changed_fi_list)
-  dl_list_type      *fi_list;
-  int               index_file_index;
-  int               data_file_index;
-  off_t             offset;
-  dl_list_type      *changed_fi_list;
+mkdb_delete_index_entry(
+  dl_list_type      *fi_list,
+  int               index_file_index,
+  int               data_file_index,
+  off_t             offset,
+  dl_list_type      *changed_fi_list)
 {
   file_struct       *fi             = NULL;
   index_struct      index_item;
@@ -163,10 +162,10 @@ mkdb_delete_index_entry(fi_list, index_file_index, data_file_index, offset,
 
 
 int
-mkdb_delete_data_entry(fi_list, hit_item, changed_fi_list)
-  dl_list_type      *fi_list;
-  record_struct     *hit_item;
-  dl_list_type      *changed_fi_list;
+mkdb_delete_data_entry(
+  dl_list_type      *fi_list,
+  record_struct     *hit_item,
+  dl_list_type      *changed_fi_list)
 {
   FILE        *fp;
   file_struct *fi;
--- a/mkdb/fileinfo.c
+++ b/mkdb/fileinfo.c
@@ -74,8 +74,8 @@ static int install_write_file_list PROTO((class_struct     *class,
 /* select_mkdb_file_type: returns the database file type (data or
    index) based on the tag. */
 static mkdb_file_type
-select_type(ftype)
-  char  *ftype;
+select_type(
+  char  *ftype)
 {
   if (STR_EQ(ftype, MKDB_EXACT_INDEX_STR) ||
       STR_EQ(ftype, MKDB_OLD_INDEX_STR) ||
@@ -102,8 +102,8 @@ select_type(ftype)
 }
 
 static char *
-select_str_from_type(type)
-  mkdb_file_type    type;
+select_str_from_type(
+  mkdb_file_type    type)
 {
   switch (type)
   {
@@ -121,8 +121,8 @@ select_str_from_type(type)
 }
 
 static file_struct *
-read_file_struct(fp)
-  FILE  *fp;
+read_file_struct(
+  FILE  *fp)
 {
   char        line[MAX_LINE + 1];
   char        tag[MAX_LINE];
@@ -200,10 +200,10 @@ read_file_struct(fp)
 }
 
 static int
-write_file_struct(fp, fi, not_last)
-  FILE        *fp;
-  file_struct *fi;
-  int         not_last;
+write_file_struct(
+  FILE        *fp,
+  file_struct *fi,
+  int         not_last)
 {
 
   if (!fp || !fi)
@@ -233,9 +233,9 @@ write_file_struct(fp, fi, not_last)
 /* read_file_list: reads a file_list data file into the file_list
    structure, by type.  Returns TRUE on success. */
 static int
-read_file_list(index_file, file_list)
-  char            *index_file;
-  dl_list_type    *file_list;
+read_file_list(
+  char            *index_file,
+  dl_list_type    *file_list)
 {
   FILE              *fp = NULL;
   file_struct       *fi;
@@ -297,9 +297,9 @@ read_file_list(index_file, file_list)
 /* write_file_list: writes a file list to the master index file. The
    entire file_list must be given to this routine. */
 static void
-write_file_list(filename, file_list)
-  char         *filename;
-  dl_list_type *file_list;
+write_file_list(
+  char         *filename,
+  dl_list_type *file_list)
 {
   FILE         *fp;
   file_struct  *fi;
@@ -331,8 +331,8 @@ write_file_list(filename, file_list)
    file_list is the full file list, and b) that they are sequentially
    increasing (that is, the last element has the highest number */
 static int
-next_file_no(file_list)
-  dl_list_type  *file_list;
+next_file_no(
+  dl_list_type  *file_list)
 {
   file_struct   *file;
 
@@ -354,10 +354,10 @@ next_file_no(file_list)
 }
 
 static char *
-generate_file_name(tmp_filename, base_filename, full_file_list)
-  char         *tmp_filename;
-  char         *base_filename;
-  dl_list_type *full_file_list;
+generate_file_name(
+  char         *tmp_filename,
+  char         *base_filename,
+  dl_list_type *full_file_list)
 {
   file_struct  *f;
   char         template[MAX_FILE + 1];
@@ -410,11 +410,11 @@ generate_file_name(tmp_filename, base_filename, full_file_list)
 /* fills the 'index_file' varible with the path and name of the master
    index file, given the instance type (read, write, backup, etc) */
 static int
-get_master_index_file(class, auth_area, instance_type, index_file)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  master_inst_type instance_type;
-  char             *index_file;
+get_master_index_file(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  master_inst_type instance_type,
+  char             *index_file)
 {
   if (!class || !class->name || !index_file)
   {
@@ -440,10 +440,10 @@ get_master_index_file(class, auth_area, instance_type, index_file)
 /* adds a file structure to a list, checking for duplication and
    assigning the index number.  */
 static int
-add_file_struct(file, file_list, lock_mode)
-  file_struct    *file;
-  dl_list_type   *file_list;
-  mkdb_lock_type lock_mode;
+add_file_struct(
+  file_struct    *file,
+  dl_list_type   *file_list,
+  mkdb_lock_type lock_mode)
 {
   file_struct *tmp_file;
   char        file_path[MAX_FILE + 1];
@@ -523,9 +523,9 @@ add_file_struct(file, file_list, lock_mode)
 
 /* deletes a given file from a file list */
 static int
-delete_file_no(file_no, file_list)
-  int          file_no;
-  dl_list_type *file_list;
+delete_file_no(
+  int          file_no,
+  dl_list_type *file_list)
 {
   file_struct *file;
   int         not_done;
@@ -549,10 +549,10 @@ delete_file_no(file_no, file_list)
 
 /* locks or unlocks a given file number with a file list */
 static int
-lock_unlock_file_no(file_no, lock, file_list)
-  int            file_no;
-  mkdb_lock_type lock;
-  dl_list_type   *file_list;
+lock_unlock_file_no(
+  int            file_no,
+  mkdb_lock_type lock,
+  dl_list_type   *file_list)
 {
   file_struct *file;
   int         not_done;
@@ -577,9 +577,9 @@ lock_unlock_file_no(file_no, lock, file_list)
 /* updates the statistics of the corresponding (by file no) file
    structure in list.  */
 static int
-update_file_no(update_file, file_list)
-  file_struct  *update_file;
-  dl_list_type *file_list;
+update_file_no(
+  file_struct  *update_file,
+  dl_list_type *file_list)
 {
   file_struct *file;
   int         not_done;
@@ -604,10 +604,10 @@ update_file_no(update_file, file_list)
 
 /* add the files in the list to the full file list */
 static int
-add_file_list(file_list, full_file_list, lock_mode)
-  dl_list_type     *file_list;
-  dl_list_type     *full_file_list;
-  mkdb_lock_type   lock_mode;
+add_file_list(
+  dl_list_type     *file_list,
+  dl_list_type     *full_file_list,
+  mkdb_lock_type   lock_mode)
 {
   file_struct   *file;
   int           not_done;
@@ -630,9 +630,9 @@ add_file_list(file_list, full_file_list, lock_mode)
 
 /* delete the files in the list from the full file list */
 static int
-delete_file_list(file_list, full_file_list)
-  dl_list_type *file_list;
-  dl_list_type *full_file_list;
+delete_file_list(
+  dl_list_type *file_list,
+  dl_list_type *full_file_list)
 {
   file_struct *file;
   int         not_done;
@@ -661,9 +661,9 @@ delete_file_list(file_list, full_file_list)
 /* modifies the statistics of the files in the list in the full file
    list */
 static int
-mod_file_list(file_list, full_file_list)
-  dl_list_type *file_list;
-  dl_list_type *full_file_list;
+mod_file_list(
+  dl_list_type *file_list,
+  dl_list_type *full_file_list)
 {
   file_struct   *file;
   int           not_done;
@@ -688,10 +688,10 @@ mod_file_list(file_list, full_file_list)
 }
 
 static int
-lock_unlock_file_list(file_list, full_file_list, lock)
-  dl_list_type   *file_list;
-  dl_list_type   *full_file_list;
-  mkdb_lock_type lock;
+lock_unlock_file_list(
+  dl_list_type   *file_list,
+  dl_list_type   *full_file_list,
+  mkdb_lock_type lock)
 {
   file_struct   *file;
   int           not_done;
@@ -717,9 +717,9 @@ lock_unlock_file_list(file_list, full_file_list, lock)
 }
 
 static int
-install_write_file_list(class, auth_area)
-  class_struct     *class;
-  auth_area_struct *auth_area;
+install_write_file_list(
+  class_struct     *class,
+  auth_area_struct *auth_area)
 {
   char w_index_file_name[MAX_FILE + 1];
   char r_index_file_name[MAX_FILE + 1];
@@ -774,9 +774,9 @@ install_write_file_list(class, auth_area)
    have to spin looking for a possibly transient master index file. (3
    stat() calls are much cheaper than any amount of waiting... */
 static int
-is_area_indexed(class, auth_area)
-  class_struct *class;
-  auth_area_struct *auth_area;
+is_area_indexed(
+  class_struct *class,
+  auth_area_struct *auth_area)
 {
   char w_index_file_name[MAX_FILE + 1];
   char r_index_file_name[MAX_FILE + 1];
@@ -819,9 +819,9 @@ is_area_indexed(class, auth_area)
 
 
 int
-mkdb_file_type_equals(type1, type2)
-  mkdb_file_type type1;
-  mkdb_file_type type2;
+mkdb_file_type_equals(
+  mkdb_file_type type1,
+  mkdb_file_type type2)
 {
   if (type1 == type2) return TRUE;
 
@@ -851,8 +851,8 @@ mkdb_file_type_equals(type1, type2)
 }
 
 file_struct *
-copy_file_struct(fi)
-  file_struct *fi;
+copy_file_struct(
+  file_struct *fi)
 {
   file_struct *copy;
 
@@ -881,9 +881,9 @@ copy_file_struct(fi)
 }
 
 int
-copy_file_list(target_file_list, source_file_list)
-  dl_list_type *target_file_list;
-  dl_list_type *source_file_list;
+copy_file_list(
+  dl_list_type *target_file_list,
+  dl_list_type *source_file_list)
 {
   int         not_done;
   file_struct *f;
@@ -912,11 +912,7 @@ copy_file_list(target_file_list, source_file_list)
 }
 /* get_dir: given class and auth_area (or just auth_area) return the
      data directory in 'dir'.  Return TRUE on success. */
-int
-get_dir(class_name, auth_area_name, dir)
-  char  *class_name;
-  char  *auth_area_name;
-  char  *dir;
+int get_dir (char *class_name, char *auth_area_name, char *dir)
 {
   auth_area_struct *auth_area;
   class_struct     *class;
@@ -967,10 +963,10 @@ get_dir(class_name, auth_area_name, dir)
      pointed to by class & auth_area, and appends them to file_list,
      which should already be initialized. */
 int
-get_file_list(class, auth_area, file_list)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  dl_list_type     *file_list;
+get_file_list(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  dl_list_type     *file_list)
 {
   char  index_file[MAX_FILE + 1];
 
@@ -1001,10 +997,10 @@ get_file_list(class, auth_area, file_list)
      and auth_area (by name), or just auth_area.  Returns TRUE on
      success. */
 int
-get_file(class_name, auth_area_name, file_list)
-  char            *class_name;
-  char            *auth_area_name;
-  dl_list_type    *file_list;
+get_file(
+  char            *class_name,
+  char            *auth_area_name,
+  dl_list_type    *file_list)
 {
   auth_area_struct *auth_area;
   schema_struct    *schema;
@@ -1076,10 +1072,10 @@ get_file(class_name, auth_area_name, file_list)
 }
 
 int
-filter_file_list(result_list, type, master_list)
-  dl_list_type   *result_list;
-  mkdb_file_type type;
-  dl_list_type   *master_list;
+filter_file_list(
+  dl_list_type   *result_list,
+  mkdb_file_type type,
+  dl_list_type   *master_list)
 {
   int         not_done;
   file_struct *fi;
@@ -1115,9 +1111,9 @@ filter_file_list(result_list, type, master_list)
 
 
 int
-unlink_master_file_list(class, auth_area)
-  class_struct     *class;
-  auth_area_struct *auth_area;
+unlink_master_file_list(
+  class_struct     *class,
+  auth_area_struct *auth_area)
 {
   char  index_file[MAX_FILE];
 
@@ -1150,12 +1146,12 @@ unlink_master_file_list(class, auth_area)
 
 
 file_struct *
-add_single_file(class, auth_area, file_name, type, num_recs)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  char             *file_name;
-  mkdb_file_type   type;
-  long             num_recs;
+add_single_file(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  char             *file_name,
+  mkdb_file_type   type,
+  long             num_recs)
 {
   file_struct  *file;
   file_struct  *list_file;
@@ -1194,15 +1190,14 @@ add_single_file(class, auth_area, file_name, type, num_recs)
 
 
 int
-modify_file_list(class, auth_area, add_list, delete_list,
-                 mod_list, unlock_list, lock_list)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  dl_list_type     *add_list;
-  dl_list_type     *delete_list;
-  dl_list_type     *mod_list;
-  dl_list_type     *unlock_list;
-  dl_list_type     *lock_list;
+modify_file_list(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  dl_list_type     *add_list,
+  dl_list_type     *delete_list,
+  dl_list_type     *mod_list,
+  dl_list_type     *unlock_list,
+  dl_list_type     *lock_list)
 {
   dl_list_type   full_file_list;
   char           write_index_file[MAX_FILE + 1];
@@ -1296,8 +1291,8 @@ modify_file_list(class, auth_area, add_list, delete_list,
 
 
 void
-unlink_file_list(file_list)
-  dl_list_type *file_list;
+unlink_file_list(
+  dl_list_type *file_list)
 {
   file_struct  *file;
   int          not_done;
@@ -1329,10 +1324,10 @@ unlink_file_list(file_list)
 /* find_file_by_id: searches a file list for a file_struct with
      'id'.  Returns NULL if not found. */
 file_struct *
-find_file_by_id(list, id, type)
-  dl_list_type   *list;
-  int            id;
-  mkdb_file_type type;
+find_file_by_id(
+  dl_list_type   *list,
+  int            id,
+  mkdb_file_type type)
 {
   int           not_done;
   file_struct   *fi;
@@ -1357,10 +1352,10 @@ find_file_by_id(list, id, type)
 /* find_file_by_name: searches a file list for a file_struct with
    filename 'name'.  Returns NULL if not found. */
 file_struct *
-find_file_by_name(list, name, type)
-  dl_list_type   *list;
-  char           *name;
-  mkdb_file_type type;
+find_file_by_name(
+  dl_list_type   *list,
+  char           *name,
+  mkdb_file_type type)
 {
   int           not_done;
   file_struct   *fi;
@@ -1383,8 +1378,8 @@ find_file_by_name(list, name, type)
 }
 
 long
-records_in_auth_area(auth_area)
-  auth_area_struct *auth_area;
+records_in_auth_area(
+  auth_area_struct *auth_area)
 {
   dl_list_type master_file_list;
   dl_list_type data_file_list;
@@ -1422,10 +1417,10 @@ records_in_auth_area(auth_area)
 /* build_base_file_struct: given a path, a type and the number of
      records, allocate and return a resultant file structure. */
 file_struct *
-build_base_file_struct(file_name, type, num_recs)
-  char           *file_name;
-  mkdb_file_type type;
-  long           num_recs;
+build_base_file_struct(
+  char           *file_name,
+  mkdb_file_type type,
+  long           num_recs)
 {
   struct stat    sb;
   int            status;
@@ -1449,11 +1444,11 @@ build_base_file_struct(file_name, type, num_recs)
 }
 
 file_struct *
-build_tmp_base_file_struct(tmp_filename, base_template, type, num_recs)
-  char           *tmp_filename;
-  char           *base_template;
-  mkdb_file_type type;
-  long           num_recs;
+build_tmp_base_file_struct(
+  char           *tmp_filename,
+  char           *base_template,
+  mkdb_file_type type,
+  long           num_recs)
 {
   struct stat    sb;
   int            status;
@@ -1483,12 +1478,12 @@ build_tmp_base_file_struct(tmp_filename, base_template, type, num_recs)
 
 
 int
-build_file_list_by_names(file_list, type, base_dir, num_names, names)
-  dl_list_type      *file_list;
-  mkdb_file_type    type;
-  char              *base_dir;
-  int               num_names;
-  char              **names;
+build_file_list_by_names(
+  dl_list_type      *file_list,
+  mkdb_file_type    type,
+  char              *base_dir,
+  int               num_names,
+  char              **names)
 {
   file_struct   *df;
   char          path[MAX_FILE + 1];
@@ -1518,11 +1513,11 @@ build_file_list_by_names(file_list, type, base_dir, num_names, names)
 }
 
 int
-build_file_list_by_suffix(file_list, type, base_dir, suffix)
-  dl_list_type   *file_list;
-  mkdb_file_type type;
-  char           *base_dir;
-  char           *suffix;
+build_file_list_by_suffix(
+  dl_list_type   *file_list,
+  mkdb_file_type type,
+  char           *base_dir,
+  char           *suffix)
 {
   file_struct   *fi;
   DIR           *dir_fp;
@@ -1572,8 +1567,8 @@ build_file_list_by_suffix(file_list, type, base_dir, suffix)
 /* --------------- Destructor Components  ------------- */
 
 int
-destroy_file_struct_data(data)
-  file_struct   *data;
+destroy_file_struct_data(
+  file_struct   *data)
 {
   if (!data)
   {
@@ -1604,5 +1599,3 @@ destroy_file_struct_data(data)
 
   return TRUE;
 }
-
-
--- a/mkdb/index.c
+++ b/mkdb/index.c
@@ -36,9 +36,9 @@
 
 /* write_index_line: output one index line to the file */
 static int
-write_index_line(fp, item)
-  FILE          *fp;
-  index_struct  *item;
+write_index_line(
+  FILE          *fp,
+  index_struct  *item)
 {
   char      line[MAX_LINE + 1];
 
@@ -60,9 +60,7 @@ write_index_line(fp, item)
 
 /* exact_index: given a value return the string to put into the
    index This was the old normal case for everything */
-static char *
-exact_index(line)
-  char      *line;
+static char *exact_index (char *line)
 {
   char      *a;
   char      *b;
@@ -76,9 +74,7 @@ exact_index(line)
 }
 
 /* cidr_index: given a value return the string to put into the index*/
-static char *
-cidr_index(line)
-  char      *line;
+static char *cidr_index (char *line)
 {
   struct netinfo prefix;
   char          buf[MAX_LINE];
@@ -104,9 +100,7 @@ cidr_index(line)
 }
 
 
-static char *
-strip_non_soundex(str)
-  char *str;
+static char *strip_non_soundex (char *str)
 {
   int i;
   int j;
@@ -135,9 +129,7 @@ strip_non_soundex(str)
   return(str);
 }
 
-static char *
-soundex_index(value)
-  char *value;
+static char *soundex_index (char *value)
 {
   char  buf[MAX_LINE];
   char  tmp_buf[MAX_LINE];
@@ -187,10 +179,7 @@ soundex_index(value)
   return(result);
 }
 
-char *
-soundex_index_to_var(result, value)
-  char      *result;
-  char      *value;
+char *soundex_index_to_var (char *result, char *value)
 {
   char *res;
 
@@ -207,9 +196,7 @@ soundex_index_to_var(result, value)
   return(result);
 }
 
-int
-is_soundexable(str)
-  char *str;
+int is_soundexable (char *str)
 {
   int i;
   int len;
@@ -237,8 +224,8 @@ is_soundexable(str)
 /* sort_index_file: given a list of files, sort each tmp file, move it
    to its real filename, and unlink the original unsorted file */
 int
-sort_index_files(files)
-  dl_list_type *files;
+sort_index_files(
+  dl_list_type *files)
 {
   char            command_str[BUFSIZ + 1];
   index_fp_struct *index_file;
@@ -283,11 +270,11 @@ sort_index_files(files)
    unnecessary), write to each index the appropriate lines for each
    attribute.  Return the number of index lines written */
 static long
-index_record(rec, auth_area, files, status)
-  record_struct    *rec;
-  auth_area_struct *auth_area;
-  dl_list_type     *files;
-  int              *status;
+index_record(
+  record_struct    *rec,
+  auth_area_struct *auth_area,
+  dl_list_type     *files,
+  int              *status)
 {
   dl_list_type     *global_attr_list;
   dl_list_type     *av_pair_list;
@@ -481,13 +468,13 @@ index_record(rec, auth_area, files, status)
    full_file_list (but not committing it).  Returns the number of
    lines written, status in the variable.  */
 long
-index_data_file(class, auth_area, data_file, files, validate_flag, status)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  file_struct       *data_file;
-  dl_list_type      *files;
-  int               validate_flag;
-  int               *status;
+index_data_file(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  file_struct       *data_file,
+  dl_list_type      *files,
+  int               validate_flag,
+  int               *status)
 {
   record_struct    *record;
   long              num_index_lines = 0;
@@ -554,9 +541,9 @@ index_data_file(class, auth_area, data_file, files, validate_flag, status)
 /* ------------------------ Public Functions ----------------- */
 
 int
-decode_index_line(line, item)
-  char              *line;
-  index_struct *item;
+decode_index_line(
+  char              *line,
+  index_struct *item)
 {
   int   argc;
   char  **argv;
@@ -587,9 +574,9 @@ decode_index_line(line, item)
 }
 
 int
-encode_index_line(line, item)
-  char          *line;
-  index_struct  *item;
+encode_index_line(
+  char          *line,
+  index_struct  *item)
 {
   if (!item || !line)
   {
@@ -609,14 +596,13 @@ encode_index_line(line, item)
 
 
 int
-index_files(class, auth_area, index_file_list, data_file_list, validate_flag,
-            hold_lock_flag)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  dl_list_type      *index_file_list;
-  dl_list_type      *data_file_list;
-  int               validate_flag;
-  int               hold_lock_flag;
+index_files(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  dl_list_type      *index_file_list,
+  dl_list_type      *data_file_list,
+  int               validate_flag,
+  int               hold_lock_flag)
 {
   file_struct   *data_file;
   file_struct   *index_file;
@@ -745,15 +731,7 @@ index_files(class, auth_area, index_file_list, data_file_list, validate_flag,
 }
 
 
-int
-index_files_by_name(class_name, auth_area_name, base_dir,
-                    num_data_files, file_names, validate_flag)
-  char  *class_name;
-  char  *auth_area_name;
-  char  *base_dir;
-  int   num_data_files;
-  char  **file_names;
-  int   validate_flag;
+int index_files_by_name (char *class_name, char *auth_area_name, char *base_dir, int num_data_files, char **file_names, int validate_flag)
 {
   class_struct      *class;
   auth_area_struct  *auth_area;
@@ -828,12 +806,7 @@ index_files_by_name(class_name, auth_area_name, base_dir,
   return(status);
 }
 
-int
-index_files_by_suffix(class_name, auth_area_name, suffix, validate_flag)
-  char *class_name;
-  char *auth_area_name;
-  char *suffix;
-  int  validate_flag;
+int index_files_by_suffix (char *class_name, char *auth_area_name, char *suffix, int validate_flag)
 {
   class_struct     *class;
   auth_area_struct *auth_area;
@@ -903,8 +876,8 @@ index_files_by_suffix(class_name, auth_area_name, suffix, validate_flag)
 /* --------------- Destructor Components ------------ */
 
 int
-destroy_index_item(item)
-  index_struct *item;
+destroy_index_item(
+  index_struct *item)
 {
   if (!item)
   {
--- a/mkdb/index_file.c
+++ b/mkdb/index_file.c
@@ -18,8 +18,8 @@
 /* ------------------- Private Functions -------------------- */
 
 static char * 
-mkdb_ft_2_ft_templ(mkdb_type)
-  mkdb_file_type mkdb_type;
+mkdb_ft_2_ft_templ(
+  mkdb_file_type mkdb_type)
 {
   switch(mkdb_type)
   {
@@ -35,8 +35,8 @@ mkdb_ft_2_ft_templ(mkdb_type)
 }
 
 static char *
-translate_type_to_str(mkdb_type)
-  mkdb_file_type mkdb_type;
+translate_type_to_str(
+  mkdb_file_type mkdb_type)
 {
   switch(mkdb_type)
   {
@@ -52,9 +52,9 @@ translate_type_to_str(mkdb_type)
 }
 
 static char *
-generate_index_file_tmpname(type, prefix)
-  mkdb_file_type type;
-  char           *prefix;
+generate_index_file_tmpname(
+  mkdb_file_type type,
+  char           *prefix)
 {
   char           tmpname[MAX_FILE + 1];
   
@@ -74,12 +74,12 @@ generate_index_file_tmpname(type, prefix)
 
 /* create_index_fp: creates an index_fp_struct and fills it out */
 static index_fp_struct *
-create_index_fp(type, class, auth_area, base_dir, base_name)
-  mkdb_file_type   type;
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  char             *base_dir;
-  char             *base_name;
+create_index_fp(
+  mkdb_file_type   type,
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  char             *base_dir,
+  char             *base_name)
 {
   index_fp_struct *file;
   char            *name;
@@ -107,9 +107,9 @@ create_index_fp(type, class, auth_area, base_dir, base_name)
 }
 
 static int
-does_index_type_exist(type, index_file_list)
-  mkdb_file_type    type;
-  dl_list_type      *index_file_list;
+does_index_type_exist(
+  mkdb_file_type    type,
+  dl_list_type      *index_file_list)
 {
   index_fp_struct *index_file;
   int             not_done;
@@ -137,10 +137,10 @@ does_index_type_exist(type, index_file_list)
 /* given a type and prefix, and spool directory, generate the real
    filename template. */
 char *
-generate_index_file_basename(type, spool_directory, prefix)
-  mkdb_file_type type;
-  char           *spool_directory;
-  char           *prefix;
+generate_index_file_basename(
+  mkdb_file_type type,
+  char           *spool_directory,
+  char           *prefix)
 {
   char           template[MAX_FILE];
   
@@ -160,8 +160,8 @@ generate_index_file_basename(type, spool_directory, prefix)
    here. It is unclear whether this is the case but there needs to be
    some break between the indexing method and the mkdb file type. */
 mkdb_file_type
-convert_file_type(attr_index)
-  attr_index_type attr_index;
+convert_file_type(
+  attr_index_type attr_index)
 {
   switch(attr_index)
   {
@@ -175,11 +175,11 @@ convert_file_type(attr_index)
     return(MKDB_NO_FILE);
   }
 }
- 
+
 index_fp_struct *
-find_index_file_by_type(files, type)
-  dl_list_type   *files;
-  mkdb_file_type type;
+find_index_file_by_type(
+  dl_list_type   *files,
+  mkdb_file_type type)
 {
   index_fp_struct *file;
   int             found = 0;
@@ -212,12 +212,12 @@ find_index_file_by_type(files, type)
      of the types and just exit because we've added 'em all and
      there's no sense in looking at any more of 'em.*/
 int
-build_index_list(class, auth_area, index_file_list, base_dir, base_name)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  dl_list_type     *index_file_list;
-  char             *base_dir;
-  char             *base_name;
+build_index_list(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  dl_list_type     *index_file_list,
+  char             *base_dir,
+  char             *base_name)
 {
   dl_list_type     *attr_list;
   int              not_done;
@@ -298,8 +298,8 @@ build_index_list(class, auth_area, index_file_list, base_dir, base_name)
   
 
 int
-unlink_index_tmp_files(index_file_list)
-   dl_list_type  *index_file_list;
+unlink_index_tmp_files(
+   dl_list_type  *index_file_list)
 {
   index_fp_struct *index_file;
   int             not_done;
@@ -329,8 +329,8 @@ unlink_index_tmp_files(index_file_list)
 }
 
 int
-destroy_index_fp_data(data)
-  index_fp_struct *data;
+destroy_index_fp_data(
+  index_fp_struct *data)
 {
   if (!data)
   {
--- a/mkdb/lex.yy.c
+++ b/mkdb/lex.yy.c
@@ -877,7 +877,7 @@ case YY_STATE_EOF(INITIAL):
  *	EOB_ACT_END_OF_FILE - end of file
  */
 
-static int yy_get_next_buffer()
+static int yy_get_next_buffer (void)
 	{
 	register char *dest = yy_current_buffer->yy_ch_buf;
 	register char *source = yytext_ptr;
@@ -1009,7 +1009,7 @@ static int yy_get_next_buffer()
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
+static yy_state_type yy_get_previous_state (void)
 	{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
@@ -1493,7 +1493,7 @@ int new_state;
 
 
 #ifndef YY_NO_POP_STATE
-static void yy_pop_state()
+static void yy_pop_state (void)
 	{
 	if ( --yy_start_stack_ptr < 0 )
 		YY_FATAL_ERROR( "start-condition stack underflow" );
@@ -1504,7 +1504,7 @@ static void yy_pop_state()
 
 
 #ifndef YY_NO_TOP_STATE
-static int yy_top_state()
+static int yy_top_state (void)
 	{
 	return yy_start_stack[yy_start_stack_ptr - 1];
 	}
@@ -1617,7 +1617,7 @@ void *ptr;
 	}
 
 #if YY_MAIN
-int main()
+int main (void)
 	{
 	yylex();
 	return 0;
@@ -1626,9 +1626,7 @@ int main()
 #line 72 "parse.l"
 
 
-int
-set_lexstring(s)
-  char *s;
+int set_lexstring (char *s)
 {
   lexstring = s;
   lexlen = strlen(lexstring);
@@ -1649,17 +1647,13 @@ set_lexstring(s)
   return TRUE;
 }
 
-int
-yywrap()
+int yywrap (void)
 {
   return 1;
 }
 
 #ifdef FLEX_SCANNER
-static int
-parse_yyinput(buf, max_size)
-  char  *buf;
-  int   max_size;
+static int parse_yyinput (char *buf, int max_size)
 {
   int n = (lexlen < max_size) ? lexlen : max_size;
 
--- a/mkdb/metaphon.c
+++ b/mkdb/metaphon.c
@@ -285,9 +285,7 @@ Boolean_T metaphone(const char *Word, char *Metaph, metaphlag Flag)
 
 #if 0
 /* strupr: Upcases a string. */
-char *
-strupr(a)
-  char *a;
+char *strupr (char *a)
 {
   char *b;
  
--- a/mkdb/parse.h
+++ b/mkdb/parse.h
@@ -24,6 +24,9 @@ int destroy_query_term PROTO((query_term_struct *qt));
 
 int destroy_query PROTO((query_struct *q));
 
+int yyerror PROTO((char *s));
+int yylex (void);
+
 /* these are really defined in parse.l */
 int set_lexstring PROTO((char *s));
 
--- a/mkdb/parse.y
+++ b/mkdb/parse.y
@@ -83,9 +83,9 @@ static query_term_struct   *working_term;
 static int                 parse_status;
   
 static int
-set_query(class_name, auth_area_name)
-  char *class_name;
-  char *auth_area_name;
+set_query(
+  char *class_name,
+  char *auth_area_name)
 {
   if (auth_area_name && *auth_area_name)
   {
@@ -101,10 +101,10 @@ set_query(class_name, auth_area_name)
 }
 
 static query_term_struct *
-set_query_term(attribute_name, value, op)
-  char               *attribute_name;
-  char               *value;
-  mkdb_operator_type op;
+set_query_term(
+  char               *attribute_name,
+  char               *value,
+  mkdb_operator_type op)
 {
   query_term_struct *qt;
   
@@ -154,8 +154,8 @@ set_query_term(attribute_name, value, op)
 
 /* sets working term to the term, and if necessary sets the first term */
 static void
-add_term(term)
-  query_term_struct *term;
+add_term(
+  query_term_struct *term)
 {
   if (working_term)
   {
@@ -201,8 +201,8 @@ add_or_term()
 }
 
 static void
-display_query_term(term)
-  query_term_struct *term;
+display_query_term(
+  query_term_struct *term)
 {
 
   printf(" ");
@@ -249,9 +249,9 @@ display_query()
   
 
 int
-parse_query(line, result)
-  char         *line;
-  query_struct *result;
+parse_query(
+  char         *line,
+  query_struct *result)
 {
   /* reset global variables */
   parse_result = result;
@@ -270,8 +270,8 @@ parse_query(line, result)
 }
 
 int
-yyerror(s)
-  char *s;
+yyerror(
+  char *s)
 {
   print_error(INVALID_QUERY_SYNTAX, "");
   parse_status = FALSE;
@@ -279,8 +279,8 @@ yyerror(s)
 }
 
 int
-destroy_query_term(qt)
-  query_term_struct *qt;
+destroy_query_term(
+  query_term_struct *qt)
 {
   if (!qt) return TRUE;
 
@@ -300,8 +300,8 @@ destroy_query_term(qt)
 }
 
 int
-destroy_query(q)
-  query_struct  *q;
+destroy_query(
+  query_struct  *q)
 {
   query_term_struct *horiz;
   query_term_struct *vert;
--- a/mkdb/records.c
+++ b/mkdb/records.c
@@ -21,10 +21,10 @@
 /* ----------------------- Local Functions ---------------------- */
 
 static int
-encode_av_pair(class, av, line)
-  class_struct      *class;
-  av_pair_struct    *av;
-  char              *line;
+encode_av_pair(
+  class_struct      *class,
+  av_pair_struct    *av,
+  char              *line)
 {
   /* Right now this routine is very simple; however, I expect that it
      will become more complex as more space and flexiblity issues move
@@ -38,12 +38,12 @@ encode_av_pair(class, av, line)
 }
 
 static av_pair_struct *
-translate_anon_av_pair(anon_av, class, auth_area, validate_flag, status)
-  anon_av_pair_struct *anon_av;
-  class_struct        *class;
-  auth_area_struct    *auth_area;
-  int                 validate_flag;
-  av_parse_result     *status;
+translate_anon_av_pair(
+  anon_av_pair_struct *anon_av,
+  class_struct        *class,
+  auth_area_struct    *auth_area,
+  int                 validate_flag,
+  av_parse_result     *status)
 {
   av_pair_struct   *av;
   attribute_struct *attr;
@@ -103,11 +103,11 @@ translate_anon_av_pair(anon_av, class, auth_area, validate_flag, status)
    were stored without explict class name or authority area
    attributes. */
 record_struct *
-mkdb_translate_anon_record(anon, class, auth_area, validate_flag)
-  anon_record_struct *anon;
-  class_struct       *class;
-  auth_area_struct   *auth_area;
-  int                validate_flag;
+mkdb_translate_anon_record(
+  anon_record_struct *anon,
+  class_struct       *class,
+  auth_area_struct   *auth_area,
+  int                validate_flag)
 {
   record_struct       *rec;
   anon_av_pair_struct *anon_av;
@@ -172,13 +172,13 @@ mkdb_translate_anon_record(anon, class, auth_area, validate_flag)
 
 
 record_struct *
-mkdb_read_record(class, auth_area, data_file_no, validate_flag, status, fp)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  int               data_file_no;
-  int               validate_flag;
-  rec_parse_result  *status;
-  FILE              *fp;
+mkdb_read_record(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  int               data_file_no,
+  int               validate_flag,
+  rec_parse_result  *status,
+  FILE              *fp)
 {
   anon_record_struct *anon;
   record_struct      *rec;
@@ -234,14 +234,13 @@ mkdb_read_record(class, auth_area, data_file_no, validate_flag, status, fp)
 }
 
 record_struct *
-mkdb_read_next_record(class, auth_area, data_file_no, validate_flag,
-                      status, fp)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  int               data_file_no;
-  int               validate_flag;
-  rec_parse_result  *status;
-  FILE              *fp;
+mkdb_read_next_record(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  int               data_file_no,
+  int               validate_flag,
+  rec_parse_result  *status,
+  FILE              *fp)
 {
   record_struct *rec;
 
@@ -268,9 +267,9 @@ mkdb_read_next_record(class, auth_area, data_file_no, validate_flag,
 /* mkdb_write_record: given a record structure, write it to file
      stream 'fp', which needs to have been opened for writing. */
 int
-mkdb_write_record(record, fp)
-  record_struct *record;
-  FILE          *fp;
+mkdb_write_record(
+  record_struct *record,
+  FILE          *fp)
 {
   char          line[MAX_LINE + 1];
   dl_list_type  *av_list = &(record->av_pair_list);
@@ -291,9 +290,9 @@ mkdb_write_record(record, fp)
 }
 
 av_pair_struct *
-find_attr_in_record_by_name(record, attr_name)
-  record_struct *record;
-  char          *attr_name;
+find_attr_in_record_by_name(
+  record_struct *record,
+  char          *attr_name)
 {
   av_pair_struct *av;
   dl_list_type   *av_list;
@@ -323,9 +322,9 @@ find_attr_in_record_by_name(record, attr_name)
 }
 
 av_pair_struct *
-find_attr_in_record_by_id(record, id)
-  record_struct *record;
-  int           id;
+find_attr_in_record_by_id(
+  record_struct *record,
+  int           id)
 {
   av_pair_struct *av;
   dl_list_type   *av_list;
@@ -356,11 +355,11 @@ find_attr_in_record_by_id(record, id)
 
 
 int
-append_attribute_to_record(record, class, attrib_name, value)
-  record_struct *record;
-  class_struct  *class;
-  char          *attrib_name;
-  char          *value;
+append_attribute_to_record(
+  record_struct *record,
+  class_struct  *class,
+  char          *attrib_name,
+  char          *value)
 {
   av_pair_struct    *av;
 
@@ -378,9 +377,9 @@ append_attribute_to_record(record, class, attrib_name, value)
 }
 
 int
-delete_attribute_from_record(record, attrib_name)
-  record_struct *record;
-  char          *attrib_name;
+delete_attribute_from_record(
+  record_struct *record,
+  char          *attrib_name)
 {
   av_pair_struct *av;
   dl_list_type   *av_list;
@@ -406,8 +405,8 @@ delete_attribute_from_record(record, attrib_name)
 }
 
 av_pair_struct *
-copy_av_pair(av)
-  av_pair_struct *av;
+copy_av_pair(
+  av_pair_struct *av)
 {
   av_pair_struct *copy;
 
@@ -429,8 +428,8 @@ copy_av_pair(av)
 }
 
 record_struct *
-copy_record(rec)
-  record_struct *rec;
+copy_record(
+  record_struct *rec)
 {
   record_struct  *copy;
   av_pair_struct *av;
@@ -460,11 +459,11 @@ copy_record(rec)
   }
 
   return(copy);
-}       
+}
 
 int
-destroy_record_data(rec)
-  record_struct *rec;
+destroy_record_data(
+  record_struct *rec)
 {
   if (!rec) return TRUE;
 
@@ -479,8 +478,8 @@ destroy_record_data(rec)
 }
 
 int
-destroy_av_pair_data(av)
-  av_pair_struct    *av;
+destroy_av_pair_data(
+  av_pair_struct    *av)
 {
   if (!av) return TRUE;
 
@@ -493,4 +492,3 @@ destroy_av_pair_data(av)
 
   return TRUE;
 }
-
--- a/mkdb/search.c
+++ b/mkdb/search.c
@@ -30,9 +30,9 @@
 
 
 static int
-rebuild_query(auth_area, query)
-  auth_area_struct *auth_area;
-  query_struct *query;
+rebuild_query(
+  auth_area_struct *auth_area,
+  query_struct *query)
 {
   query_term_struct    *cur_or;
   query_term_struct    *cur_and;
@@ -103,15 +103,14 @@ rebuild_query(auth_area, query)
 }
 
 static ret_code_type
-search_exact_index_file(class, auth_area, file, data_fi_list,
-                        query_tree, record_list, max_hits)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  file_struct       *file;
-  dl_list_type      *data_fi_list;
-  query_term_struct *query_tree;
-  dl_list_type      *record_list;
-  int               max_hits;
+search_exact_index_file(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  file_struct       *file,
+  dl_list_type      *data_fi_list,
+  query_term_struct *query_tree,
+  dl_list_type      *record_list,
+  int               max_hits)
 {
   off_t         fposition;
   ret_code_type ret_code    = SEARCH_SUCCESSFUL;
@@ -144,15 +143,14 @@ search_exact_index_file(class, auth_area, file, data_fi_list,
 }
 
 static ret_code_type
-search_soundex_index_file(class, auth_area, file, data_fi_list,
-                          query_tree, record_list, max_hits)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  file_struct       *file;
-  dl_list_type      *data_fi_list;
-  query_term_struct *query_tree;
-  dl_list_type      *record_list;
-  int               max_hits;
+search_soundex_index_file(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  file_struct       *file,
+  dl_list_type      *data_fi_list,
+  query_term_struct *query_tree,
+  dl_list_type      *record_list,
+  int               max_hits)
 {
   char          *orig_search_val;
   char          search_val_buf[MAX_LINE];
@@ -182,15 +180,14 @@ search_soundex_index_file(class, auth_area, file, data_fi_list,
 }
 
 static ret_code_type
-search_cidr_index_file(class, auth_area, file, data_fi_list,
-                       query_tree, record_list, max_hits)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  file_struct       *file;
-  dl_list_type      *data_fi_list;
-  query_term_struct *query_tree;
-  dl_list_type      *record_list;
-  int               max_hits;
+search_cidr_index_file(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  file_struct       *file,
+  dl_list_type      *data_fi_list,
+  query_term_struct *query_tree,
+  dl_list_type      *record_list,
+  int               max_hits)
 {
   struct netinfo         prefix;
   off_t                  fposition;
@@ -255,16 +252,15 @@ search_cidr_index_file(class, auth_area, file, data_fi_list,
 }
 
 static ret_code_type
-search_index_file(class, auth_area, index_fi_list, data_fi_list, query_tree,
-                  record_list, max_hits, index_type)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  dl_list_type      *index_fi_list;
-  dl_list_type      *data_fi_list;
-  query_term_struct *query_tree;
-  dl_list_type      *record_list;
-  int               max_hits;
-  attr_index_type   index_type;
+search_index_file(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  dl_list_type      *index_fi_list,
+  dl_list_type      *data_fi_list,
+  query_term_struct *query_tree,
+  dl_list_type      *record_list,
+  int               max_hits,
+  attr_index_type   index_type)
   /* for a switch-a-roo on a query's value */
 {
   file_struct    *file;
@@ -332,12 +328,12 @@ search_index_file(class, auth_area, index_fi_list, data_fi_list, query_tree,
 }
 
 static ret_code_type
-search_class(query_tree, auth_area, class, record_list, max_hits)
-  query_term_struct *query_tree;
-  auth_area_struct  *auth_area;
-  class_struct      *class;
-  dl_list_type      *record_list;
-  int               max_hits;
+search_class(
+  query_term_struct *query_tree,
+  auth_area_struct  *auth_area,
+  class_struct      *class,
+  dl_list_type      *record_list,
+  int               max_hits)
 {
   dl_list_type     master_fi_list;
   dl_list_type     index_fi_list;
@@ -408,12 +404,12 @@ search_class(query_tree, auth_area, class, record_list, max_hits)
 }
 
 static ret_code_type
-search_auth_area(auth_area, class_name, query, record_list, max_hits)
-  auth_area_struct *auth_area;
-  char             *class_name;
-  query_struct     *query;
-  dl_list_type     *record_list;
-  int              max_hits;
+search_auth_area(
+  auth_area_struct *auth_area,
+  char             *class_name,
+  query_struct     *query,
+  dl_list_type     *record_list,
+  int              max_hits)
 {
   class_struct  *class;
   dl_list_type  *class_list;
@@ -481,11 +477,11 @@ search_auth_area(auth_area, class_name, query, record_list, max_hits)
    the record_list. Returns the number of hits, and an error code it
    'ret_code' */
 int
-search(query, record_list, max_hits, ret_code)
-  query_struct  *query;
-  dl_list_type  *record_list;
-  int           max_hits;
-  ret_code_type *ret_code;
+search(
+  query_struct  *query,
+  dl_list_type  *record_list,
+  int           max_hits,
+  ret_code_type *ret_code)
 {
   dl_list_type     *auth_area_list = NULL;
   auth_area_struct *auth_area      = NULL;
@@ -591,8 +587,8 @@ search(query, record_list, max_hits, ret_code)
 }
 
 int
-check_query_complexity(query)
-  query_struct *query;
+check_query_complexity(
+  query_struct *query)
 {
   query_term_struct *current_or;
   query_term_struct *current_and;
--- a/mkdb/search_prim.c
+++ b/mkdb/search_prim.c
@@ -24,8 +24,8 @@ static int hit_count = 0;
 /* --------------------- Private Functions ------------------- */
 
 static int
-open_fp(file)
-  file_struct *file;
+open_fp(
+  file_struct *file)
 {
   /* open the file, if necessary */
   if (!file->fp)
@@ -41,8 +41,8 @@ open_fp(file)
 }
 
 static int
-close_fp(file)
-  file_struct *file;
+close_fp(
+  file_struct *file)
 {
   if (file->fp)
   {
@@ -57,11 +57,11 @@ close_fp(file)
 /* check_hit_list_for_hit: returns TRUE if the index_item already
    exists in the record_list */
 static int
-check_hit_list_for_hit(class, auth_area, record_list, index_item)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  dl_list_type     *record_list;
-  index_struct     index_item;
+check_hit_list_for_hit(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  dl_list_type     *record_list,
+  index_struct     index_item)
 {
   int           not_done;
   record_struct *record;
@@ -89,11 +89,11 @@ check_hit_list_for_hit(class, auth_area, record_list, index_item)
    allows us to invalidate certain kinds of searches (e.g.,
    unspecified searches on a type ID attribute) */
 static int
-validate_search_cond(class, auth_area, query_item, index_item)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  query_term_struct *query_item;
-  index_struct      *index_item;
+validate_search_cond(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  query_term_struct *query_item,
+  index_struct      *index_item)
 {
   attribute_struct *attr;
 
@@ -114,9 +114,9 @@ validate_search_cond(class, auth_area, query_item, index_item)
    conditions, returns true if the record matches all of the
    conditions */
 static int
-validate_and_list(record, query_list)
-  record_struct     *record;
-  query_term_struct *query_list;
+validate_and_list(
+  record_struct     *record,
+  query_term_struct *query_list)
 {
   dl_list_type   *pair_list;
   av_pair_struct *pair;
@@ -160,12 +160,12 @@ validate_and_list(record, query_list)
 
 /* note: this routine should probably reside in some form in records.c */
 static record_struct *
-fill_out_record(class, auth_area, index_item, data_fi_list, status)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  index_struct     *index_item;
-  dl_list_type     *data_fi_list;
-  rec_parse_result *status;
+fill_out_record(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  index_struct     *index_item,
+  dl_list_type     *data_fi_list,
+  rec_parse_result *status)
 {
   file_struct      *fi;
   record_struct    *result;
@@ -200,21 +200,17 @@ fill_out_record(class, auth_area, index_item, data_fi_list, status)
 
 /* --------------------- Public Functions -------------------- */
 
-void
-set_hit_count(value)
-  int value;
+void set_hit_count (int value)
 {
   hit_count = value;
 }
 
-void
-inc_hit_count()
+void inc_hit_count (void)
 {
   hit_count++;
 }
 
-int
-get_hit_count()
+int get_hit_count (void)
 {
   return(hit_count);
 }
@@ -224,9 +220,9 @@ get_hit_count()
    the index. The business of actually checking AND operations and
    such is done in the linear scan which should be called next. */
 off_t
-binary_search(file, query_item)
-  file_struct       *file;
-  query_term_struct *query_item;
+binary_search(
+  file_struct       *file,
+  query_term_struct *query_item)
 {
   FILE              *fp         = NULL;
   char              buf[MAX_BUF];
@@ -328,17 +324,16 @@ binary_search(file, query_item)
    doesn't match (if find_all_flag is false). Returns the number of
    hits it added to 'hit_list', -1 on error. */
 ret_code_type
-full_scan(class, auth_area, file, data_fi_list, query_item, record_list,
-          max_hits, start_pos, find_all_flag)
-  class_struct      *class;
-  auth_area_struct  *auth_area;
-  file_struct       *file;
-  dl_list_type      *data_fi_list;
-  query_term_struct *query_item;
-  dl_list_type      *record_list;
-  int               max_hits;
-  off_t             start_pos;
-  int               find_all_flag;
+full_scan(
+  class_struct      *class,
+  auth_area_struct  *auth_area,
+  file_struct       *file,
+  dl_list_type      *data_fi_list,
+  query_term_struct *query_item,
+  dl_list_type      *record_list,
+  int               max_hits,
+  off_t             start_pos,
+  int               find_all_flag)
 {
   FILE             *fp;
   char             line[MAX_LINE];
@@ -492,11 +487,11 @@ full_scan(class, auth_area, file, data_fi_list, query_item, record_list,
 #define     BUF_MID             (int) MAX_BACKUP_BUFFER / 2
 
 int
-scan_for_bol(fp, low, offset, high)
-  FILE          *fp;
-  register off_t low;
-  register off_t *offset;
-  register off_t high;
+scan_for_bol(
+  FILE          *fp,
+  register off_t low,
+  register off_t *offset,
+  register off_t high)
 {
   register off_t c;
   register int  inc = -1;
@@ -647,9 +642,9 @@ scan_for_bol(fp, low, offset, high)
    If there isn't a match then return(1) */
 
 int
-search_compare(query_item, index_value)
-  query_term_struct *query_item;
-  char              *index_value;
+search_compare(
+  query_term_struct *query_item,
+  char              *index_value)
 {
   int  relationship = 0;
   char *substring;
--- a/mkdb/y.tab.c
+++ b/mkdb/y.tab.c
@@ -1,27 +1,79 @@
+/* A Bison parser, made by GNU Bison 3.8.2.  */
 
-/*  A Bison parser, made from ./parse.y
- by  GNU Bison version 1.25
-  */
+/* Bison implementation for Yacc-like parsers in C
 
-#define YYBISON 1  /* Identify Bison output.  */
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
 
-#define	AND	258
-#define	OR	259
-#define	EQ	260
-#define	NEQ	261
-#define	CLASS	262
-#define	ATTR	263
-#define	VALUE	264
-#define	QUOTEDVALUE	265
-#define	WILD	266
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30802
+
+/* Bison version string.  */
+#define YYBISON_VERSION "3.8.2"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
 
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+
+
+/* First part of user prologue.  */
 #line 1 "./parse.y"
 
 /* *************************************************************
    RWhois Software
 
    Copyright (c) 1994 Scott Williamson and Mark Kosters
-   Copyright (c) 1996-2000 Network Solutions, Inc.
+   Copyright (c) 1996-1998 Network Solutions, Inc.
 
    See the file LICENSE for conditions of use and distribution.
 **************************************************************** */
@@ -52,864 +104,1328 @@ static void display_query_term PROTO((query_term_struct *term));
 static void display_query PROTO((void));
 
 
+#line 108 "y.tab.c"
+
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
+# ifndef YY_NULLPTR
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
+#  else
+#   define YY_NULLPTR ((void*)0)
+#  endif
+# endif
+
+/* Use api.header.include to #include this header
+   instead of duplicating it here.  */
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token kinds.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    AND = 258,                     /* AND  */
+    OR = 259,                      /* OR  */
+    EQ = 260,                      /* EQ  */
+    NEQ = 261,                     /* NEQ  */
+    CLASS = 262,                   /* CLASS  */
+    ATTR = 263,                    /* ATTR  */
+    VALUE = 264,                   /* VALUE  */
+    QUOTEDVALUE = 265,             /* QUOTEDVALUE  */
+    WILD = 266                     /* WILD  */
+  };
+  typedef enum yytokentype yytoken_kind_t;
+#endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define AND 258
+#define OR 259
+#define EQ 260
+#define NEQ 261
+#define CLASS 262
+#define ATTR 263
+#define VALUE 264
+#define QUOTEDVALUE 265
+#define WILD 266
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+union YYSTYPE
+{
 #line 48 "./parse.y"
-typedef union {
+
   char              *val;
   query_term_struct *qt;
-} YYSTYPE;
-#include <stdio.h>
 
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
+#line 188 "y.tab.c"
+
+};
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
 #endif
 
 
+extern YYSTYPE yylval;
 
-#define	YYFINAL		19
-#define	YYFLAG		-32768
-#define	YYNTBASE	12
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 266 ? yytranslate[x] : 16)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11
-};
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     3,     5,     9,    13,    15,    19,    23,    25,    27,
-    29
-};
+int yyparse (void);
+
 
-static const short yyrhs[] = {     7,
-    13,     0,    13,     0,    13,     3,    14,     0,    13,     4,
-    14,     0,    14,     0,     8,     5,    15,     0,     8,     6,
-    15,     0,    15,     0,     8,     0,     9,     0,    10,     0
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_AND = 3,                        /* AND  */
+  YYSYMBOL_OR = 4,                         /* OR  */
+  YYSYMBOL_EQ = 5,                         /* EQ  */
+  YYSYMBOL_NEQ = 6,                        /* NEQ  */
+  YYSYMBOL_CLASS = 7,                      /* CLASS  */
+  YYSYMBOL_ATTR = 8,                       /* ATTR  */
+  YYSYMBOL_VALUE = 9,                      /* VALUE  */
+  YYSYMBOL_QUOTEDVALUE = 10,               /* QUOTEDVALUE  */
+  YYSYMBOL_WILD = 11,                      /* WILD  */
+  YYSYMBOL_YYACCEPT = 12,                  /* $accept  */
+  YYSYMBOL_total = 13,                     /* total  */
+  YYSYMBOL_query = 14,                     /* query  */
+  YYSYMBOL_querystr = 15,                  /* querystr  */
+  YYSYMBOL_value = 16                      /* value  */
 };
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
-#endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    58,    59,    62,    63,    64,    67,    68,    69,    70,    73,
-    74
-};
+
+
+#ifdef short
+# undef short
 #endif
 
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
+#endif
 
-static const char * const yytname[] = {   "$","error","$undefined.","AND","OR",
-"EQ","NEQ","CLASS","ATTR","VALUE","QUOTEDVALUE","WILD","total","query","querystr",
-"value", NULL
-};
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
+#else
+typedef signed char yytype_int8;
 #endif
 
-static const short yyr1[] = {     0,
-    12,    12,    13,    13,    13,    14,    14,    14,    14,    15,
-    15
-};
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
+#else
+typedef short yytype_int16;
+#endif
 
-static const short yyr2[] = {     0,
-     2,     1,     3,     3,     1,     3,     3,     1,     1,     1,
-     1
-};
+/* Work around bug in HP-UX 11.23, which defines these macros
+   incorrectly for preprocessor constants.  This workaround can likely
+   be removed in 2023, as HPE has promised support for HP-UX 11.23
+   (aka HP-UX 11i v2) only through the end of 2022; see Table 2 of
+   <https://h20195.www2.hpe.com/V2/getpdf.aspx/4AA4-7673ENW.pdf>.  */
+#ifdef __hpux
+# undef UINT_LEAST8_MAX
+# undef UINT_LEAST16_MAX
+# define UINT_LEAST8_MAX 255
+# define UINT_LEAST16_MAX 65535
+#endif
 
-static const short yydefact[] = {     0,
-     0,     9,    10,    11,     2,     5,     8,     1,     0,     0,
-     0,     0,     6,     7,     3,     4,     0,     0,     0
-};
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
+#else
+typedef short yytype_uint8;
+#endif
 
-static const short yydefgoto[] = {    17,
-     5,     6,     7
-};
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
+#else
+typedef int yytype_uint16;
+#endif
 
-static const short yypact[] = {    -7,
-    -4,     2,-32768,-32768,     6,-32768,-32768,     6,     3,     3,
-    -4,    -4,-32768,-32768,-32768,-32768,    11,    14,-32768
-};
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
+#endif
 
-static const short yypgoto[] = {-32768,
-    18,     4,     8
-};
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned
+# endif
+#endif
 
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
 
-#define	YYLAST		19
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
 
 
-static const short yytable[] = {     1,
-     2,     3,     4,     2,     3,     4,     9,    10,    11,    12,
-    18,     3,     4,    19,    15,    16,    13,    14,     8
-};
+/* Stored state numbers (used for stacks). */
+typedef yytype_int8 yy_state_t;
 
-static const short yycheck[] = {     7,
-     8,     9,    10,     8,     9,    10,     5,     6,     3,     4,
-     0,     9,    10,     0,    11,    12,     9,    10,     1
-};
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/local/share/bison.simple"
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
 
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+#ifndef YY_ATTRIBUTE_PURE
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
+#endif
 
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
-
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-#ifndef alloca
-#ifdef __GNUC__
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
-#include <alloca.h>
-#else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
-#include <malloc.h>
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-#include <malloc.h>
- #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
-#ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
-};
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
-#endif /* __hpux */
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
-#define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  */
-#define YYFAIL		goto yyerrlab
-#define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
-      goto yybackup;						\
-    }								\
-  else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-#ifndef YYPURE
-#define YYLEX		yylex()
+#ifndef YY_ATTRIBUTE_UNUSED
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+# else
+#  define YY_ATTRIBUTE_UNUSED
+# endif
 #endif
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YY_USE(E) ((void) (E))
 #else
-#define YYLEX		yylex(&yylval, &yylloc)
+# define YY_USE(E) /* empty */
 #endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+#if defined __GNUC__ && ! defined __ICC && 406 <= __GNUC__ * 100 + __GNUC_MINOR__
+# if __GNUC__ * 100 + __GNUC_MINOR__ < 407
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")
+# else
+#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                           \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# endif
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
+    _Pragma ("GCC diagnostic pop")
 #else
-#define YYLEX		yylex(&yylval)
+# define YY_INITIAL_VALUE(Value) Value
 #endif
-#endif /* not YYLSP_NEEDED */
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
 #endif
 
-/* If nonreentrant, generate the variables here */
 
-#ifndef YYPURE
+#define YY_ASSERT(E) ((void) (0 && (E)))
+
+#if !defined yyoverflow
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* !defined yyoverflow */
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yy_state_t yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYPTRDIFF_T yynewbytes;                                         \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
+      }                                                                 \
+    while (0)
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
 #endif
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYPTRDIFF_T yyi;                      \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  12
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   18
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  12
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  5
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  12
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  19
+
+/* YYMAXUTOK -- Last valid token kind.  */
+#define YYMAXUTOK   266
+
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11
+};
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
+#if YYDEBUG
+/* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_int8 yyrline[] =
+{
+       0,    58,    58,    59,    62,    63,    64,    67,    68,    69,
+      70,    73,    74
+};
 #endif
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
 
-#ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "\"end of file\"", "error", "\"invalid token\"", "AND", "OR", "EQ",
+  "NEQ", "CLASS", "ATTR", "VALUE", "QUOTEDVALUE", "WILD", "$accept",
+  "total", "query", "querystr", "value", YY_NULLPTR
+};
 
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
+{
+  return yytname[yysymbol];
+}
 #endif
 
-#ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
-#endif
+#define YYPACT_NINF (-8)
+
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
+
+#define YYTABLE_NINF (-1)
+
+#define yytable_value_is_error(Yyn) \
+  0
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      -7,    -4,     2,    -8,    -8,    11,     6,    -8,    -8,     6,
+       3,     3,    -8,    -4,    -4,    -8,    -8,    -8,    -8
+};
+
+/* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+   Performed when YYTABLE does not specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_int8 yydefact[] =
+{
+       0,     0,    10,    11,    12,     0,     3,     6,     9,     2,
+       0,     0,     1,     0,     0,     7,     8,     4,     5
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+      -8,    -8,    15,     1,     7
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+       0,     5,     6,     7,     8
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule whose
+   number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
+{
+       1,     2,     3,     4,     2,     3,     4,    10,    11,    13,
+      14,    12,     3,     4,    17,    18,     9,    15,    16
+};
+
+static const yytype_int8 yycheck[] =
+{
+       7,     8,     9,    10,     8,     9,    10,     5,     6,     3,
+       4,     0,     9,    10,    13,    14,     1,    10,    11
+};
+
+/* YYSTOS[STATE-NUM] -- The symbol kind of the accessing symbol of
+   state STATE-NUM.  */
+static const yytype_int8 yystos[] =
+{
+       0,     7,     8,     9,    10,    13,    14,    15,    16,    14,
+       5,     6,     0,     3,     4,    16,    16,    15,    15
+};
+
+/* YYR1[RULE-NUM] -- Symbol kind of the left-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr1[] =
+{
+       0,    12,    13,    13,    14,    14,    14,    15,    15,    15,
+      15,    16,    16
+};
+
+/* YYR2[RULE-NUM] -- Number of symbols on the right-hand side of rule RULE-NUM.  */
+static const yytype_int8 yyr2[] =
+{
+       0,     2,     2,     1,     3,     3,     1,     3,     3,     1,
+       1,     1,     1
+};
+
+
+enum { YYENOMEM = -2 };
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+#define YYNOMEM         goto yyexhaustedlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+
+
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Kind, Value); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
+{
+  FILE *yyoutput = yyo;
+  YY_USE (yyoutput);
+  if (!yyvaluep)
+    return;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
 
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
-#endif
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
 static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     int count;
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep)
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  while (i-- > 0)
-    *t++ = *f++;
+  yy_symbol_value_print (yyo, yykind, yyvaluep);
+  YYFPRINTF (yyo, ")");
 }
 
-#else /* __cplusplus */
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
 static void
-__yy_memcpy (char *to, char *from, int count)
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
 
-  while (i-- > 0)
-    *t++ = *f++;
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule)
+{
+  int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)]);
+      YYFPRINTF (stderr, "\n");
+    }
 }
 
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, Rule); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
 #endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
 #endif
-
-#line 196 "/usr/local/share/bison.simple"
-
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
-
-#ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
 
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
+
+
+
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep)
 {
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+  YY_USE (yyvaluep);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YY_USE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
 
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+/* Lookahead token kind.  */
+int yychar;
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
-#else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
 
-  int yystacksize = YYINITDEPTH;
 
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
+/*----------.
+| yyparse.  |
+`----------*/
 
-  int yylen;
+int
+yyparse (void)
+{
+    yy_state_fast_t yystate = 0;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus = 0;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY;		/* Cause a token to be read.  */
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
 
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-  yyssp = yyss - 1;
-  yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+  int yyn;
+  /* The return value of yyparse.  */
+  int yyresult;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
 
-  *++yyssp = yystate;
 
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
 
-      /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
-#else /* no yyoverflow */
-      /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  return 2;
-	}
-      yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
-	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
-#endif
-#endif /* no yyoverflow */
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  goto yysetstate;
 
-      if (yyssp >= yyss + yystacksize - 1)
-	YYABORT;
+
+/*------------------------------------------------------------.
+| yynewstate -- push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
+
+  if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    YYNOMEM;
+#else
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
+
+# if defined yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        yy_state_t *yyss1 = yyss;
+        YYSTYPE *yyvs1 = yyvs;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
+                    &yystacksize);
+        yyss = yyss1;
+        yyvs = yyvs1;
+      }
+# else /* defined YYSTACK_RELOCATE */
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        YYNOMEM;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yy_state_t *yyss1 = yyss;
+        union yyalloc *yyptr =
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
+        if (! yyptr)
+          YYNOMEM;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
     }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
 
   goto yybackup;
- yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
 
-  /* First try to decide what to do without reference to lookahead token.  */
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to lookahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yypact_value_is_default (yyn))
     goto yydefault;
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
-
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
-      yychar = YYLEX;
+      YYDPRINTF ((stderr, "Reading a token\n"));
+      yychar = yylex ();
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
-	goto yyerrlab;
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
-  if (yyn == YYFINAL)
-    YYACCEPT;
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
-
-  /* Discard the token being shifted unless it is eof.  */
-  if (yychar != YYEOF)
-    yychar = YYEMPTY;
-
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
-
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
-  yystate = yyn;
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+
+/*-----------------------------.
+| yyreduce -- do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
 
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
 
-  switch (yyn) {
 
-case 1:
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+  case 2: /* total: CLASS query  */
 #line 58 "./parse.y"
-{ set_query(yyvsp[-1].val, NULL); ;
-    break;}
-case 3:
+                          { set_query((yyvsp[-1].val), NULL); }
+#line 1179 "y.tab.c"
+    break;
+
+  case 4: /* query: query AND querystr  */
 #line 62 "./parse.y"
-{ add_term(yyvsp[0].qt); add_and_term(); ;
-    break;}
-case 4:
+                          { add_term((yyvsp[0].qt)); add_and_term(); }
+#line 1185 "y.tab.c"
+    break;
+
+  case 5: /* query: query OR querystr  */
 #line 63 "./parse.y"
-{ add_term(yyvsp[0].qt); add_or_term();  ;
-    break;}
-case 5:
+                          { add_term((yyvsp[0].qt)); add_or_term();  }
+#line 1191 "y.tab.c"
+    break;
+
+  case 6: /* query: querystr  */
 #line 64 "./parse.y"
-{ add_term(yyvsp[0].qt); ;
-    break;}
-case 6:
+                          { add_term((yyvsp[0].qt)); }
+#line 1197 "y.tab.c"
+    break;
+
+  case 7: /* querystr: ATTR EQ value  */
 #line 67 "./parse.y"
-{ yyval.qt = set_query_term(yyvsp[-2].val, yyvsp[0].val, MKDB_EQ_OP);   ;
-    break;}
-case 7:
+                         { (yyval.qt) = set_query_term((yyvsp[-2].val), (yyvsp[0].val), MKDB_EQ_OP);   }
+#line 1203 "y.tab.c"
+    break;
+
+  case 8: /* querystr: ATTR NEQ value  */
 #line 68 "./parse.y"
-{ yyval.qt = set_query_term(yyvsp[-2].val, yyvsp[0].val, MKDB_NOT_EQ_OP); ;
-    break;}
-case 8:
+                         { (yyval.qt) = set_query_term((yyvsp[-2].val), (yyvsp[0].val), MKDB_NOT_EQ_OP); }
+#line 1209 "y.tab.c"
+    break;
+
+  case 9: /* querystr: value  */
 #line 69 "./parse.y"
-{ yyval.qt = set_query_term(NULL, yyvsp[0].val, MKDB_EQ_OP); ;
-    break;}
-case 9:
+                         { (yyval.qt) = set_query_term(NULL, (yyvsp[0].val), MKDB_EQ_OP); }
+#line 1215 "y.tab.c"
+    break;
+
+  case 10: /* querystr: ATTR  */
 #line 70 "./parse.y"
-{ yyval.qt = set_query_term(NULL, yyvsp[0].val, MKDB_EQ_OP); ;
-    break;}
-case 10:
+                         { (yyval.qt) = set_query_term(NULL, (yyvsp[0].val), MKDB_EQ_OP); }
+#line 1221 "y.tab.c"
+    break;
+
+  case 11: /* value: VALUE  */
 #line 73 "./parse.y"
-{ yyval.val = yyvsp[0].val; ;
-    break;}
-case 11:
+                         { (yyval.val) = (yyvsp[0].val); }
+#line 1227 "y.tab.c"
+    break;
+
+  case 12: /* value: QUOTEDVALUE  */
 #line 74 "./parse.y"
-{ yyval.val = yyvsp[0].val; ;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 498 "/usr/local/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
+                         { (yyval.val) = (yyvsp[0].val); }
+#line 1233 "y.tab.c"
+    break;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
 
-  *++yyvsp = yyval;
+#line 1237 "y.tab.c"
 
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
+      default: break;
     }
-#endif
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
-
-  yyn = yyr1[yyn];
+  *++yyvsp = yyval;
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTBASE];
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
+      yyerror (YY_("syntax error"));
+    }
 
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
-	}
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
       else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval);
+          yychar = YYEMPTY;
+        }
     }
 
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
 
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+  ++yynerrs;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
-      yychar = YYEMPTY;
+  /* Pop stack until we find a state that shifts the error token.  */
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+
+      yydestruct ("Error: popping",
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
     }
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
 
-  goto yyerrhandle;
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
+  yystate = yyn;
+  goto yynewstate;
 
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturnlab;
 
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturnlab;
 
-yyerrhandle:
 
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+/*-----------------------------------------------------------.
+| yyexhaustedlab -- YYNOMEM (memory exhaustion) comes here.  |
+`-----------------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  goto yyreturnlab;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
+/*----------------------------------------------------------.
+| yyreturnlab -- parsing is finished, clean up and return.  |
+`----------------------------------------------------------*/
+yyreturnlab:
+  if (yychar != YYEMPTY)
     {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
-
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
 #endif
 
-  yystate = yyn;
-  goto yynewstate;
+  return yyresult;
 }
+
 #line 77 "./parse.y"
 
 
@@ -920,9 +1436,9 @@ static query_term_struct   *working_term;
 static int                 parse_status;
   
 static int
-set_query(class_name, auth_area_name)
-  char *class_name;
-  char *auth_area_name;
+set_query(
+  char *class_name,
+  char *auth_area_name)
 {
   if (auth_area_name && *auth_area_name)
   {
@@ -938,10 +1454,10 @@ set_query(class_name, auth_area_name)
 }
 
 static query_term_struct *
-set_query_term(attribute_name, value, op)
-  char               *attribute_name;
-  char               *value;
-  mkdb_operator_type op;
+set_query_term(
+  char               *attribute_name,
+  char               *value,
+  mkdb_operator_type op)
 {
   query_term_struct *qt;
   
@@ -991,8 +1507,8 @@ set_query_term(attribute_name, value, op)
 
 /* sets working term to the term, and if necessary sets the first term */
 static void
-add_term(term)
-  query_term_struct *term;
+add_term(
+  query_term_struct *term)
 {
   if (working_term)
   {
@@ -1038,8 +1554,8 @@ add_or_term()
 }
 
 static void
-display_query_term(term)
-  query_term_struct *term;
+display_query_term(
+  query_term_struct *term)
 {
 
   printf(" ");
@@ -1086,9 +1602,9 @@ display_query()
   
 
 int
-parse_query(line, result)
-  char         *line;
-  query_struct *result;
+parse_query(
+  char         *line,
+  query_struct *result)
 {
   /* reset global variables */
   parse_result = result;
@@ -1107,8 +1623,8 @@ parse_query(line, result)
 }
 
 int
-yyerror(s)
-  char *s;
+yyerror(
+  char *s)
 {
   print_error(INVALID_QUERY_SYNTAX, "");
   parse_status = FALSE;
@@ -1116,8 +1632,8 @@ yyerror(s)
 }
 
 int
-destroy_query_term(qt)
-  query_term_struct *qt;
+destroy_query_term(
+  query_term_struct *qt)
 {
   if (!qt) return TRUE;
 
@@ -1137,8 +1653,8 @@ destroy_query_term(qt)
 }
 
 int
-destroy_query(q)
-  query_struct  *q;
+destroy_query(
+  query_struct  *q)
 {
   query_term_struct *horiz;
   query_term_struct *vert;
--- a/mkdb/y.tab.h
+++ b/mkdb/y.tab.h
@@ -1,16 +1,108 @@
-typedef union {
+/* A Bison parser, made by GNU Bison 3.8.2.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2021 Free Software Foundation,
+   Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+#ifndef YY_YY_Y_TAB_H_INCLUDED
+# define YY_YY_Y_TAB_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int yydebug;
+#endif
+
+/* Token kinds.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    AND = 258,                     /* AND  */
+    OR = 259,                      /* OR  */
+    EQ = 260,                      /* EQ  */
+    NEQ = 261,                     /* NEQ  */
+    CLASS = 262,                   /* CLASS  */
+    ATTR = 263,                    /* ATTR  */
+    VALUE = 264,                   /* VALUE  */
+    QUOTEDVALUE = 265,             /* QUOTEDVALUE  */
+    WILD = 266                     /* WILD  */
+  };
+  typedef enum yytokentype yytoken_kind_t;
+#endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define AND 258
+#define OR 259
+#define EQ 260
+#define NEQ 261
+#define CLASS 262
+#define ATTR 263
+#define VALUE 264
+#define QUOTEDVALUE 265
+#define WILD 266
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+union YYSTYPE
+{
+#line 48 "./parse.y"
+
   char              *val;
   query_term_struct *qt;
-} YYSTYPE;
-#define	AND	258
-#define	OR	259
-#define	EQ	260
-#define	NEQ	261
-#define	CLASS	262
-#define	ATTR	263
-#define	VALUE	264
-#define	QUOTEDVALUE	265
-#define	WILD	266
+
+#line 94 "y.tab.h"
+
+};
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
 
 
 extern YYSTYPE yylval;
+
+
+int yyparse (void);
+
+
+#endif /* !YY_YY_Y_TAB_H_INCLUDED  */
--- a/regexp/regerror.c
+++ b/regexp/regerror.c
@@ -1,8 +1,4 @@
-#include <stdio.h>
-
-void
-regerror(s)
-char *s;
+void regerror (char *s)
 {
 #ifdef ERRAVAIL
 	error("regexp: %s", s);
--- a/regexp/regexp.c
+++ b/regexp/regexp.c
@@ -185,16 +185,16 @@ static long regsize;            /* Code size. */
 #ifndef STATIC
 #define STATIC  static
 #endif
-STATIC char *reg();
-STATIC char *regbranch();
-STATIC char *regpiece();
-STATIC char *regatom();
-STATIC char *regnode();
-STATIC char *regnext();
-STATIC void regc();
-STATIC void reginsert();
-STATIC void regtail();
-STATIC void regoptail();
+STATIC char *reg (int paren, int *flagp);
+STATIC char *regbranch (int *flagp);
+STATIC char *regpiece (int *flagp);
+STATIC char *regnode (int op);
+STATIC char *regatom (int *flagp);
+STATIC char *regnext (register char *p);
+STATIC void regc (int b);
+STATIC void reginsert (int op, char *opnd);
+STATIC void regtail (char *p, char *val);
+STATIC void regoptail (char *p, char *val);
 #ifdef STRCSPN
 STATIC int strcspn();
 #endif
@@ -215,8 +215,7 @@ STATIC int strcspn();
  * of the structure of the compiled regexp.
  */
 regexp *
-regcomp(exp)
-char *exp;
+regcomp(char *exp)
 {
         register regexp *r;
         register char *scan;
@@ -304,9 +303,10 @@ char *exp;
  * follows makes it hard to avoid.
  */
 static char *
-reg(paren, flagp)
-int paren;                      /* Parenthesized? */
-int *flagp;
+reg (
+    int paren,                      /* Parenthesized? */
+    int *flagp
+)
 {
         register char *ret;
         register char *br;
@@ -375,9 +375,7 @@ int *flagp;
  *
  * Implements the concatenation operator.
  */
-static char *
-regbranch(flagp)
-int *flagp;
+static char *regbranch (int *flagp)
 {
         register char *ret;
         register char *chain;
@@ -415,9 +413,7 @@ int *flagp;
  * It might seem that this node could be dispensed with entirely, but the
  * endmarker role is not redundant.
  */
-static char *
-regpiece(flagp)
-int *flagp;
+static char *regpiece (int *flagp)
 {
         register char *ret;
         register char op;
@@ -479,9 +475,7 @@ int *flagp;
  * faster to run.  Backslashed characters are exceptions, each becoming a
  * separate node; the code is simpler that way and it's not worth fixing.
  */
-static char *
-regatom(flagp)
-int *flagp;
+static char *regatom (int *flagp)
 {
         register char *ret;
         int flags;
@@ -657,9 +651,7 @@ int *flagp;
 /*
  - regnode - emit a node
  */
-static char *                   /* Location. */
-regnode(op)
-char op;
+static char *regnode (int op)
 {
         register char *ret;
         register char *ptr;
@@ -682,9 +674,7 @@ char op;
 /*
  - regc - emit (if appropriate) a byte of code
  */
-static void
-regc(b)
-char b;
+static void regc (int b)
 {
         if (regcode != &regdummy)
                 *regcode++ = b;
@@ -697,10 +687,7 @@ char b;
  *
  * Means relocating the operand.
  */
-static void
-reginsert(op, opnd)
-char op;
-char *opnd;
+static void reginsert (int op, char *opnd)
 {
         register char *src;
         register char *dst;
@@ -726,10 +713,7 @@ char *opnd;
 /*
  - regtail - set the next-pointer at the end of a node chain
  */
-static void
-regtail(p, val)
-char *p;
-char *val;
+static void regtail (char *p, char *val)
 {
         register char *scan;
         register char *temp;
@@ -758,10 +742,7 @@ char *val;
 /*
  - regoptail - regtail on operand of first argument; nop if operandless
  */
-static void
-regoptail(p, val)
-char *p;
-char *val;
+static void regoptail (char *p, char *val)
 {
         /* "Operandless" and "op != BRANCH" are synonymous in practice. */
         if (p == NULL || p == &regdummy || OP(p) != BRANCH)
@@ -784,9 +765,9 @@ static char **regendp;          /* Ditto for endp. */
 /*
  * Forwards.
  */
-STATIC int regtry();
-STATIC int regmatch();
-STATIC int regrepeat();
+STATIC int regtry(regexp *prog, char *string);
+STATIC int regmatch (char *prog);
+STATIC int regrepeat (char *p);
 
 #ifdef DEBUG
 int regnarrate = 0;
@@ -798,9 +779,9 @@ STATIC char *regprop();
  - regexec - match a regexp against a string
  */
 int
-regexec(prog, string)
-register regexp *prog;
-register char *string;
+regexec(
+register regexp *prog,
+register char *string)
 {
         register char *s;
         /* extern char *strchr(); */
@@ -860,9 +841,9 @@ register char *string;
  - regtry - try match at specific point
  */
 static int                      /* 0 failure, 1 success */
-regtry(prog, string)
-regexp *prog;
-char *string;
+regtry(
+regexp *prog,
+char *string)
 {
         register int i;
         register char **sp;
@@ -896,9 +877,7 @@ char *string;
  * need to know whether the rest of the match failed) by a loop instead of
  * by recursion.
  */
-static int                      /* 0 failure, 1 success */
-regmatch(prog)
-char *prog;
+static int regmatch (char *prog)
 {
         register char *scan;    /* Current node. */
         char *next;             /* Next node. */
@@ -1099,9 +1078,7 @@ char *prog;
 /*
  - regrepeat - repeatedly match something simple, report how many
  */
-static int
-regrepeat(p)
-char *p;
+static int regrepeat (char *p)
 {
         register int count = 0;
         register char *scan;
@@ -1147,9 +1124,7 @@ char *p;
 /*
  - regnext - dig the "next" pointer out of a node
  */
-static char *
-regnext(p)
-register char *p;
+static char *regnext (register char *p)
 {
         register int offset;
 
@@ -1217,9 +1192,7 @@ regexp *r;
 /*
  - regprop - printable representation of opcode
  */
-static char *
-regprop(op)
-char *op;
+static char *regprop (char *op)
 {
         register char *p;
         static char buf[50];
@@ -1315,10 +1288,7 @@ char *op;
  * of characters not from s2
  */
 
-static int
-strcspn(s1, s2)
-char *s1;
-char *s2;
+static int strcspn (char *s1, char *s2)
 {
         register char *scan1;
         register char *scan2;
--- a/regexp/regexp.h
+++ b/regexp/regexp.h
@@ -18,9 +18,9 @@ typedef struct regexp {
         char program[1];        /* Unwarranted chumminess with compiler. */
 } regexp;
 
-extern regexp *regcomp();
-extern int regexec();
-extern void regsub();
+extern regexp *regcomp(char *exp);
+extern int regexec(regexp *prog, char *string);
+extern void regsub(regexp *prog, char *source, char *dest);
 extern void regerror(char *);
 
 #endif /* _REGEXP_H_ */
--- a/regexp/regsub.c
+++ b/regexp/regsub.c
@@ -19,7 +19,7 @@
  *		be misrepresented as being the original software.
  */
 #include <stdio.h>
-#include <regexp.h>
+#include "regexp.h"
 #include "regmagic.h"
 
 #ifndef CHARBITS
@@ -32,10 +32,10 @@
  - regsub - perform substitutions after a regexp match
  */
 void
-regsub(prog, source, dest)
-regexp *prog;
-char *source;
-char *dest;
+regsub(
+regexp *prog,
+char *source,
+char *dest)
 {
 	register char *src;
 	register char *dst;
--- a/server/class_directive.c
+++ b/server/class_directive.c
@@ -39,9 +39,7 @@ typedef struct _class_arg_struct
 
 /* ------------------- Local Functions -------------------- */
 
-static int
-destroy_class_arg_struct(cs)
-  class_arg_struct *cs;
+static int destroy_class_arg_struct (class_arg_struct *cs)
 {
   if (!cs) return TRUE;
   
@@ -55,9 +53,7 @@ destroy_class_arg_struct(cs)
 /* class_parse_args:  parses argument of -class call.  
  *  It returns a class_arg_struct on success. 
  */
-static class_arg_struct * 
-class_parse_args(str)
-  char *str;
+static class_arg_struct *class_parse_args (char *str)
 {
   class_arg_struct  *cs;
   auth_area_struct  *auth_area;
@@ -126,9 +122,9 @@ class_parse_args(str)
 
 /* display_one_class: display one class. 
  */
-static void 
-display_one_class(class)
-  class_struct *class;
+static void
+display_one_class(
+  class_struct *class)
 {
 
     print_response(RESP_CLASS, "%s:description:%s",class->name,
@@ -142,13 +138,13 @@ display_one_class(class)
 /* display_classses: display all the classes in a class-list.  
  * Only description and version info are displayed. 
  */
-static void 
-display_classes(class_list)
-  dl_list_type *class_list;
-{   
+static void
+display_classes(
+  dl_list_type *class_list)
+{
   int          not_done;
   class_struct *class;
- 
+
   not_done = dl_list_first(class_list);
   while (not_done)
   {
@@ -166,16 +162,14 @@ display_classes(class_list)
 
 /* class_directive:  process the call to -class directive.
  */
-int 
-class_directive(str)
-  char * str;
+int class_directive (char *str)
 {
   class_arg_struct *in = NULL;
 
 
   in = class_parse_args(str);
 
-  if (!in) 
+  if (!in)
   {
     return FALSE;
   }
--- a/server/daemon.c
+++ b/server/daemon.c
@@ -25,8 +25,7 @@ static int num_children = 0;
 /* -------------------- Local Functions ----------------- */
 
 /* logpid: put the pid in a specified file */
-static void
-logpid ()
+static void logpid (void)
 {
   FILE *fp;
 
@@ -37,8 +36,7 @@ logpid ()
   }
 }
 
-static void
-delpid()
+static void delpid (void)
 {
   char  *pid_file = get_pid_file();
 
@@ -49,8 +47,7 @@ delpid()
 }
 
 /* daemonize: turn the process into a daemon a la Stevens */
-static void
-daemonize()
+static void daemonize (void)
 {
   /* ignore TTY signals, if necessary */
 
@@ -92,8 +89,8 @@ daemonize()
 
 /* the sigchld signal handler */
 static RETSIGTYPE
-sigchld_handler(arg)
-  int   arg;
+sigchld_handler(
+  int   arg)
 {
   int       status;
   pid_t     pid;
@@ -107,42 +104,39 @@ sigchld_handler(arg)
 
   /* reset the signal handler -- some older systems remove the signal
      handler upon use.  POSIX systems should not do this */
-  signal(SIGCHLD, sigchld_handler);
+  signal(SIGCHLD, (__sighandler_t)sigchld_handler);
 }
 
 static RETSIGTYPE
-sighup_handler(arg)
-  int   arg;
+sighup_handler(
+  int   arg)
 {
   hup_recvd = TRUE;
-  signal(SIGHUP, sighup_handler);
+  signal(SIGHUP, (__sighandler_t)sighup_handler);
 }
 
 static RETSIGTYPE
-exit_handler(arg)
-  int   arg;
+exit_handler(
+  int   arg)
 {
   log(L_LOG_NOTICE, UNKNOWN, "Exiting");
   delpid();
   exit(0);
 }
 
-static void
-set_sighup()
+static void set_sighup (void)
 {
-  signal(SIGHUP, sighup_handler);
+  signal(SIGHUP, (__sighandler_t)sighup_handler);
 }
 
 /* this actually handles all the normal quitting signals */
-static void
-set_exithandler()
+static void set_exithandler (void)
 {
-  signal(SIGINT, exit_handler);
+  signal(SIGINT, (__sighandler_t)exit_handler);
   signal(SIGTERM, exit_handler);
 }
 
-static void
-reinit()
+static void reinit (void)
 {
   log(L_LOG_NOTICE, CONFIG, "Hangup received -- reinitializing");
 
@@ -165,16 +159,14 @@ reinit()
 
 /* -------------------- Public Functions ---------------- */
 
-void
-no_zombies()
+void no_zombies (void)
 {
   /* we need the sigchld handler to limit the number of concurrent
      processes */
-  signal(SIGCHLD, sigchld_handler);
+  signal(SIGCHLD, (__sighandler_t)sigchld_handler);
 }
 
-int
-run_daemon()
+int run_daemon (void)
 {
 #ifdef HAVE_IPV6
   struct sockaddr_storage client_addr;
--- a/server/deadman.c
+++ b/server/deadman.c
@@ -21,10 +21,7 @@ static long initial_time = -1;
 /******************************************************************************
   sets the timer for seconds before calling function
 ******************************************************************************/
-void
-set_timer(seconds, function)
-  int   seconds;
-  void  *function;
+void set_timer (int seconds, void *function)
 {
   if (seconds)
   {
@@ -37,8 +34,7 @@ set_timer(seconds, function)
 /******************************************************************************
  notifies user that deadman time has come - logs it and bye!
 ******************************************************************************/
-void
-is_a_deadman()
+void is_a_deadman (void)
 {
   print_error (DEADMAN_TIME, "");
   log(L_LOG_INFO, CLIENT, "deadman time exceeded - terminating connection.");
@@ -48,8 +44,7 @@ is_a_deadman()
 /******************************************************************************
  unsets the timer
 ******************************************************************************/
-void
-unset_timer()
+void unset_timer (void)
 {
   signal(SIGALRM, SIG_IGN);
 }
@@ -57,9 +52,7 @@ unset_timer()
 /******************************************************************************
  sets seconds before exiting (read from config file)
 ******************************************************************************/
-void
-set_deadman_time(secs)
-  char *secs;
+void set_deadman_time (char *secs)
 {
   if (atoi (secs))
   {
@@ -70,8 +63,7 @@ set_deadman_time(secs)
 /******************************************************************************
  recovers the deadman second timer
 ******************************************************************************/
-int
-get_deadman_time ()
+int get_deadman_time (void)
 {
   /* value is uninitialized -- pull default from config */
   if (deadman_time < 0)
@@ -82,15 +74,13 @@ get_deadman_time ()
 }
 
 
-void
-set_initial_time()
+void set_initial_time (void)
 {
   initial_time = time((time_t *) NULL);
 }
 
 
-long
-get_time_elapsed()
+long get_time_elapsed (void)
 {
   long current_time;
  
--- a/server/directive.c
+++ b/server/directive.c
@@ -37,10 +37,7 @@
 
 /* --------------------- Local Functions ------------------ */
 
-static int
-add_directive_func(name, func)
-  char *name;
-  int  (*func)();
+static int add_directive_func (char *name, int (*func)(void))
 {
   directive_struct  *item;
 
@@ -63,8 +60,7 @@ add_directive_func(name, func)
 /* --------------------- Public Functions ----------------- */
 
 /* initializes the native commands */
-void
-init_directive_functions()
+void init_directive_functions (void)
 {
   add_directive_func("class", class_directive);
   add_directive_func("directive", directive_directive);
@@ -85,9 +81,7 @@ init_directive_functions()
 }
 
 /* is_directive: returns TRUE if is directive command, FALSE otherwise */
-int
-is_directive(str)
-  char *str;
+int is_directive (char *str)
 {
   if (!str || !*str)
   {
@@ -104,9 +98,7 @@ is_directive(str)
 
 /* run directive: given a query string that is a directive, decode the
       directive and run it */
-int
-run_directive(query_str)
-  char  *query_str;
+int run_directive (char *query_str)
 {
   directive_struct  *di;
   char              *directive;
@@ -184,9 +176,7 @@ run_directive(query_str)
    Response:    %directive directive:<name>
                 %directive description:<description>
                 %directive */
-int
-directive_directive( str)
-  char *str;
+int directive_directive (char *str)
 {
   dl_list_type      *full_list;
   directive_struct  *dir_struct;
--- a/server/display.c
+++ b/server/display.c
@@ -27,9 +27,7 @@
  *  -OR-
  *      %error if non-RWhois client.
  */
-int
-display_directive( str)
-  char  *str;
+int display_directive (char *str)
 {
   int   argc;
   char  **argv;
--- a/server/exit.c
+++ b/server/exit.c
@@ -16,9 +16,7 @@
 /*************************************************************************
   exits the whois loop
 **************************************************************************/
-int
-quit_directive(str)
-  char *str;
+int quit_directive (char *str)
 {
    print_ok(); 
 
--- a/server/forward.c
+++ b/server/forward.c
@@ -26,9 +26,7 @@ static char original_query_buf[MAX_LINE];
   sets the cache value
    toggles it for now
 **************************************************************************/
-int
-forward_directive( str )
-  char *str;
+int forward_directive (char *str)
 {
   if ( !set_forward(str) )
   {
@@ -45,11 +43,7 @@ forward_directive( str )
 /**************************************************************************
   forwards the request
 **************************************************************************/
-int
-forward_request(host, query, auth_area)
-  char *host;
-  char *query;
-  char *auth_area;
+int forward_request (char *host, char *query, char *auth_area)
 
 {
   char param_str[MAX_LINE];
@@ -63,9 +57,7 @@ forward_request(host, query, auth_area)
 /**************************************************************************
   saves the query
 **************************************************************************/
-int
-save_original_query (query_str)
-  char *query_str;
+int save_original_query (char *query_str)
 
 {
   strcpy(original_query_buf, query_str);
@@ -76,8 +68,7 @@ save_original_query (query_str)
 /**************************************************************************
   retrieves the query
 **************************************************************************/
-char *
-original_query()
+char *original_query (void)
 {
   return(original_query_buf);
 }
--- a/server/holdconnect.c
+++ b/server/holdconnect.c
@@ -17,9 +17,7 @@
 #include "strutil.h"
 
 /* set_holdconnect: sets the holdconnect value */
-int 
-holdconnect_directive( str )
-  char  *str;
+int holdconnect_directive (char *str)
 {
   log(L_LOG_DEBUG, CLIENT, "holdconnect directive: %s", str);
   
--- a/server/limit.c
+++ b/server/limit.c
@@ -23,9 +23,7 @@
  *      -OR- 
  *       error messages.
  */
-int 
-limit_directive(str)
-  char  *str;
+int limit_directive (char *str)
 {
   int hits;
   int ceiling;
--- a/server/main.c
+++ b/server/main.c
@@ -48,9 +48,7 @@ int deny_severity  = LOG_INFO;
 /* local prototypes */
 
 /* usage: prints the usage statement */
-static void
-usage(prog_name)
-  char *prog_name;
+static void usage (char *prog_name)
 {
   fprintf(stderr,
           "usage: %s [-c config_file] [-r] [-s] [-Vvq] [-di]\n", prog_name);
@@ -75,10 +73,7 @@ usage(prog_name)
   exit(64);
 }
 
-static void
-parse_cl_options(argc, argv)
-  int  argc;
-  char *argv[];
+static void parse_cl_options (int argc, char *argv[])
 {
   extern char       *optarg;
   extern int        optind;
@@ -136,8 +131,7 @@ parse_cl_options(argc, argv)
   }
 }
 
-static void
-set_cl_options()
+static void set_cl_options (void)
 {
   if (opts.opt_r)
   {
@@ -166,8 +160,7 @@ set_cl_options()
 
    note: this routine (and the other option routines) should probably
    be in another file. */
-void
-initialize()
+void initialize (void)
 {
   char  *config_file = NULL;
 
@@ -210,10 +203,7 @@ initialize()
 }
 
   
-int
-main(argc, argv)
-  int  argc;
-  char *argv[];
+int main (int argc, char *argv[])
 {
   bzero(orig_cwd, sizeof(orig_cwd));
 
--- a/server/notify.c
+++ b/server/notify.c
@@ -35,9 +35,7 @@
  */
 
 
-int
-notify_directive(str)
-  char *str;
+int notify_directive (char *str)
 {
   char  word[MAX_LINE];
   char  *cp;
--- a/server/referral.c
+++ b/server/referral.c
@@ -71,9 +71,7 @@ static int aa_has_referrals PROTO((auth_area_struct *aa));
 /* roughly check network format, detailed check is done in with_network() 
  * network str has to have "prefix/prefix-length" format 
  */
-static int
-is_net( str )
-  char *str;
+static int is_net (char *str)
 {
   if ( !str || !*str) return FALSE;
 
@@ -86,9 +84,7 @@ is_net( str )
 
 /* domain str has to have "XX.XXX" format */
 /* what about second level domain */
-static int
-is_domain( str )
-  char *str;
+static int is_domain (char *str)
 {
   if (! str || !*str) return FALSE;
 
@@ -106,10 +102,7 @@ is_domain( str )
 
 /* hierarchical_value_domain: This function parses a domain
    hierarchical value */
-static int
-hierarchical_value_domain(value, hvalue)
-  char *value;
-  char *hvalue;
+static int hierarchical_value_domain (char *value, char *hvalue)
 {
   char *p;
 
@@ -153,10 +146,7 @@ hierarchical_value_domain(value, hvalue)
    hierarchical value in prefix/prefix length format.  Note that is
    repeats some of the same logic from the ip_network routines, but
    this is trying to discover a (possibly) embedded instance. */
-static int
-hierarchical_value_network(value, hvalue)
-  char *value;
-  char *hvalue;
+static int hierarchical_value_network (char *value, char *hvalue)
 {
   struct netinfo value_info;
 
@@ -179,10 +169,7 @@ hierarchical_value_network(value, hvalue)
 
 /* within_domain: This function checks if a subdomain is within
    a domain */
-static int
-within_domain(subdomain, domain)
-  char *subdomain;
-  char *domain;
+static int within_domain (char *subdomain, char *domain)
 {
   int    rval = FALSE;
   static regexp *prog = NULL;
@@ -226,10 +213,7 @@ within_domain(subdomain, domain)
 
 /* within_network: This function checks if a subnetwork is
    within a network */
-static int
-within_network(subnetwork, network)
-  char *subnetwork;
-  char *network;
+static int within_network (char *subnetwork, char *network)
 {
   int           rval            = FALSE;
   static regexp *prog           = NULL;
@@ -448,9 +432,7 @@ get_down_referral(hvalue, htype, aa_name, referral_list)
 
 
 /* reduce_domain: This function reduces a domain */
-static int
-reduce_domain(domain)
-  char *domain;
+static int reduce_domain (char *domain)
 {
   int  rval = FALSE;
   char *p;
@@ -473,9 +455,7 @@ reduce_domain(domain)
 }
 
 /* reduce_network: This function reduces a network */
-static int
-reduce_network(network)
-  char *network;
+static int reduce_network (char *network)
 {
   struct netinfo ni;
  
@@ -534,10 +514,7 @@ build_referral_query(query, search_value, aa_name)
   return TRUE;
 }
 
-static void
-print_referral(referral_to, aa_name)
-  char *referral_to;
-  char *aa_name;
+static void print_referral (char *referral_to, char *aa_name)
 {
 
   if (NOT_STR_EXISTS(referral_to))
@@ -750,11 +727,7 @@ refer_query_term(query_term, referral_list)
 
 /* parse_hierarchical_value: This function parses hierarchical value
    from the search value in a query term */
-int
-parse_hierarchical_value(value, hvalue, htype)
-  char *value;
-  char *hvalue;
-  int  *htype;
+int parse_hierarchical_value (char *value, char *hvalue, int *htype)
 {
   int    rval = FALSE;
   static regexp *net_prog   = NULL;
@@ -826,11 +799,7 @@ parse_hierarchical_value(value, hvalue, htype)
 
 /* hierarchical_value_within_aa: This function checks if a
    hierarchical value is within an authority area */
-int
-hierarchical_value_within_aa(hvalue, htype, aa_name)
-  char *hvalue;
-  int  htype;
-  char *aa_name;
+int hierarchical_value_within_aa (char *hvalue, int htype, char *aa_name)
 {
   if (!hvalue  || !*hvalue ||
       !aa_name || !*aa_name)
--- a/server/reg_utils.c
+++ b/server/reg_utils.c
@@ -143,9 +143,7 @@ action_to_string(action)
 }
            
 /* given the authority area name, generate a random ID string. */
-char *
-generate_id(auth_area_name)
-  char *auth_area_name;
+char *generate_id (char *auth_area_name)
 {
   char      buffer[16];
   char      id_str[MAX_LINE];
@@ -163,8 +161,7 @@ generate_id(auth_area_name)
   return(xstrdup(id_str));
 }
 
-char *
-generate_updated()
+char *generate_updated (void)
 {
   return(xstrdup(make_timestamp()));
 }
--- a/server/register_directive.c
+++ b/server/register_directive.c
@@ -27,9 +27,7 @@
 /************* Directive String Parsing/Processing Routines */
   
 /* verify that the action is one of "add", "mod", and "del" */
-static int
-valid_registration_action(action_str)
-  char *action_str;
+static int valid_registration_action (char *action_str)
 {
   register_action_type  action;
 
@@ -43,9 +41,7 @@ valid_registration_action(action_str)
 }
 
 /* verifies that the email address is an email address */
-static int
-valid_registration_email_address(email)
-  char *email;
+static int valid_registration_email_address (char *email)
 {
   static regexp     *prog   = NULL;
   int               status  = FALSE;
@@ -69,12 +65,7 @@ valid_registration_email_address(email)
 /* given the truncated argument list (argv[0] should be the first arg
     *after* the on/off arg, check to see if the remaining arguments
     are valid, and write the header to the spool file */
-static int
-handle_registration_header(reg_action, reg_email, argc, argv)
-  char  *reg_action;
-  char  *reg_email;
-  int   argc;
-  char  **argv;
+static int handle_registration_header (char *reg_action, char *reg_email, int argc, char **argv)
 {
   char  *action     = NULL;
   char  *email      = NULL;
@@ -107,10 +98,7 @@ handle_registration_header(reg_action, reg_email, argc, argv)
   return (TRUE);
 }
 
-static int
-register_on(argc, argv)
-  int   argc;
-  char  **argv;
+static int register_on (int argc, char **argv)
 {
   FILE  *spool_fp;
   char  fname[MAX_FILE];
@@ -200,8 +188,7 @@ register_on(argc, argv)
   return TRUE;
 }
 
-static int
-register_off()
+static int register_off (void)
 {
   /* if we weren't in the correct state, this directive is invalid */
   if (get_rwhois_state() != SPOOL_STATE)
@@ -236,9 +223,7 @@ register_off()
 
 /* ------------------- PUBLIC FUNCTIONS ----------------- */
 
-int
-register_directive(str)
-  char *str;
+int register_directive (char *str)
 {
   int   argc;
   char  **argv;
--- a/server/rwhois_directive.c
+++ b/server/rwhois_directive.c
@@ -32,9 +32,7 @@ typedef struct _client_cap_struct
 /* rwhois_parse_args:  this function parses the input argument 
    string and stores the arguments in rwhois_arg. */
 
-static client_cap_struct *
-rwhois_parse_args(str)
-  char *str;
+static client_cap_struct *rwhois_parse_args (char *str)
 {
   int               argc;
   char              **argv;
@@ -80,9 +78,7 @@ rwhois_parse_args(str)
   return(cap);
 }  /* end of rwhois_parse_args. */
 
-static void
-destroy_client_cap_struct(cap)
-  client_cap_struct *cap;
+static void destroy_client_cap_struct (client_cap_struct *cap)
 {
   if (!cap) return;
 
@@ -100,8 +96,7 @@ destroy_client_cap_struct(cap)
      -soa directive.  */
 
 
-int rwhois_directive(str)
-  char *str;
+int rwhois_directive (char *str)
 {
   client_cap_struct *cap;
 
--- a/server/schema_directive.c
+++ b/server/schema_directive.c
@@ -34,9 +34,7 @@ typedef struct schema_arg_struct
 
 /* ------------------- Local Functions -------------------- */
 
-static int
-destroy_schema_arg_struct(ss)
-  schema_arg_struct *ss;
+static int destroy_schema_arg_struct (schema_arg_struct *ss)
 {
   if (!ss) return TRUE;
   
@@ -49,9 +47,7 @@ destroy_schema_arg_struct(ss)
 
 /* schema_parse_args:  This function parses that are given in the -schema
    call.  It returns a schema_arg_struct on success. */
-static schema_arg_struct * 
-schema_parse_args(str)
-  char *str;
+static schema_arg_struct *schema_parse_args (char *str)
 {
   schema_arg_struct *ss;
   auth_area_struct  *auth_area;
@@ -239,8 +235,7 @@ schema_display_classes(class_list)
 
 /* schema_directive:  This function process the call to -schema
      directive.*/
-int schema_directive(str)
-  char * str;
+int schema_directive (char *str)
 {
   schema_arg_struct *in = NULL;
 
--- a/server/security.c
+++ b/server/security.c
@@ -26,8 +26,7 @@ from W.Z. Venema's chrootuid code.
 returns TRUE if ok
         FALSE otherwise
 ****************************************************************************/
-int
-setup_security()
+int setup_security (void)
 {
   struct passwd *pwd    = NULL;
   char          *userid = NULL;
@@ -101,9 +100,7 @@ setup_security()
    returns TRUE if can
            FALSE if not
 ****************************************************************************/
-int
-authorized_directive(directive)
-  char *directive;
+int authorized_directive (char *directive)
 {
 #ifdef USE_TCP_WRAPPERS
   char                    *hosts_allow;
@@ -195,8 +192,7 @@ authorized_directive(directive)
 #endif /* USE_TCP_WRAPPERS */
 }
 
-int
-authorized_client()
+int authorized_client (void)
 {
   return( authorized_directive( "rwhoisd" ) );
 }
--- a/server/security_directive.c
+++ b/server/security_directive.c
@@ -72,9 +72,7 @@ free_auth_struct(auth)
   free(auth);
 }
 
-static security_arg_struct *
-security_parse_args(str)
-  char *str;
+static security_arg_struct *security_parse_args (char *str)
 {
   int                 i;
   int                 argc;
@@ -240,8 +238,7 @@ security_store_auth(prs)
 }
 
 
-static void
-print_auth_struct()
+static void print_auth_struct (void)
 {
   if (request)
   {
@@ -265,9 +262,7 @@ print_auth_struct()
 }
 
 
-static void 
-free_security_args_struct(prs)
-    security_arg_struct *prs;
+static void free_security_args_struct (security_arg_struct *prs)
 {
   if (prs->mode)
   {
@@ -292,9 +287,7 @@ free_security_args_struct(prs)
 
 /*------------------- PUBLIC FUNCTIONS -------------------------*/
 
-int
-security_directive(str)
-  char  *str;
+int security_directive (char *str)
 {
   security_arg_struct *prs;
 
--- a/server/session.c
+++ b/server/session.c
@@ -35,9 +35,7 @@ static int run_query PROTO((char *str));
 /* ------------------- LOCAL FUNCTIONS -------------------- */
 
 
-static int
-processline(str)
-  char *str;
+static int processline (char *str)
 {
   int                status = FALSE;
   rwhois_state_type  state  = get_rwhois_state();
@@ -85,9 +83,7 @@ processline(str)
 }
 
 
-static int
-run_query(str)
-  char *str;
+static int run_query (char *str)
 {
   query_struct      *query;
   dl_list_type      record_list;
@@ -185,9 +181,7 @@ run_query(str)
 
 
 /* run_session: runs a rwhois client session */
-void
-run_session(real_flag)
-  int real_flag;
+void run_session (int real_flag)
 {
   char target[MAX_LINE];
   int  not_finished    = TRUE;
@@ -240,8 +234,7 @@ run_session(real_flag)
 
 
 /* print_welcome_header: prints the standard rwhois banner greeting */
-void
-print_welcome_header()
+void print_welcome_header (void)
 {
   char             *hostname;
   dl_list_type     *dir_list;
--- a/server/soa.c
+++ b/server/soa.c
@@ -161,8 +161,7 @@ update_soa_auth_area_list(auth_area_list)
 
 /* soa_directive:  This is the main directive function which processes the
      -soa directive.  */
-int soa_directive(str)
-    char *str;
+int soa_directive (char *str)
 {
   dl_list_type     *aa_list      = NULL;
 
--- a/server/sresponse.c
+++ b/server/sresponse.c
@@ -56,11 +56,7 @@ processline(line, delimiter, response)
 
 /* connect_server: This function sets up a TCP connection to
    an RWhois server running at addr:port */
-void
-connect_server(addr, port, sockfd)
-  char *addr;
-  int  port;
-  int  *sockfd;
+void connect_server (char *addr, int port, int *sockfd)
 {
 #ifdef HAVE_IPV6
   struct addrinfo hints, *gai_result, *server_aip;
@@ -147,10 +143,7 @@ connect_server(addr, port, sockfd)
 
 /* send_directive: This function sends directive to
    an RWhois server */
-void
-send_directive(sockfd, directive)
-  int  sockfd;
-  char *directive;
+void send_directive (int sockfd, char *directive)
 {
   /* Write directive */
   if (write(sockfd, directive, strlen(directive)) < 0)
@@ -194,9 +187,7 @@ recv_response(fp, delimiter, response)
 
 
 /* destroy_response_data: This function frees a character string */
-int
-destroy_response_data(str)
-  char *str;
+int destroy_response_data (char *str)
 {
   if (!str)
   {
--- a/server/sschema.c
+++ b/server/sschema.c
@@ -290,10 +290,7 @@ create_attr_file_line(fp, tag, value)
 
 
 /* base_attr: This function checks for a base schema attribute */
-static int
-base_attr(tag, value)
-  char *tag;
-  char *value;
+static int base_attr (char *tag, char *value)
 {
   if (STR_EQ(tag, "attribute"))
   {
--- a/server/sslave.c
+++ b/server/sslave.c
@@ -19,8 +19,7 @@
 /* init_slave_auth_areas: This function initially creates
    SOA file, schema file, attribute definitions directory,
    and data directory for each slave authority area */
-int
-init_slave_auth_areas()
+int init_slave_auth_areas (void)
 {
   dl_list_type       *aa_list;
   dl_list_type       slave_aa_list;
@@ -288,8 +287,7 @@ init_slave_auth_areas()
 /* update_slave_auth_areas: This function updates data for a
    slave authority area if serial number has been incremented
    at the master server */
-int
-update_slave_auth_areas()
+int update_slave_auth_areas (void)
 {
   dl_list_type       *aa_list;
   dl_list_type       slave_aa_list;
--- a/server/sstate.c
+++ b/server/sstate.c
@@ -45,18 +45,14 @@ destroy_slave_state_data(slave_state)
 
 
 /* sigalrm_handler: This function handles SIGALRM signal */
-static void
-sigalrm_handler(signo)
-  int signo;
+static void sigalrm_handler (int signo)
 {
   return;
 }
 
 
 /* sigchld_handler: This function handles SIGCHLD signal */
-static void
-sigchld_handler(signo)
-  int signo;
+static void sigchld_handler (int signo)
 {
   childpid = wait(&childstatus);
 
@@ -68,12 +64,7 @@ sigchld_handler(signo)
 
 
 /* set_slave_state: This function sets slave authority area state */
-int
-set_slave_state(name, pid, action, status)
-  char *name;
-  int  pid;
-  int  action;
-  int  status;
+int set_slave_state (char *name, int pid, int action, int status)
 {
   slave_state_struct *slave_state;
   int                not_done;
@@ -156,11 +147,7 @@ init_slave_state_list(slave_aa_list)
 
 /* wait_for_child_processes: This function waits for child processes for
    slave authority areas */
-void
-wait_for_child_processes(count, seconds, action)
-  int count;
-  int seconds;
-  int action;
+void wait_for_child_processes (int count, int seconds, int action)
 {
   slave_state_struct *slave_state;
   int                not_done;
--- a/server/state.c
+++ b/server/state.c
@@ -31,8 +31,7 @@ typedef struct _rwhois_state_struct
 
 static rwhois_state_struct  state_info;
 
-int 
-get_rwhois_secure_mode()
+int get_rwhois_secure_mode (void)
 {
   return(state_info.secure_mode);
 }
@@ -58,15 +57,12 @@ set_rwhois_state(s)
   return TRUE;
 }
 
-char *
-get_rwhois_spool_file_name()
+char *get_rwhois_spool_file_name (void)
 {
   return(state_info.spool_file_name);
 }
 
-int
-set_rwhois_spool_file_name(file)
-  char *file;
+int set_rwhois_spool_file_name (char *file)
 {
   strncpy(state_info.spool_file_name, file,
           sizeof(state_info.spool_file_name));
@@ -99,8 +95,7 @@ open_spool_file(char *mode)
   return(fp);
 }
 
-void
-close_spool_file()
+void close_spool_file (void)
 {
   if (state_info.spool_fp)
   {
@@ -109,9 +104,7 @@ close_spool_file()
   }
 }
 
-int
-move_spool_file(new_file_name)
-  char *new_file_name;
+int move_spool_file (char *new_file_name)
 {
   if (! *(state_info.spool_file_name))
   {
@@ -146,8 +139,7 @@ move_spool_file(new_file_name)
   return TRUE;
 }
 
-int
-remove_spool_file()
+int remove_spool_file (void)
 {
   if (! *(state_info.spool_file_name))
   {
@@ -171,29 +163,23 @@ remove_spool_file()
   return TRUE;
 }
 
-char *
-get_client_vendor_id()
+char *get_client_vendor_id (void)
 {
   return(state_info.client_vendor_id);
 }
 
-void
-set_client_vendor_id(id)
-  char *id;
+void set_client_vendor_id (char *id)
 {
   strncpy(state_info.client_vendor_id, id,
           sizeof(state_info.client_vendor_id));
 }
 
-char *
-get_register_email()
+char *get_register_email (void)
 {
   return(state_info.register_email);
 }
 
-void
-set_register_email(email)
-  char *email;
+void set_register_email (char *email)
 {
   strncpy(state_info.register_email, email, sizeof(state_info.register_email));
 }
--- a/server/status.c
+++ b/server/status.c
@@ -23,8 +23,7 @@
 /****************************************************************************
   return number of records
 ****************************************************************************/
-static long
-get_rec_num()
+static long get_rec_num (void)
 {
   dl_list_type     *aa_list;
   auth_area_struct *auth_area;
@@ -62,9 +61,7 @@ get_rec_num()
  *      %status Cached:  <cacheed number>
  *      %status Display:  <mode>: <type>
  */     
-int
-status_directive ( str )
-  char  *str;
+int status_directive (char *str)
 {
    
   /* -status don't have any argument */
--- a/server/sxfer.c
+++ b/server/sxfer.c
@@ -171,9 +171,7 @@ create_data_file_line(fp, tag, value)
 
 /* destroy_xfer_class_data: This function frees a
    xfer_class_struct structure */
-static int
-destroy_xfer_class_data(xclass)
-  xfer_class_struct *xclass;
+static int destroy_xfer_class_data (xfer_class_struct *xclass)
 {
   if (!xclass)
   {
@@ -189,9 +187,7 @@ destroy_xfer_class_data(xclass)
 
 /* destroy_xfer_arg_data: This function frees a xfer_arg_struct
    structure */
-static int
-destroy_xfer_arg_data(xarg)
-  xfer_arg_struct *xarg;
+static int destroy_xfer_arg_data (xfer_arg_struct *xarg)
 {
   if (!xarg)
   {
@@ -212,11 +208,7 @@ destroy_xfer_arg_data(xarg)
 
 
 /* xfer_split_av: This function parses an attribute=value string */
-static void 
-xfer_split_av(str, attr, value)
-  char *str;
-  char *attr;
-  char *value;
+static void xfer_split_av (char *str, char *attr, char *value)
 {
   char *eq = NULL;
 
--- a/server/xfer.c
+++ b/server/xfer.c
@@ -68,9 +68,7 @@ destroy_xfer_class_data(xclass)
   return TRUE;
 }
 
-static int
-destroy_xfer_arg_data(xarg)
-  xfer_arg_struct *xarg;
+static int destroy_xfer_arg_data (xfer_arg_struct *xarg)
 {
   if (!xarg) return TRUE;
 
@@ -89,11 +87,7 @@ destroy_xfer_arg_data(xarg)
 /* xfer_split_av: splits a string into its attribute and 
 value components. */
 
-static void 
-xfer_split_av(in_str, attr, value)
-  char *in_str;
-  char *attr;
-  char *value;
+static void xfer_split_av (char *in_str, char *attr, char *value)
 {
   char  *eq = NULL;
 
@@ -122,9 +116,7 @@ xfer_split_av(in_str, attr, value)
      directive.  It checks for all required arguments and stores the
      optional arguments in the appropriate data structure as defined
      in xfer_arg_struct.*/
-static xfer_arg_struct * 
-xfer_parse_args(str)
-  char *str;
+static xfer_arg_struct *xfer_parse_args (char *str)
 {
   xfer_arg_struct   *xs;
   xfer_class_struct *cur_xclass = NULL;
@@ -484,9 +476,7 @@ xfer_all_classes(aa, serial_no)
   return(found_data);
 }  /* end of xfer_all_classes */
 
-static int
-xfer_some_classes(xs)
-  xfer_arg_struct *xs;
+static int xfer_some_classes (xfer_arg_struct *xs)
 {
   xfer_class_struct *curr_class;
   int               not_done;
@@ -512,9 +502,7 @@ xfer_some_classes(xs)
 /* xfer_directive:  This function xfers data depending upon the 
    parameters passed in str.  Returns TRUE on success. */
 
-int 
-xfer_directive( str)
-  char *str;
+int xfer_directive (char *str)
 {
   xfer_arg_struct   *xs;
   int               found_data;
--- a/tools/rwhois_indexer/rwhois_indexer.c
+++ b/tools/rwhois_indexer/rwhois_indexer.c
@@ -31,9 +31,7 @@
 /* local prototypes */
 
 /* usage: prints the usage statement */
-static int
-usage(prog_name)
-  char *prog_name;
+static int usage (char *prog_name)
 {
   fprintf(stderr, "usage:\n");
   fprintf(stderr, " file list mode:\n");
@@ -112,16 +110,7 @@ delete_index_files(class, auth_area)
   return TRUE;
 }
 
-static int
-run_file_index(class_name, auth_area_name, validate_flag, init_flag,
-               base_dir, argc, argv)
-  char  *class_name;
-  char  *auth_area_name;
-  int   validate_flag;
-  int   init_flag;
-  char  *base_dir;
-  int   argc;
-  char  *argv[];
+static int run_file_index (char *class_name, char *auth_area_name, int validate_flag, int init_flag, char *base_dir, int argc, char *argv[])
 {
   class_struct     *class               = NULL;
   auth_area_struct *auth_area           = NULL;
@@ -231,13 +220,7 @@ run_suffix_index_auth_area(auth_area, class_name, validate_flag, init_flag,
                                 suffix));
 }
 
-static int
-run_suffix_index(class_name, auth_area_name, validate_flag, init_flag, suffix)
-  char *class_name;
-  char *auth_area_name;
-  int  validate_flag;
-  int  init_flag;
-  char *suffix;
+static int run_suffix_index (char *class_name, char *auth_area_name, int validate_flag, int init_flag, char *suffix)
 {
   auth_area_struct *auth_area = NULL;
   class_ref_struct *class_ref = NULL;
@@ -294,10 +277,7 @@ run_suffix_index(class_name, auth_area_name, validate_flag, init_flag, suffix)
   return TRUE;
 }
 
-int
-main(argc, argv)
-  int  argc;
-  char *argv[];
+int main (int argc, char *argv[])
 {
   extern char   *optarg;
 #ifndef optind
--- a/tools/rwhois_repack/rwhois_repack.c
+++ b/tools/rwhois_repack/rwhois_repack.c
@@ -34,9 +34,7 @@
 /* --------------- local prototypes ----------------------- */
 
 /* usage: prints the usage statement */
-static int
-usage(prog_name)
-  char *prog_name;
+static int usage (char *prog_name)
 {
   fprintf(stderr, "Usage:\n");
   fprintf(stderr,
--- a/tools/tcpd_wrapper/clean_exit.c
+++ b/tools/tcpd_wrapper/clean_exit.c
@@ -20,8 +20,7 @@ extern void exit();
 
 /* clean_exit - clean up and exit */
 
-void    clean_exit(request)
-struct request_info *request;
+void clean_exit (struct request_info *request)
 {
 
     /*
--- a/tools/tcpd_wrapper/diag.c
+++ b/tools/tcpd_wrapper/diag.c
@@ -29,11 +29,7 @@ jmp_buf tcpd_buf;
 
 /* tcpd_diag - centralize error reporter */
 
-static void tcpd_diag(severity, tag, format, ap)
-int     severity;
-char   *tag;
-char   *format;
-va_list ap;
+static void tcpd_diag (int severity, char *tag, char *format, va_list ap)
 {
     char    fmt[BUFSIZ];
 
--- a/tools/tcpd_wrapper/environ.c
+++ b/tools/tcpd_wrapper/environ.c
@@ -37,8 +37,7 @@ static int allocated = 0;		/* environ is, or is not, allocated */
 
 /* namelength - determine length of name in "name=whatever" */
 
-static int namelength(name)
-char   *name;
+static int namelength (char *name)
 {
     char   *equal;
 
@@ -48,9 +47,7 @@ char   *name;
 
 /* findenv - given name, locate name=value */
 
-static char **findenv(name, len)
-char   *name;
-int     len;
+static char **findenv (char *name, int len)
 {
     char  **envp;
 
@@ -62,8 +59,7 @@ int     len;
 
 /* getenv - given name, locate value */
 
-char   *getenv(name)
-char   *name;
+char *getenv (char *name)
 {
     int     len = namelength(name);
     char  **envp = findenv(name, len);
@@ -73,8 +69,7 @@ char   *name;
 
 /* putenv - update or append environment (name,value) pair */
 
-int     putenv(nameval)
-char   *nameval;
+int putenv (char *nameval)
 {
     char   *equal = strchr(nameval, '=');
     char   *value = (equal ? equal : "");
@@ -84,8 +79,7 @@ char   *nameval;
 
 /* unsetenv - remove variable from environment */
 
-void    unsetenv(name)
-char   *name;
+void unsetenv (char *name)
 {
     char  **envp;
 
@@ -96,10 +90,7 @@ char   *name;
 
 /* setenv - update or append environment (name,value) pair */
 
-int     setenv(name, value, clobber)
-char   *name;
-char   *value;
-int     clobber;
+int setenv (char *name, char *value, int clobber)
 {
     char   *destination;
     char  **envp;
@@ -133,9 +124,7 @@ int     clobber;
 
 /* cmalloc - malloc and copy block of memory */
 
-static char *cmalloc(new_len, old, old_len)
-char   *old;
-int     old_len;
+static char *cmalloc (int new_len, char *old, int old_len)
 {
     char   *new = malloc(new_len);
 
@@ -146,8 +135,7 @@ int     old_len;
 
 /* addenv - append environment entry */
 
-static int addenv(nameval)
-char   *nameval;
+static int addenv (char *nameval)
 {
     char  **envp;
     int     n_used;			/* number of environment entries */
@@ -182,7 +170,7 @@ char   *nameval;
 
 /* printenv - display environment */
 
-static void printenv()
+static void printenv (void)
 {
     char  **envp;
 
@@ -190,9 +178,7 @@ static void printenv()
 	printf("%s\n", *envp);
 }
 
-int     main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     char   *cp;
     int     changed = 0;
--- a/tools/tcpd_wrapper/eval.c
+++ b/tools/tcpd_wrapper/eval.c
@@ -42,8 +42,7 @@ char    paranoid[] = STRING_PARANOID;
 
 /* eval_user - look up user name */
 
-char   *eval_user(request)
-struct request_info *request;
+char *eval_user (struct request_info *request)
 {
     if (request->user[0] == 0) {
 	strcpy(request->user, unknown);
@@ -55,8 +54,7 @@ struct request_info *request;
 
 /* eval_hostaddr - look up printable address */
 
-char   *eval_hostaddr(host)
-struct host_info *host;
+char *eval_hostaddr (struct host_info *host)
 {
     if (host->addr[0] == 0) {
 	strcpy(host->addr, unknown);
@@ -68,8 +66,7 @@ struct host_info *host;
 
 /* eval_hostname - look up host name */
 
-char   *eval_hostname(host)
-struct host_info *host;
+char *eval_hostname (struct host_info *host)
 {
     if (host->name[0] == 0) {
 	strcpy(host->name, unknown);
@@ -81,8 +78,7 @@ struct host_info *host;
 
 /* eval_hostinfo - return string with host name (preferred) or address */
 
-char   *eval_hostinfo(host)
-struct host_info *host;
+char *eval_hostinfo (struct host_info *host)
 {
     char   *hostname;
 
@@ -100,8 +96,7 @@ struct host_info *host;
 
 /* eval_client - return string with as much about the client as we know */
 
-char   *eval_client(request)
-struct request_info *request;
+char *eval_client (struct request_info *request)
 {
     static char both[2 * STRING_LENGTH];
     char   *hostinfo = eval_hostinfo(request->client);
@@ -120,8 +115,7 @@ struct request_info *request;
 
 /* eval_server - return string with as much about the server as we know */
 
-char   *eval_server(request)
-struct request_info *request;
+char *eval_server (struct request_info *request)
 {
     static char both[2 * STRING_LENGTH];
     char   *host = eval_hostinfo(request->server);
--- a/tools/tcpd_wrapper/fakelog.c
+++ b/tools/tcpd_wrapper/fakelog.c
@@ -1,36 +1,11 @@
- /*
-  * This module intercepts syslog() library calls and redirects their output
-  * to the standard output stream. For interactive testing.
-  * 
-  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
-  */
-
-#ifndef lint
-static char sccsid[] = "@(#) fakelog.c 1.3 94/12/28 17:42:21";
-#endif
-
-#include <stdio.h>
-
-#include "mystdarg.h"
-
-/* openlog - dummy */
-
-/* ARGSUSED */
-
-openlog(name, logopt, facility)
-char   *name;
-int     logopt;
-int     facility;
+__END_DECLS openlog (char *name, int logopt, int facility)
 {
     /* void */
 }
 
 /* vsyslog - format one record */
 
-vsyslog(severity, fmt, ap)
-int     severity;
-char   *fmt;
-va_list ap;
+int vsyslog (int severity, char *fmt, va_list ap)
 {
     char    buf[BUFSIZ];
 
@@ -56,7 +31,7 @@ VARARGS(syslog, int, severity)
 
 /* closelog - dummy */
 
-closelog()
+int closelog (void)
 {
     /* void */
 }
--- a/tools/tcpd_wrapper/fromhost.c
+++ b/tools/tcpd_wrapper/fromhost.c
@@ -1,12 +1,12 @@
  /*
   * On socket-only systems, fromhost() is nothing but an alias for the
   * socket-specific sock_host() function.
-  * 
+  *
   * On systems with sockets and TLI, fromhost() determines the type of API
   * (sockets, TLI), then invokes the appropriate API-specific routines.
-  * 
+  *
   * Diagnostics are reported through syslog(3).
-  * 
+  *
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
@@ -28,15 +28,14 @@ static char sccsid[] = "@(#) fromhost.c 1.17 94/12/28 17:42:23";
 
 /* fromhost - find out what network API we should use */
 
-void    fromhost(request)
-struct request_info *request;
+void    fromhost(struct request_info *request)
 {
 
     /*
      * On systems with streams support the IP network protocol family may be
      * accessible via more than one programming interface: Berkeley sockets
      * and the Transport Level Interface (TLI).
-     * 
+     *
      * Thus, we must first find out what programming interface to use: sockets
      * or TLI. On some systems, sockets are not part of the streams system,
      * so if request->fd is not a stream we simply assume sockets.
--- a/tools/tcpd_wrapper/hosts_access.c
+++ b/tools/tcpd_wrapper/hosts_access.c
@@ -96,8 +96,7 @@ static void ipv6_mask();
 
 /* hosts_access - host access control facility */
 
-int     hosts_access(request)
-struct request_info *request;
+int hosts_access (struct request_info *request)
 {
     int     verdict;
 
@@ -130,9 +129,7 @@ struct request_info *request;
 
 /* table_match - match table entries with (daemon, client) pair */
 
-static int table_match(table, request)
-char   *table;
-struct request_info *request;
+static int table_match (char *table, struct request_info *request)
 {
     FILE   *fp;
     char    sv_list[BUFLEN];		/* becomes list of daemons */
@@ -189,10 +186,7 @@ struct request_info *request;
 
 /* list_match - match a request against a list of patterns with exceptions */
 
-static int list_match(list, request, match_fn)
-char   *list;
-struct request_info *request;
-int   (*match_fn) ();
+static int list_match (char *list, struct request_info *request, int (*match_fn)(char *tok, struct request_info *req))
 {
     char   *tok;
 
@@ -217,9 +211,7 @@ int   (*match_fn) ();
 
 /* server_match - match server information */
 
-static int server_match(tok, request)
-char   *tok;
-struct request_info *request;
+static int server_match (char *tok, struct request_info *request)
 {
     char   *host;
 
@@ -233,9 +225,7 @@ struct request_info *request;
 
 /* client_match - match client information */
 
-static int client_match(tok, request)
-char   *tok;
-struct request_info *request;
+static int client_match (char *tok, struct request_info *request)
 {
     char   *host;
 
@@ -249,9 +239,7 @@ struct request_info *request;
 
 /* host_match - match host name and/or address against pattern */
 
-static int host_match(tok, host)
-char   *tok;
-struct host_info *host;
+static int host_match (char *tok, struct host_info *host)
 {
     char   *mask;
 
@@ -352,9 +340,7 @@ struct host_info *host;
 
 /* string_match - match string against pattern */
 
-static int string_match(tok, string)
-char   *tok;
-char   *string;
+static int string_match (char *tok, char *string)
 {
     int     n;
 
@@ -374,10 +360,7 @@ char   *string;
 
 /* masked_match - match address against netnumber/netmask */
 
-static int masked_match(net_tok, mask_tok, string)
-char   *net_tok;
-char   *mask_tok;
-char   *string;
+static int masked_match (char *net_tok, char *mask_tok, char *string)
 {
     unsigned long net;
     unsigned long mask;
@@ -405,9 +388,7 @@ char   *string;
  * This function can be made generic by specifying an address length as
  * extra parameter. (So Wietse can implement 1.2.3.4/16)
  */
-static void ipv6_mask(in6p, maskbits)
-struct in6_addr *in6p;
-int maskbits;
+static void ipv6_mask (struct in6_addr *in6p, int maskbits)
 {
     uchar_t *p = (uchar_t*) in6p;
 
--- a/tools/tcpd_wrapper/hosts_ctl.c
+++ b/tools/tcpd_wrapper/hosts_ctl.c
@@ -4,10 +4,10 @@
   * access control checker. The host name and user name arguments should be
   * empty strings, STRING_UNKNOWN or real data. If a match is found, the
   * optional shell command is executed.
-  * 
+  *
   * Restriction: this interface does not pass enough information to support
   * selective remote username lookups or selective hostname double checks.
-  * 
+  *
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
@@ -21,11 +21,11 @@ static char sccsid[] = "@(#) hosts_ctl.c 1.4 94/12/28 17:42:27";
 
 /* hosts_ctl - limited interface to the hosts_access() routine */
 
-int     hosts_ctl(daemon, name, addr, user)
-char   *daemon;
-char   *name;
-char   *addr;
-char   *user;
+int     hosts_ctl(
+char   *daemon,
+char   *name,
+char   *addr,
+char   *user)
 {
     struct request_info request;
 
--- a/tools/tcpd_wrapper/hosts_info.c
+++ b/tools/tcpd_wrapper/hosts_info.c
@@ -1,23 +1,4 @@
- /*
-  * hosts_info() returns a string with as much information about the origin
-  * of a connection as we have: the user name, if known, and the host name,
-  * or the host address if the name is not available.
-  * 
-  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
-  */
-
-#ifndef lint
-static char sccsid[] = "@(#) hosts_info.c 1.1 92/06/11 22:21:44";
-#endif
-
-#include <stdio.h>
-
-#include "log_tcp.h"
-
-/* hosts_info - return string with as much about the client as we know */
-
-char   *hosts_info(client)
-struct from_host *client;
+__END_DECLS char *hosts_info (struct from_host *client)
 {
     static char buf[BUFSIZ];		/* XXX */
 
--- a/tools/tcpd_wrapper/inetcf.c
+++ b/tools/tcpd_wrapper/inetcf.c
@@ -54,8 +54,7 @@ static char whitespace[] = " \t\r\n";
 
 /* inet_conf - read in and examine inetd.conf (or tlid.conf) entries */
 
-char   *inet_cfg(conf)
-char   *conf;
+char *inet_cfg (char *conf)
 {
     char    buf[BUFSIZ];
     FILE   *fp;
@@ -159,11 +158,7 @@ char   *conf;
 
 /* inet_chk - examine one inetd.conf (tlid.conf?) entry */
 
-static void inet_chk(protocol, path, arg0, arg1)
-char   *protocol;
-char   *path;
-char   *arg0;
-char   *arg1;
+static void inet_chk (char *protocol, char *path, char *arg0, char *arg1)
 {
     char    daemon[BUFSIZ];
     struct stat st;
@@ -270,9 +265,7 @@ char   *arg1;
 
 /* inet_set - remember service status */
 
-void    inet_set(name, type)
-char   *name;
-int     type;
+void inet_set (char *name, int type)
 {
     struct inet_ent *ip =
     (struct inet_ent *) malloc(sizeof(struct inet_ent) + strlen(name));
@@ -289,8 +282,7 @@ int     type;
 
 /* inet_get - look up service status */
 
-int     inet_get(name)
-char   *name;
+int inet_get (char *name)
 {
     struct inet_ent *ip;
 
@@ -306,8 +298,7 @@ char   *name;
 
 /* base_name - compute last pathname component */
 
-static char *base_name(path)
-char   *path;
+static char *base_name (char *path)
 {
     char   *cp;
 
--- a/tools/tcpd_wrapper/misc.c
+++ b/tools/tcpd_wrapper/misc.c
@@ -27,10 +27,7 @@ extern char *fgets();
 
 /* xgets - fgets() with backslash-newline stripping */
 
-char   *xgets(ptr, len, fp)
-char   *ptr;
-int     len;
-FILE   *fp;
+char *xgets (char *ptr, int len, FILE *fp)
 {
     int     got;
     char   *start = ptr;
@@ -54,9 +51,7 @@ FILE   *fp;
 
 /* split_at - break string at delimiter or return NULL */
 
-char   *split_at(string, delimiter)
-char   *string;
-int     delimiter;
+char *split_at (char *string, int delimiter)
 {
     char   *cp;
 
@@ -67,8 +62,7 @@ int     delimiter;
 
 /* dot_quad_addr - convert dotted quad to internal form */
 
-unsigned long dot_quad_addr(str)
-char   *str;
+unsigned long dot_quad_addr (char *str)
 {
     int     in_run = 0;
     int     runs = 0;
@@ -90,11 +84,7 @@ char   *str;
 
 /* numeric_addr - convert textual IP address to binary form */
 
-int numeric_addr(str, addr, af, len)
-char *str;
-union gen_addr *addr;
-int *af;
-int *len;
+int numeric_addr (char *str, union gen_addr *addr, int *af, int *len)
 {
     union gen_addr t;
 
@@ -123,9 +113,7 @@ int *len;
 
 /* tcpd_gethostbyname - an IP family neutral gethostbyname */
 
-struct hostent *tcpd_gethostbyname(host, af)
-char *host;
-int af;
+struct hostent *tcpd_gethostbyname (char *host, int af)
 {
 #ifdef HAVE_IPV6
     struct hostent *hp;
@@ -164,8 +152,7 @@ int af;
  *
  * We also allow a '/prefix' specifier.
  */
-char *skip_ipv6_addrs(str)
-char *str;
+char *skip_ipv6_addrs (char *str)
 {
     char *obr, *cbr, *colon;
     char *p = str;
--- a/tools/tcpd_wrapper/miscd.c
+++ b/tools/tcpd_wrapper/miscd.c
@@ -43,9 +43,7 @@ static char sccsid[] = "@(#) miscd.c 1.10 96/02/11 17:01:30";
 int     allow_severity = SEVERITY;	/* run-time adjustable */
 int     deny_severity = LOG_WARNING;	/* ditto */
 
-main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     struct request_info request;
     char    path[MAXPATHNAMELEN];
--- a/tools/tcpd_wrapper/myvsyslog.c
+++ b/tools/tcpd_wrapper/myvsyslog.c
@@ -1,9 +1,9 @@
- /*
+/*
   * vsyslog() for sites without. In order to enable this code, build with
   * -Dvsyslog=myvsyslog. We use a different name so that no accidents will
   * happen when vsyslog() exists. On systems with vsyslog(), syslog() is
   * typically implemented in terms of vsyslog().
-  * 
+  *
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
@@ -18,10 +18,10 @@ static char sccsid[] = "@(#) myvsyslog.c 1.1 94/12/28 17:42:33";
 #include "tcpd.h"
 #include "mystdarg.h"
 
-myvsyslog(severity, format, ap)
-int     severity;
-char   *format;
-va_list ap;
+myvsyslog(
+int     severity,
+char   *format,
+va_list ap)
 {
     char    fbuf[BUFSIZ];
     char    obuf[3 * STRING_LENGTH];
--- a/tools/tcpd_wrapper/options.c
+++ b/tools/tcpd_wrapper/options.c
@@ -127,9 +127,7 @@ static struct option option_table[] = {
 
 /* process_options - process access control options */
 
-void    process_options(options, request)
-char   *options;
-struct request_info *request;
+void process_options (char *options, struct request_info *request)
 {
     char   *key;
     char   *value;
@@ -193,9 +191,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void allow_option(value, request)
-char   *value;
-struct request_info *request;
+static void allow_option (char *value, struct request_info *request)
 {
     longjmp(tcpd_buf, AC_PERMIT);
 }
@@ -204,18 +200,14 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void deny_option(value, request)
-char   *value;
-struct request_info *request;
+static void deny_option (char *value, struct request_info *request)
 {
     longjmp(tcpd_buf, AC_DENY);
 }
 
 /* banners_option - expand %<char>, terminate each line with CRLF */
 
-static void banners_option(value, request)
-char   *value;
-struct request_info *request;
+static void banners_option (char *value, struct request_info *request)
 {
     char    path[MAXPATHNAMELEN];
     char    ibuf[BUFSIZ];
@@ -245,9 +237,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void group_option(value, request)
-char   *value;
-struct request_info *request;
+static void group_option (char *value, struct request_info *request)
 {
     struct group *grp;
     struct group *getgrnam();
@@ -264,9 +254,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void user_option(value, request)
-char   *value;
-struct request_info *request;
+static void user_option (char *value, struct request_info *request)
 {
     struct passwd *pwd;
     struct passwd *getpwnam();
@@ -286,9 +274,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void umask_option(value, request)
-char   *value;
-struct request_info *request;
+static void umask_option (char *value, struct request_info *request)
 {
     unsigned mask;
     char    junk;
@@ -302,9 +288,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void spawn_option(value, request)
-char   *value;
-struct request_info *request;
+static void spawn_option (char *value, struct request_info *request)
 {
     if (dry_run == 0)
 	shell_cmd(value);
@@ -314,9 +298,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void linger_option(value, request)
-char   *value;
-struct request_info *request;
+static void linger_option (char *value, struct request_info *request)
 {
     struct linger linger;
     char    junk;
@@ -336,9 +318,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void keepalive_option(value, request)
-char   *value;
-struct request_info *request;
+static void keepalive_option (char *value, struct request_info *request)
 {
     static int on = 1;
 
@@ -351,9 +331,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void nice_option(value, request)
-char   *value;
-struct request_info *request;
+static void nice_option (char *value, struct request_info *request)
 {
     int     niceval = 10;
     char    junk;
@@ -366,9 +344,7 @@ struct request_info *request;
 
 /* twist_option - replace process by shell command */
 
-static void twist_option(value, request)
-char   *value;
-struct request_info *request;
+static void twist_option (char *value, struct request_info *request)
 {
     char   *error;
 
@@ -404,9 +380,7 @@ struct request_info *request;
 
 /* rfc931_option - look up remote user name */
 
-static void rfc931_option(value, request)
-char   *value;
-struct request_info *request;
+static void rfc931_option (char *value, struct request_info *request)
 {
     int     timeout;
     char    junk;
@@ -423,9 +397,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-static void setenv_option(value, request)
-char   *value;
-struct request_info *request;
+static void setenv_option (char *value, struct request_info *request)
 {
     char   *var_value;
 
@@ -530,9 +502,7 @@ static struct syslog_names log_sev[] = {
 
 /* severity_map - lookup facility or severity value */
 
-static int severity_map(table, name)
-struct syslog_names *table;
-char   *name;
+static int severity_map (struct syslog_names *table, char *name)
 {
     struct syslog_names *t;
 
@@ -547,9 +517,7 @@ char   *name;
 
 /* ARGSUSED */
 
-static void severity_option(value, request)
-char   *value;
-struct request_info *request;
+static void severity_option (char *value, struct request_info *request)
 {
     char   *level = split_at(value, '.');
 
@@ -560,8 +528,7 @@ struct request_info *request;
 
 /* get_field - return pointer to next field in string */
 
-static char *get_field(string)
-char   *string;
+static char *get_field (char *string)
 {
     static char *last = "";
     char   *src;
@@ -603,8 +570,7 @@ char   *string;
 
 /* chop_string - strip leading and trailing blanks from string */
 
-static char *chop_string(string)
-register char *string;
+static char *chop_string (register char *string)
 {
     char   *start = 0;
     char   *end;
--- a/tools/tcpd_wrapper/percent_m.c
+++ b/tools/tcpd_wrapper/percent_m.c
@@ -22,9 +22,7 @@ extern int sys_nerr;
 
 #include "mystdarg.h"
 
-char   *percent_m(obuf, ibuf)
-char   *obuf;
-char   *ibuf;
+char *percent_m (char *obuf, char *ibuf)
 {
     char   *bp = obuf;
     char   *cp = ibuf;
--- a/tools/tcpd_wrapper/percent_x.c
+++ b/tools/tcpd_wrapper/percent_x.c
@@ -28,11 +28,7 @@ extern void exit();
 
 /* percent_x - do %<char> expansion, abort if result buffer is too small */
 
-char   *percent_x(result, result_len, string, request)
-char   *result;
-int     result_len;
-char   *string;
-struct request_info *request;
+char *percent_x (char *result, int result_len, char *string, struct request_info *request)
 {
     char   *bp = result;
     char   *end = result + result_len - 1;	/* end of result buffer */
--- a/tools/tcpd_wrapper/ptx.c
+++ b/tools/tcpd_wrapper/ptx.c
@@ -35,8 +35,7 @@ static void ptx_sink();
 
 /* tli_host - determine TLI endpoint info, PTX version */
 
-void    tli_host(request)
-struct request_info *request;
+void tli_host (struct request_info *request)
 {
     static struct sockaddr_in client;
     static struct sockaddr_in server;
@@ -81,8 +80,7 @@ struct request_info *request;
 
 /* ptx_sink - absorb unreceived IP datagram */
 
-static void ptx_sink(fd)
-int     fd;
+static void ptx_sink (int fd)
 {
     char    buf[BUFSIZ];
     struct sockaddr sa;
--- a/tools/tcpd_wrapper/rfc931.c
+++ b/tools/tcpd_wrapper/rfc931.c
@@ -37,10 +37,7 @@ static jmp_buf timebuf;
 
 /* fsocket - open stdio stream on top of socket */
 
-static FILE *fsocket(domain, type, protocol)
-int     domain;
-int     type;
-int     protocol;
+static FILE *fsocket (int domain, int type, int protocol)
 {
     int     s;
     FILE   *fp;
@@ -59,18 +56,14 @@ int     protocol;
 
 /* timeout - handle timeouts */
 
-static void timeout(sig)
-int     sig;
+static void timeout (int sig)
 {
     longjmp(timebuf, sig);
 }
 
 /* rfc931 - return remote user name, given socket structures */
 
-void    rfc931(rmt_sin, our_sin, dest)
-struct sockaddr_gen *rmt_sin;
-struct sockaddr_gen *our_sin;
-char   *dest;
+void rfc931 (struct sockaddr_gen *rmt_sin, struct sockaddr_gen *our_sin, char *dest)
 {
     unsigned rmt_port;
     unsigned our_port;
--- a/tools/tcpd_wrapper/safe_finger.c
+++ b/tools/tcpd_wrapper/safe_finger.c
@@ -42,16 +42,13 @@ char    path[] = "PATH=/bin:/usr/bin:/usr/ucb:/usr/bsd:/etc:/usr/etc:/usr/sbin";
 
 int     finger_pid;
 
-void    cleanup(sig)
-int     sig;
+void cleanup (int sig)
 {
     kill(finger_pid, SIGKILL);
     exit(0);
 }
 
-main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     int     c;
     int     line_length = 0;
@@ -135,8 +132,7 @@ char  **argv;
 
 /* perror_exit - report system error text and terminate */
 
-void    perror_exit(text)
-char   *text;
+void perror_exit (char *text)
 {
     perror(text);
     exit(1);
@@ -144,8 +140,7 @@ char   *text;
 
 /* pipe_stdin - pipe stdin through program (from my ANSI to OLD C converter) */
 
-int     pipe_stdin(argv)
-char  **argv;
+int pipe_stdin (char **argv)
 {
     int     pipefds[2];
     int     pid;
--- a/tools/tcpd_wrapper/scaffold.c
+++ b/tools/tcpd_wrapper/scaffold.c
@@ -41,8 +41,7 @@ int     rfc931_timeout = RFC931_TIMEOUT;
 
 /* dup_hostent - create hostent in one memory block */
 
-static struct hostent *dup_hostent(hp)
-struct hostent *hp;
+static struct hostent *dup_hostent (struct hostent *hp)
 {
     struct hostent_block {
 	struct hostent host;
@@ -77,8 +76,7 @@ struct hostent *hp;
 
 /* find_inet_addr - find all addresses for this host, result to free() */
 
-struct hostent *find_inet_addr(host)
-char   *host;
+struct hostent *find_inet_addr (char *host)
 {
     union gen_addr addr;
     struct hostent *hp;
@@ -121,8 +119,7 @@ char   *host;
 
 /* check_dns - give each address thorough workout, return address count */
 
-int     check_dns(host)
-char   *host;
+int check_dns (char *host)
 {
     struct request_info request;
     struct sockaddr_gen sin;
@@ -159,8 +156,7 @@ char   *host;
 
 /* ARGSUSED */
 
-void    shell_cmd(command)
-char   *command;
+void shell_cmd (char *command)
 {
     if (hosts_access_verbose)
 	printf("command: %s", command);
@@ -170,8 +166,7 @@ char   *command;
 
 /* ARGSUSED */
 
-void    clean_exit(request)
-struct request_info *request;
+void clean_exit (struct request_info *request)
 {
     exit(0);
 }
@@ -180,8 +175,7 @@ struct request_info *request;
 
 /* ARGSUSED */
 
-void    rfc931(request)
-struct request_info *request;
+void rfc931 (struct request_info *request)
 {
     strcpy(request->user, unknown);
 }
--- a/tools/tcpd_wrapper/setenv.c
+++ b/tools/tcpd_wrapper/setenv.c
@@ -16,10 +16,7 @@ static char sccsid[] = "@(#) setenv.c 1.1 93/03/07 22:47:58";
 
 /* setenv - update or insert environment (name,value) pair */
 
-int     setenv(name, value, clobber)
-char   *name;
-char   *value;
-int     clobber;
+int setenv (char *name, char *value, int clobber)
 {
     char   *malloc();
     char   *getenv();
--- a/tools/tcpd_wrapper/shell_cmd.c
+++ b/tools/tcpd_wrapper/shell_cmd.c
@@ -33,8 +33,7 @@ static void do_child();
 
 /* shell_cmd - execute shell command */
 
-void    shell_cmd(command)
-char   *command;
+void shell_cmd (char *command)
 {
     int     child_pid;
     int     wait_pid;
@@ -59,8 +58,7 @@ char   *command;
 
 /* do_child - exec command with { stdin, stdout, stderr } to /dev/null */
 
-static void do_child(command)
-char   *command;
+static void do_child (char *command)
 {
     char   *error;
     int     tmp_fd;
--- a/tools/tcpd_wrapper/socket.c
+++ b/tools/tcpd_wrapper/socket.c
@@ -51,9 +51,7 @@ static void sock_sink();
   * that lack DNS-style trailing dot magic, such as local files or NIS maps.
   */
 
-static struct hostent *tcpd_gethostbyname_dot(name, af)
-char   *name;
-int af;
+static struct hostent *tcpd_gethostbyname_dot (char *name, int af)
 {
     char    dot_name[MAXHOSTNAMELEN + 1];
 
@@ -75,8 +73,7 @@ int af;
 
 /* sock_host - look up endpoint addresses and install conversion methods */
 
-void    sock_host(request)
-struct request_info *request;
+void sock_host (struct request_info *request)
 {
     static struct sockaddr_gen client;
     static struct sockaddr_gen server;
@@ -128,8 +125,7 @@ struct request_info *request;
 
 /* sock_hostaddr - map endpoint address to printable form */
 
-void    sock_hostaddr(host)
-struct host_info *host;
+void sock_hostaddr (struct host_info *host)
 {
     struct sockaddr_gen *sin = host->sin;
 
@@ -144,8 +140,7 @@ struct host_info *host;
 
 /* sock_hostname - map endpoint address to host name */
 
-void    sock_hostname(host)
-struct host_info *host;
+void sock_hostname (struct host_info *host)
 {
     struct sockaddr_gen *sin = host->sin;
     struct hostent *hp;
@@ -239,8 +234,7 @@ struct host_info *host;
 
 /* sock_sink - absorb unreceived IP datagram */
 
-static void sock_sink(fd)
-int     fd;
+static void sock_sink (int fd)
 {
     char    buf[BUFSIZ];
     struct sockaddr_in sin;
--- a/tools/tcpd_wrapper/strcasecmp.c
+++ b/tools/tcpd_wrapper/strcasecmp.c
@@ -66,8 +66,7 @@ static u_char charmap[] = {
 	'\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377',
 };
 
-strcasecmp(s1, s2)
-	char *s1, *s2;
+int strcasecmp (char *s1, char *s2)
 {
 	register u_char	*cm = charmap,
 			*us1 = (u_char *)s1,
@@ -79,9 +78,7 @@ strcasecmp(s1, s2)
 	return(cm[*us1] - cm[*--us2]);
 }
 
-strncasecmp(s1, s2, n)
-	char *s1, *s2;
-	register int n;
+int strncasecmp (char *s1, char *s2, register int n)
 {
 	register u_char	*cm = charmap,
 			*us1 = (u_char *)s1,
--- a/tools/tcpd_wrapper/tcpd.c
+++ b/tools/tcpd_wrapper/tcpd.c
@@ -41,9 +41,7 @@ static char sccsid[] = "@(#) tcpd.c 1.10 96/02/11 17:01:32";
 int     allow_severity = SEVERITY;	/* run-time adjustable */
 int     deny_severity = LOG_WARNING;	/* ditto */
 
-main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     struct request_info request;
     char    path[MAXPATHNAMELEN];
--- a/tools/tcpd_wrapper/tcpdchk.c
+++ b/tools/tcpd_wrapper/tcpdchk.c
@@ -87,9 +87,7 @@ static char *myname;
 static int allow_check;
 static char *inetcf;
 
-int     main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     struct request_info request;
     struct stat st;
@@ -178,7 +176,7 @@ char  **argv;
 
 /* usage - explain */
 
-static void usage()
+static void usage (void)
 {
     fprintf(stderr, "usage: %s [-a] [-d] [-i inet_conf] [-v]\n", myname);
     fprintf(stderr, "	-a: report rules with implicit \"ALLOW\" at end\n");
@@ -190,9 +188,7 @@ static void usage()
 
 /* parse_table - like table_match(), but examines _all_ entries */
 
-static void parse_table(table, request)
-char   *table;
-struct request_info *request;
+static void parse_table (char *table, struct request_info *request)
 {
     FILE   *fp;
     int     real_verdict;
@@ -266,9 +262,7 @@ struct request_info *request;
 
 /* print_list - pretty-print a list */
 
-static void print_list(title, list)
-char   *title;
-char   *list;
+static void print_list (char *title, char *list)
 {
     char    buf[BUFLEN];
     char   *cp;
@@ -288,8 +282,7 @@ char   *list;
 
 /* check_daemon_list - criticize daemon list */
 
-static void check_daemon_list(list)
-char   *list;
+static void check_daemon_list (char *list)
 {
     char    buf[BUFLEN];
     char   *cp;
@@ -316,8 +309,7 @@ char   *list;
 
 /* check_client_list - criticize client list */
 
-static void check_client_list(list)
-char   *list;
+static void check_client_list (char *list)
 {
     char    buf[BUFLEN];
     char   *cp;
@@ -345,8 +337,7 @@ char   *list;
 
 /* check_daemon - criticize daemon pattern */
 
-static void check_daemon(pat)
-char   *pat;
+static void check_daemon (char *pat)
 {
     if (pat[0] == '@') {
 	tcpd_warn("%s: daemon name begins with \"@\"", pat);
@@ -377,8 +368,7 @@ char   *pat;
 
 /* check_user - criticize user pattern */
 
-static void check_user(pat)
-char   *pat;
+static void check_user (char *pat)
 {
     if (pat[0] == '@') {			/* @netgroup */
 	tcpd_warn("%s: user name begins with \"@\"", pat);
@@ -399,8 +389,7 @@ char   *pat;
 
 /* check_host - criticize host pattern */
 
-static int check_host(pat)
-char   *pat;
+static int check_host (char *pat)
 {
     char   *mask;
     int     addr_count = 1;
@@ -475,8 +464,7 @@ char   *pat;
 
 /* reserved_name - determine if name is reserved */
 
-static int reserved_name(pat)
-char   *pat;
+static int reserved_name (char *pat)
 {
     return (STR_EQ(pat, unknown)
 	    || STR_EQ(pat, "KNOWN")
--- a/tools/tcpd_wrapper/tcpdmatch.c
+++ b/tools/tcpd_wrapper/tcpdmatch.c
@@ -53,9 +53,7 @@ static void tcpdmatch();
 
 /* The main program */
 
-int     main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     struct hostent *hp;
     char   *myname = argv[0];
@@ -253,8 +251,7 @@ char  **argv;
 
 /* Explain how to use this program */
 
-static void usage(myname)
-char   *myname;
+static void usage (char *myname)
 {
     fprintf(stderr, "usage: %s [-d] [-i inet_conf] daemon[@host] [user@]host\n",
 	    myname);
@@ -265,10 +262,7 @@ char   *myname;
 
 /* Print interesting expansions */
 
-static void expand(text, pattern, request)
-char   *text;
-char   *pattern;
-struct request_info *request;
+static void expand (char *text, char *pattern, struct request_info *request)
 {
     char    buf[BUFSIZ];
 
@@ -278,8 +272,7 @@ struct request_info *request;
 
 /* Try out a (server,client) pair */
 
-static void tcpdmatch(request)
-struct request_info *request;
+static void tcpdmatch (struct request_info *request)
 {
     int     verdict;
 
--- a/tools/tcpd_wrapper/tli-sequent.c
+++ b/tools/tcpd_wrapper/tli-sequent.c
@@ -49,8 +49,7 @@ static void tli_sink();
 
 /* tli_host - determine endpoint info */
 
-int     tli_host(request)
-struct request_info *request;
+int tli_host (struct request_info *request)
 {
     static struct sockaddr_in client;
     static struct sockaddr_in server;
@@ -145,7 +144,7 @@ struct request_info *request;
 
 /* tli_error - convert tli error number to text */
 
-static char *tli_error()
+static char *tli_error (void)
 {
     static char buf[40];
 
@@ -168,8 +167,7 @@ static char *tli_error()
 
 /* tli_sink - absorb unreceived datagram */
 
-static void tli_sink(fd)
-int     fd;
+static void tli_sink (int fd)
 {
     struct t_unitdata *unit;
     int     flags;
--- a/tools/tcpd_wrapper/tli.c
+++ b/tools/tcpd_wrapper/tli.c
@@ -64,8 +64,7 @@ static void tli_sink();
 
 /* tli_host - look up endpoint addresses and install conversion methods */
 
-void    tli_host(request)
-struct request_info *request;
+void tli_host (struct request_info *request)
 {
     static struct sockaddr_gen client;
     static struct sockaddr_gen server;
@@ -108,8 +107,7 @@ struct request_info *request;
 
 /* tli_cleanup - cleanup some dynamically-allocated data structures */
 
-static void tli_cleanup(request)
-struct request_info *request;
+static void tli_cleanup (struct request_info *request)
 {
     if (request->config != 0)
 	freenetconfigent(request->config);
@@ -121,8 +119,7 @@ struct request_info *request;
 
 /* tli_endpoints - determine TLI client and server endpoint information */
 
-static void tli_endpoints(request)
-struct request_info *request;
+static void tli_endpoints (struct request_info *request)
 {
     struct t_unitdata *server;
     struct t_unitdata *client;
@@ -175,8 +172,7 @@ struct request_info *request;
 
 /* tli_transport - find out TLI transport type */
 
-static struct netconfig *tli_transport(fd)
-int     fd;
+static struct netconfig *tli_transport (int fd)
 {
     struct stat from_client;
     struct stat from_config;
@@ -224,8 +220,7 @@ int     fd;
 
 /* tli_hostaddr - map TLI transport address to printable address */
 
-static void tli_hostaddr(host)
-struct host_info *host;
+static void tli_hostaddr (struct host_info *host)
 {
     struct request_info *request = host->request;
     struct netconfig *config = request->config;
@@ -241,8 +236,7 @@ struct host_info *host;
 
 /* tli_hostname - map TLI transport address to hostname */
 
-static void tli_hostname(host)
-struct host_info *host;
+static void tli_hostname (struct host_info *host)
 {
     struct request_info *request = host->request;
     struct netconfig *config = request->config;
@@ -307,7 +301,7 @@ struct host_info *host;
 
 /* tli_error - convert tli error number to text */
 
-static char *tli_error()
+static char *tli_error (void)
 {
     static char buf[40];
 
@@ -334,8 +328,7 @@ static char *tli_error()
 
 /* tli_sink - absorb unreceived datagram */
 
-static void tli_sink(fd)
-int     fd;
+static void tli_sink (int fd)
 {
     struct t_unitdata *unit;
     int     flags;
--- a/tools/tcpd_wrapper/try-from.c
+++ b/tools/tcpd_wrapper/try-from.c
@@ -37,9 +37,7 @@ static char sccsid[] = "@(#) try-from.c 1.2 94/12/28 17:42:55";
 int     allow_severity = SEVERITY;	/* run-time adjustable */
 int     deny_severity = LOG_WARNING;	/* ditto */
 
-main(argc, argv)
-int     argc;
-char  **argv;
+int main (int argc, char **argv)
 {
     struct request_info request;
     char    buf[BUFSIZ];
--- a/tools/tcpd_wrapper/update.c
+++ b/tools/tcpd_wrapper/update.c
@@ -1,15 +1,15 @@
  /*
   * Routines for controlled update/initialization of request structures.
-  * 
+  *
   * request_init() initializes its argument. Pointers and string-valued members
   * are initialized to zero, to indicate that no lookup has been attempted.
-  * 
+  *
   * request_set() adds information to an already initialized request structure.
-  * 
+  *
   * Both functions take a variable-length name-value list.
-  * 
+  *
   * Diagnostics are reported through syslog(3).
-  * 
+  *
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
@@ -30,9 +30,9 @@ static char sccsid[] = "@(#) update.c 1.1 94/12/28 17:42:56";
 
 /* request_fill - request update engine */
 
-static struct request_info *request_fill(request, ap)
-struct request_info *request;
-va_list ap;
+static struct request_info *request_fill(
+struct request_info *request,
+va_list ap)
 {
     int     key;
     char   *ptr;
--- a/tools/tcpd_wrapper/vfprintf.c
+++ b/tools/tcpd_wrapper/vfprintf.c
@@ -1,29 +1,4 @@
- /*
-  * vfprintf() and vprintf() clones. They will produce unexpected results
-  * when excessive dynamic ("*") field widths are specified. To be used for
-  * testing purposes only.
-  * 
-  * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
-  */
-
-#ifndef lint
-static char sccsid[] = "@(#) vfprintf.c 1.2 94/03/23 17:44:46";
-#endif
-
-#include <stdio.h>
-#include <ctype.h>
-#ifdef __STDC__
-#include <stdarg.h>
-#else
-#include <varargs.h>
-#endif
-
-/* vfprintf - print variable-length argument list to stream */
-
-int     vfprintf(fp, format, ap)
-FILE   *fp;
-char   *format;
-va_list ap;
+__END_DECLS int vfprintf (FILE *fp, char *format, va_list ap)
 {
     char    fmt[BUFSIZ];		/* format specifier */
     register char *fmtp;
@@ -117,9 +92,7 @@ va_list ap;
 
 /* vprintf - print variable-length argument list to stdout */
 
-vprintf(format, ap)
-char   *format;
-va_list ap;
+int vprintf (char *format, va_list ap)
 {
     return (vfprintf(stdout, format, ap));
 }
--- a/tools/tcpd_wrapper/workarounds.c
+++ b/tools/tcpd_wrapper/workarounds.c
@@ -56,8 +56,7 @@ extern int errno;
 
 #undef inet_addr
 
-long    fix_inet_addr(string)
-char   *string;
+long fix_inet_addr (char *string)
 {
     return (inet_addr(string).s_addr);
 }
@@ -77,10 +76,7 @@ char   *string;
 
 #undef fgets
 
-char   *fix_fgets(buf, len, fp)
-char   *buf;
-int     len;
-FILE   *fp;
+char *fix_fgets (char *buf, int len, FILE *fp)
 {
     char   *cp = buf;
     int     c;
@@ -120,13 +116,7 @@ FILE   *fp;
 
 #undef recvfrom
 
-int     fix_recvfrom(sock, buf, buflen, flags, from, fromlen)
-int     sock;
-char   *buf;
-int     buflen;
-int     flags;
-struct sockaddr *from;
-int    *fromlen;
+int fix_recvfrom (int sock, char *buf, int buflen, int flags, struct sockaddr *from, int *fromlen)
 {
     int     ret;
 
@@ -160,10 +150,7 @@ int    *fromlen;
 
 #undef getpeername
 
-int     fix_getpeername(sock, sa, len)
-int     sock;
-struct sockaddr *sa;
-int    *len;
+int fix_getpeername (int sock, struct sockaddr *sa, int *len)
 {
     int     ret;
     struct sockaddr_in *sin = (struct sockaddr_in *) sa;
@@ -188,8 +175,7 @@ int    *len;
 
 #ifdef USE_GETDOMAIN
 
-int     yp_get_default_domain(ptr)
-char  **ptr;
+int yp_get_default_domain (char **ptr)
 {
     static char mydomain[MAXHOSTNAMELEN];
 
@@ -217,8 +203,7 @@ char  **ptr;
 
 #undef gethostbyname
 
-struct hostent *fix_gethostbyname(name)
-char   *name;
+struct hostent *fix_gethostbyname (char *name)
 {
     struct hostent *hp;
     struct in_addr addr;
@@ -255,9 +240,7 @@ char   *name;
 
 #ifdef USE_STRSEP
 
-char   *fix_strtok(buf, sep)
-char   *buf;
-char   *sep;
+char *fix_strtok (char *buf, char *sep)
 {
     static char *state;
     char   *result;
@@ -280,9 +263,7 @@ char   *sep;
 
 #ifdef LIBC_CALLS_STRTOK
 
-char   *my_strtok(buf, sep)
-char   *buf;
-char   *sep;
+char *my_strtok (char *buf, char *sep)
 {
     static char *state;
     char   *result;
--- a/common/types.h
+++ b/common/types.h
@@ -212,7 +212,7 @@ typedef struct _directive_struct
   int   len;
   int   disabled_flag;
   long  cap_bit;
-  int   (*function)();
+  int   (*function)(char* c);
   char  *name;
   char  *description;
   char  *program;
--- a/server/daemon.c
+++ b/server/daemon.c
@@ -133,7 +133,7 @@ static void set_sighup (void)
 static void set_exithandler (void)
 {
   signal(SIGINT, (__sighandler_t)exit_handler);
-  signal(SIGTERM, exit_handler);
+  signal(SIGTERM, (__sighandler_t)exit_handler);
 }
 
 static void reinit (void)
--- a/server/directive.c
+++ b/server/directive.c
@@ -34,6 +34,7 @@
 #include "soa.h"
 #include "status.h"
 #include "xfer.h"
+#include "../common/types.h"
 
 /* --------------------- Local Functions ------------------ */
 
@@ -52,7 +53,7 @@ static int add_directive_func (char *name, int (*func)(void))
     return FALSE;
   }
 
-  item->function = func;
+  item->function = (int (*)(char*))func;
 
   return TRUE;
 }
@@ -62,21 +63,21 @@ static int add_directive_func (char *name, int (*func)(void))
 /* initializes the native commands */
 void init_directive_functions (void)
 {
-  add_directive_func("class", class_directive);
-  add_directive_func("directive", directive_directive);
-  add_directive_func("display", display_directive);
-  add_directive_func("forward", forward_directive);
-  add_directive_func("holdconnect", holdconnect_directive);
-  add_directive_func("limit", limit_directive);
-  add_directive_func("security", security_directive);
-  add_directive_func("notify", notify_directive); 
-  add_directive_func("quit", quit_directive);
-  add_directive_func("register", register_directive);
-  add_directive_func("rwhois", rwhois_directive);
-  add_directive_func("schema", schema_directive);
-  add_directive_func("soa", soa_directive);
-  add_directive_func("status", status_directive);
-  add_directive_func("xfer", xfer_directive);
+  add_directive_func("class", (int (*)(void))class_directive);
+  add_directive_func("directive", (int (*)(void))directive_directive);
+  add_directive_func("display", (int (*)(void))display_directive);
+  add_directive_func("forward",(int (*)(void))forward_directive);
+  add_directive_func("holdconnect", (int (*)(void))holdconnect_directive);
+  add_directive_func("limit", (int (*)(void))limit_directive);
+  add_directive_func("security", (int (*)(void))security_directive);
+  add_directive_func("notify", (int (*)(void))notify_directive);
+  add_directive_func("quit", (int (*)(void))quit_directive);
+  add_directive_func("register", (int (*)(void))register_directive);
+  add_directive_func("rwhois", (int (*)(void))rwhois_directive);
+  add_directive_func("schema", (int (*)(void))schema_directive);
+  add_directive_func("soa", (int (*)(void))soa_directive);
+  add_directive_func("status", (int (*)(void))status_directive);
+  add_directive_func("xfer", (int (*)(void))xfer_directive);
 
 }
 
--- a/server/dump.c
+++ b/server/dump.c
@@ -21,8 +21,8 @@
 /* display_dump_format: this procedure displays the results using the
      "dump" command */
 int
-display_dump_format(record)
-  record_struct *record;
+display_dump_format(
+  record_struct *record)
 {
   class_struct   *class;
   dl_list_type   *field_list;
--- a/server/guardian.c
+++ b/server/guardian.c
@@ -29,8 +29,8 @@
 /*--------------------- LOCAL FUNCTIONS ---------------------------*/
 
 static int
-looks_like_id(id)
-  char *id;
+looks_like_id(
+  char *id)
 {
   char *p = NULL;
 
@@ -50,9 +50,9 @@ looks_like_id(id)
 }
 
 static int
-build_guardian_query(query, id)
-  query_struct *query;
-  char         *id;
+build_guardian_query(
+  query_struct *query,
+  char         *id)
 {
   char         query_str[MAX_LINE];
 
@@ -83,8 +83,8 @@ build_guardian_query(query, id)
 
 /* A debug function which prints the details of a query_struct */
 void
-print_query_details(query)
-  query_struct *query;
+print_query_details(
+  query_struct *query)
 {
 
   if (query->auth_area_name)
@@ -109,9 +109,9 @@ print_query_details(query)
    guardian information.  Returns FALSE if this guardian doesn't
    match, TRUE if it does. */
 static int
-check_credentials(guard, request)
-  record_struct *guard;
-  auth_struct   *request;
+check_credentials(
+  record_struct *guard,
+  auth_struct   *request)
 {
   av_pair_struct    *av_pair;
   char              *guard_info;
@@ -196,8 +196,8 @@ check_credentials(guard, request)
 }
 
 static record_struct *
-lookup_guardian_record(guard_id)
-  char *guard_id;
+lookup_guardian_record(
+  char *guard_id)
 {
   query_struct      *query;
   dl_list_type      new_rec_list;
@@ -260,8 +260,8 @@ lookup_guardian_record(guard_id)
 
 /* this function returns TRUE if the record is guarded, FALSE if not.  */
 static int
-is_record_guarded(record)
-  record_struct *record;
+is_record_guarded(
+  record_struct *record)
 {
   av_pair_struct *av_pair;
 
@@ -302,8 +302,8 @@ is_record_guarded(record)
 /* returns TRUE if the security attributes match a guardian of record,
    or record not guarded */
 int
-check_guardian(record)
-  record_struct *record;
+check_guardian(
+  record_struct *record)
 {
   av_pair_struct *av_pair;
   record_struct  *guard;
@@ -479,8 +479,8 @@ check_guardian(record)
 }
 
 int
-is_guardian_record(record)
-  record_struct *record;
+is_guardian_record(
+  record_struct *record)
 {
   if (STR_EQ(record->class->name, "Guardian"))
   {
@@ -495,8 +495,8 @@ is_guardian_record(record)
    crypt() passwords, normalize scheme names, etc. */
 
 int
-transform_guardian_record(rec)
-  record_struct *rec;
+transform_guardian_record(
+  record_struct *rec)
 {
   av_pair_struct *av;
   char           *scheme;
--- a/server/referral.c
+++ b/server/referral.c
@@ -262,8 +262,8 @@ static int within_network (char *subnetwork, char *network)
 /* get_up_referral: This function gets punt referrals to the
    root RWhois server */
 static int
-get_up_referral(referral_list)
-  dl_list_type *referral_list;
+get_up_referral(
+  dl_list_type *referral_list)
 {
   FILE            *fp;
   char            *punt_file;
@@ -320,11 +320,11 @@ get_up_referral(referral_list)
 /* get_down_referral: This function gets link referrals to a
    referred authority area */ 
 static int
-get_down_referral(hvalue, htype, aa_name, referral_list)
-  char         *hvalue;
-  int          htype;
-  char         *aa_name;
-  dl_list_type *referral_list;
+get_down_referral(
+  char         *hvalue,
+  int          htype,
+  char         *aa_name,
+  dl_list_type *referral_list)
 {
   query_struct      *query;
   dl_list_type      record_list;
@@ -484,10 +484,10 @@ static int reduce_network (char *network)
 
 
 static int
-build_referral_query(query, search_value, aa_name)
-  query_struct *query;
-  char *search_value;
-  char *aa_name;
+build_referral_query(
+  query_struct *query,
+  char *search_value,
+  char *aa_name)
 {
   char query_str[MAX_LINE];
 
@@ -538,8 +538,8 @@ static void print_referral (char *referral_to, char *aa_name)
 
 /* print_referral_list: This function prints a referral list */
 static void
-print_referral_list(referral_list)
-  dl_list_type *referral_list;
+print_referral_list(
+  dl_list_type *referral_list)
 {
   int             not_done;
   referral_struct *referral;
@@ -564,8 +564,8 @@ print_referral_list(referral_list)
 
 /* destroy_referral_list: This function frees a referral list */
 static void
-destroy_referral_list(referral_list)
-  dl_list_type *referral_list;
+destroy_referral_list(
+  dl_list_type *referral_list)
 {
   if (!referral_list)
   {
@@ -578,8 +578,8 @@ destroy_referral_list(referral_list)
 
 /* destroy_referral_data: This function frees a referral structure */
 static int
-destroy_referral_data(referral)
-  referral_struct *referral;
+destroy_referral_data(
+  referral_struct *referral)
 {
   if (!referral)
   {
@@ -608,8 +608,8 @@ destroy_referral_data(referral)
 /* refer_query: This function refers a query to another RWhois
    server if this server can not resolve the query */
 int
-refer_query(query)
-  query_struct *query;
+refer_query(
+  query_struct *query)
 {
   query_term_struct *ver;
   query_term_struct *hor;
@@ -655,9 +655,9 @@ refer_query(query)
 
 /* refer_query_term:  This function refers a query term */
 int
-refer_query_term(query_term, referral_list)
-  query_term_struct *query_term;
-  dl_list_type      *referral_list;
+refer_query_term(
+  query_term_struct *query_term,
+  dl_list_type      *referral_list)
 {
   dl_list_type     *auth_area_list    = NULL;
   auth_area_struct *auth_area;
@@ -833,8 +833,8 @@ int hierarchical_value_within_aa (char *hvalue, int htype, char *aa_name)
 /*   here we only check the specific referral_auth_area attribute*/
 
 int
-referral_rec_check( ref_rec )
-  record_struct *ref_rec; 
+referral_rec_check(
+  record_struct *ref_rec)
 {
   int           not_done;
   av_pair_struct    *av;
@@ -903,8 +903,8 @@ referral_rec_check( ref_rec )
 }
 
 static int
-aa_has_referrals(aa)
-  auth_area_struct *aa;
+aa_has_referrals(
+  auth_area_struct *aa)
 {
   class_ref_struct     *c_ref;
 
--- a/server/reg_ext.c
+++ b/server/reg_ext.c
@@ -24,12 +24,12 @@
 
 
 ext_parse_response_type
-run_external_parser(parse_prog, action, reg_email, old_rec, new_rec_p)
-  char                 *parse_prog;
-  register_action_type action;
-  char                 *reg_email;
-  record_struct        *old_rec;
-  record_struct        **new_rec_p;
+run_external_parser(
+  char                 *parse_prog,
+  register_action_type action,
+  char                 *reg_email,
+  record_struct        *old_rec,
+  record_struct        **new_rec_p)
 {
   FILE                    *tmp_fp;
   char                    *action_str;
--- a/server/reg_utils.c
+++ b/server/reg_utils.c
@@ -48,9 +48,9 @@ static char *get_aaname_from_anon_rec PROTO((anon_record_struct *anon_rec));
 /* --------------------- Local Functions ------------------- */
 
 static void
-report_rec_parse_error(function_name, status)
-  char             *function_name;
-  rec_parse_result status;
+report_rec_parse_error(
+  char             *function_name,
+  rec_parse_result status)
 {
   switch (status)
   {
@@ -76,8 +76,8 @@ report_rec_parse_error(function_name, status)
 
 /* finds the class attribute in an anonymous record, and extracts the name. */
 static char *
-get_classname_from_anon_rec(anon_rec)
-  anon_record_struct *anon_rec;
+get_classname_from_anon_rec(
+  anon_record_struct *anon_rec)
 {
   anon_av_pair_struct *av;
   
@@ -91,8 +91,8 @@ get_classname_from_anon_rec(anon_rec)
 
 /* finds the auth-area attribute in the anon record and returns the value. */
 static char *
-get_aaname_from_anon_rec(anon_rec)
-  anon_record_struct *anon_rec;
+get_aaname_from_anon_rec(
+  anon_record_struct *anon_rec)
 {
   anon_av_pair_struct *av;
 
@@ -106,8 +106,8 @@ get_aaname_from_anon_rec(anon_rec)
 /* --------------------- Public Functions ------------------- */
 
 register_action_type
-translate_action_str(action)
-  char *action;
+translate_action_str(
+  char *action)
 {
   if (STR_EQ(action, "ADD"))
   {
@@ -126,8 +126,8 @@ translate_action_str(action)
 }
 
 char *
-action_to_string(action)
-  register_action_type action;
+action_to_string(
+  register_action_type action)
 {
   switch (action)
   {
@@ -171,10 +171,10 @@ char *generate_updated (void)
    register spool file.  Basically, this is just an encapsulation of
    some error checking. */
 int
-get_class_and_aa_from_anon_rec(anon_rec, class_p, auth_area_p)
-  anon_record_struct *anon_rec;
-  class_struct       **class_p;
-  auth_area_struct   **auth_area_p;
+get_class_and_aa_from_anon_rec(
+  anon_record_struct *anon_rec,
+  class_struct       **class_p,
+  auth_area_struct   **auth_area_p)
 {
   char             *class_str;
   char             *aa_str;
@@ -216,8 +216,8 @@ get_class_and_aa_from_anon_rec(anon_rec, class_p, auth_area_p)
 
 /* returns TRUE if a there is a record separator in the file. */
 int
-has_record_separator(fp)
-  FILE  *fp;
+has_record_separator(
+  FILE  *fp)
 {
   char          line[MAX_LINE];
   unsigned long orig_pos;
@@ -264,9 +264,9 @@ has_record_separator(fp)
 
 /* updates the soa record. Returns TRUE if ok, FALSE if not. */
 int
-update_soa_record(auth_area, updated_str)
-  auth_area_struct *auth_area;
-  char             *updated_str;
+update_soa_record(
+  auth_area_struct *auth_area,
+  char             *updated_str)
 {  
   free(auth_area->serial_no);
   auth_area->serial_no = xstrdup(updated_str);
@@ -277,9 +277,9 @@ update_soa_record(auth_area, updated_str)
 /* either adds or modifies the record's 'Updated' attribute, setting
    it to 'updated_str' */
 void
-set_updated_attr(record, updated_str)
-  record_struct *record;
-  char          *updated_str;
+set_updated_attr(
+  record_struct *record,
+  char          *updated_str)
 {
   av_pair_struct   *av;
 
@@ -298,10 +298,10 @@ set_updated_attr(record, updated_str)
 
 
 int
-compare_record_attr_by_name(rec1, rec2, attr_name)
-  record_struct *rec1;
-  record_struct *rec2;
-  char          *attr_name;
+compare_record_attr_by_name(
+  record_struct *rec1,
+  record_struct *rec2,
+  char          *attr_name)
 {
   av_pair_struct *av1;
   av_pair_struct *av2;
@@ -330,10 +330,10 @@ compare_record_attr_by_name(rec1, rec2, attr_name)
 }
 
 int
-get_id_and_updated_from_anon(anon_rec, id, updated)
-  anon_record_struct *anon_rec;
-  char **id;
-  char **updated;
+get_id_and_updated_from_anon(
+  anon_record_struct *anon_rec,
+  char **id,
+  char **updated)
 {
   anon_av_pair_struct *anon_av;
 
@@ -360,10 +360,10 @@ get_id_and_updated_from_anon(anon_rec, id, updated)
 
 /* builds the query struture used to get the to-be-deleted object */
 int
-build_object_query(query, id, updated)
-  query_struct *query;
-  char         *id;
-  char         *updated;
+build_object_query(
+  query_struct *query,
+  char         *id,
+  char         *updated)
 {
   char                query_str[MAX_LINE];
 
@@ -395,9 +395,9 @@ build_object_query(query, id, updated)
 /* build a query looking for other objects with the same primary keys
    as the given record */
 int
-build_primary_key_query(query, record)
-  query_struct  *query;
-  record_struct *record;
+build_primary_key_query(
+  query_struct  *query,
+  record_struct *record)
 {
   dl_list_type     *attr_list;
   attribute_struct *attr;
@@ -458,9 +458,9 @@ build_primary_key_query(query, record)
 /* reads the contents of the register spool file on an add operation
    (one fully specified record only) */
 int
-read_add_spool(spool_fp, new_record_p)
-  FILE          *spool_fp;
-  record_struct **new_record_p;
+read_add_spool(
+  FILE          *spool_fp,
+  record_struct **new_record_p)
 {
   auth_area_struct   *aa;
   class_struct       *class;
@@ -517,10 +517,10 @@ read_add_spool(spool_fp, new_record_p)
 /* read the contents of the register spool file for a mod operation
    (id & updated, _NEW_, and the replacement record) */
 int
-read_mod_spool(spool_fp, new_record_p, old_record_p)
-  FILE               *spool_fp;
-  record_struct      **new_record_p;
-  anon_record_struct **old_record_p;
+read_mod_spool(
+  FILE               *spool_fp,
+  record_struct      **new_record_p,
+  anon_record_struct **old_record_p)
 {
   auth_area_struct   *aa;
   class_struct       *class;
@@ -584,9 +584,9 @@ read_mod_spool(spool_fp, new_record_p, old_record_p)
 /* read the contents of the register spool file for a del operation
    (at least an ID and Updated, other stuff is ok but ignored) */
 int
-read_del_spool(spool_fp, old_record_p)
-  FILE *spool_fp;
-  anon_record_struct **old_record_p;
+read_del_spool(
+  FILE *spool_fp,
+  anon_record_struct **old_record_p)
 {
   anon_record_struct *old_rec;
   rec_parse_result   status;
--- a/server/register.c
+++ b/server/register.c
@@ -96,9 +96,9 @@ static int print_add_result PROTO((record_struct *rec));
 
 
 static int
-get_real_object_from_anon(anon_rec, record_list)
-  anon_record_struct *anon_rec;
-  dl_list_type       *record_list;
+get_real_object_from_anon(
+  anon_record_struct *anon_rec,
+  dl_list_type       *record_list)
 {
   query_struct   *query;
   record_struct  *rec;
@@ -194,8 +194,8 @@ get_real_object_from_anon(anon_rec, record_list)
 /* generates a search str and validates that no record exists for this
      auth area. Returns TRUE if success, FALSE if failure. */
 static int
-check_uniq_record(record)
-  record_struct *record;
+check_uniq_record(
+  record_struct *record)
 {
   query_struct  *query;
   dl_list_type  record_list;
@@ -235,9 +235,9 @@ check_uniq_record(record)
    probably make sure that the other primary keys match, too, but
    doesn't. */
 static int
-ensure_objects_match(new_record, old_record)
-  record_struct *new_record;
-  record_struct *old_record;
+ensure_objects_match(
+  record_struct *new_record,
+  record_struct *old_record)
 {
   av_pair_struct *new_av;
   av_pair_struct *old_av;
@@ -304,8 +304,8 @@ ensure_objects_match(new_record, old_record)
 /* indexes the file from a new record structure. Returns TRUE if
      success, FALSE if failure. */
 static int
-index_new_record(record)
-  record_struct *record;
+index_new_record(
+  record_struct *record)
 {
   char             store_fname[MAX_FILE];
   dl_list_type     index_file_list;
@@ -365,9 +365,9 @@ index_new_record(record)
 
 /* check the add record for validity */
 static int
-check_add(record_p, reg_email)
-  record_struct **record_p;
-  char          *reg_email;
+check_add(
+  record_struct **record_p,
+  char          *reg_email)
 {
   record_struct           *rec;
   ext_parse_response_type resp      = EXT_PARSE_OK;
@@ -429,11 +429,11 @@ check_add(record_p, reg_email)
 
 /* check the mod records for validity */
 static int
-check_mod(new_record_p, old_record_p, old_record_list, reg_email)
-  record_struct      **new_record_p;
-  anon_record_struct **old_record_p;
-  dl_list_type       *old_record_list;
-  char               *reg_email;
+check_mod(
+  record_struct      **new_record_p,
+  anon_record_struct **old_record_p,
+  dl_list_type       *old_record_list,
+  char               *reg_email)
 {
   int                     validate_flag;
   record_struct           *new_rec;
@@ -525,10 +525,10 @@ check_mod(new_record_p, old_record_p, old_record_list, reg_email)
    deletion is valid.  Also fills 'record_list' with the actual
    record(s) matching the delete criteria. */
 static int
-check_del(old_rec, record_list, reg_email)
-  anon_record_struct *old_rec;
-  dl_list_type       *record_list;
-  char               *reg_email;
+check_del(
+  anon_record_struct *old_rec,
+  dl_list_type       *record_list,
+  char               *reg_email)
 {
   record_struct           *rec;
   ext_parse_response_type resp = EXT_PARSE_OK;
@@ -587,8 +587,8 @@ check_del(old_rec, record_list, reg_email)
 
 
 static int 
-add_record(rec)
-  record_struct  *rec;
+add_record(
+  record_struct  *rec)
 {
   av_pair_struct *av;
   int            status;
@@ -626,9 +626,9 @@ add_record(rec)
 /* deletes a record from a file.  Returns TRUE if success, FALSE if
      failure */
 static int
-del_record(record_list, update_soa)
-  dl_list_type *record_list;
-  int          update_soa;
+del_record(
+  dl_list_type *record_list,
+  int          update_soa)
 {
   auth_area_struct  *aa;
   record_struct     *rec;
@@ -660,9 +660,9 @@ del_record(record_list, update_soa)
 /* modifies a record from a file. Returns TRUE if success, FALSE if
      failure */
 static int 
-mod_record(new_record, old_record_list)
-  record_struct    *new_record;
-  dl_list_type     *old_record_list;
+mod_record(
+  record_struct    *new_record,
+  dl_list_type     *old_record_list)
 {
   char *updated_str;
   
@@ -683,8 +683,8 @@ mod_record(new_record, old_record_list)
 }
 
 static int
-print_add_result(rec)
-  record_struct  *rec;
+print_add_result(
+  record_struct  *rec)
 {
   av_pair_struct *av;
   char           *id;
@@ -710,9 +710,9 @@ print_add_result(rec)
 /* ------------------- Public Functions -------------------- */
 
 int
-process_registration(reg_email, action)
-  char                 *reg_email;
-  register_action_type action;
+process_registration(
+  char                 *reg_email,
+  register_action_type action)
 {
   FILE                 *spool_fp;
   anon_record_struct   *old_rec = NULL;
--- a/server/schema_directive.c
+++ b/server/schema_directive.c
@@ -117,9 +117,9 @@ static schema_arg_struct *schema_parse_args (char *str)
 /* schema_display_attribute:  this function displays the information about
    each attribute of a class. */
 static void 
-schema_display_attribute(name, attr)
-  char             *name;
-  attribute_struct *attr;
+schema_display_attribute(
+  char             *name,
+  attribute_struct *attr)
 {
   print_response(RESP_SCHEMA, "%s:attribute:%s", name, 
                  SAFE_STR_NONE(attr->name));
@@ -177,9 +177,9 @@ schema_display_attribute(name, attr)
 /* schema_display_attribute_list:  This function displays all the
    attributes in a class.  */ 
 static void 
-schema_display_attribute_list(name, list)
-  char         *name;
-  dl_list_type *list;
+schema_display_attribute_list(
+  char         *name,
+  dl_list_type *list)
 {
   int not_done;
  
@@ -202,8 +202,8 @@ schema_display_attribute_list(name, list)
 /* schema_display_class: This function is called to display the
      class in a schema. */
 static void 
-schema_display_class(class)
-  class_struct *class;
+schema_display_class(
+  class_struct *class)
 {
     schema_display_attribute_list(class->name, &(class->attribute_list));
 }
@@ -212,8 +212,8 @@ schema_display_class(class)
 /* schema_display_all_schemas: This function is called to display all the
      classes in a schema. */
 static void 
-schema_display_classes(class_list)
-  dl_list_type *class_list;
+schema_display_classes(
+  dl_list_type *class_list)
 {   
   int          not_done;
   class_struct *class;
--- a/server/security.c
+++ b/server/security.c
@@ -19,6 +19,7 @@
 #include "main_config.h"
 #include "types.h"
 
+int     hosts_ctl(char   *daemon, char   *name, char   *addr, char   *user);
 /***************************************************************************
 sets up a security playground by doing a chroot and setuid (taken
 from W.Z. Venema's chrootuid code.
--- a/server/security_directive.c
+++ b/server/security_directive.c
@@ -46,8 +46,8 @@ static void print_auth_struct PROTO((void));
 /*------------------ LOCAL FUNCTIONS -----------------------------*/
 
 static void 
-free_auth_struct(auth)
-  auth_struct *auth;
+free_auth_struct(
+  auth_struct *auth)
 {
   if (!auth)
   {
@@ -178,8 +178,8 @@ static security_arg_struct *security_parse_args (char *str)
    authentication of all requests sent by the client, and response for
    all responses from the server. */
 static auth_struct * 
-security_store_auth(prs)
-  security_arg_struct *prs;
+security_store_auth(
+  security_arg_struct *prs)
 {
   auth_struct *auth = NULL;
 
--- a/server/soa.c
+++ b/server/soa.c
@@ -24,8 +24,8 @@
 /* soa_parse_args: this function parses the input argument string 
    and stores the arguments in soa_arg_struct. */
 static dl_list_type * 
-soa_parse_args(str)
-    char *str;
+soa_parse_args(
+    char *str)
 {
   int              argc;
   char             **argv;
@@ -67,8 +67,8 @@ soa_parse_args(str)
 
 /* soa_display_autharea: Function to display the auth_area information. */
 static int 
-soa_display_auth_area(aa)
-  auth_area_struct *aa;
+soa_display_auth_area(
+  auth_area_struct *aa)
 {
   if (!aa)
   {
@@ -99,8 +99,8 @@ soa_display_auth_area(aa)
 /* soa_display_auth_areas displays the auth-area info for the list of
      authority areas. */
 static void 
-soa_display_auth_areas(auth_area_list)
-  dl_list_type  *auth_area_list;
+soa_display_auth_areas(
+  dl_list_type  *auth_area_list)
 {
   int           not_done;
 
@@ -117,8 +117,8 @@ soa_display_auth_areas(auth_area_list)
 
 /* update_soa_auth_area: update soa for one auth_area */
 static int 
-update_soa_auth_area(aa)
-  auth_area_struct *aa;
+update_soa_auth_area(
+  auth_area_struct *aa)
 {
   if (!aa)
   {
@@ -141,8 +141,8 @@ update_soa_auth_area(aa)
  *  authority areas. 
  */
 static void 
-update_soa_auth_area_list(auth_area_list)
-  dl_list_type  *auth_area_list;
+update_soa_auth_area_list(
+  dl_list_type  *auth_area_list)
 {
   int           not_done;
 
--- a/server/sresponse.c
+++ b/server/sresponse.c
@@ -15,10 +15,10 @@ static int processline PROTO((char         *line,
 
 /* processline: This function processes a response line */
 static int
-processline(line, delimiter, response)
-  char         *line;
-  char         *delimiter;
-  dl_list_type *response;
+processline(
+  char         *line,
+  char         *delimiter,
+  dl_list_type *response)
 {
   char *p;
 
@@ -158,10 +158,10 @@ void send_directive (int sockfd, char *directive)
 /* recv_response: This functions receives response from
    an RWhois server */
 void
-recv_response(fp, delimiter, response)
-  FILE         *fp;
-  char         *delimiter;
-  dl_list_type *response;
+recv_response(
+  FILE         *fp,
+  char         *delimiter,
+  dl_list_type *response)
 {
   char line[MAX_LINE];
   int  not_done        = TRUE;
--- a/server/sschema.c
+++ b/server/sschema.c
@@ -33,10 +33,10 @@ static int base_attr PROTO((char *tag,
 /* create_schema_file_record: This function maps an RWhois
    server response into a schema file record */
 static int
-create_schema_file_record(aa, fp, response)
-  auth_area_struct *aa;
-  FILE             *fp;
-  dl_list_type     *response;
+create_schema_file_record(
+  auth_area_struct *aa,
+  FILE             *fp,
+  dl_list_type     *response)
 {
   int         not_done;
   int         first_str        = TRUE;
@@ -173,10 +173,10 @@ create_schema_file_record(aa, fp, response)
 /* create_attr_file_line: This function creates an attribute file
    line */
 static void
-create_attr_file_line(fp, tag, value)
-  FILE *fp;
-  char *tag;
-  char *value;
+create_attr_file_line(
+  FILE *fp,
+  char *tag,
+  char *value)
 {
   if (!fp    ||
       !tag   || !*tag ||
@@ -316,9 +316,9 @@ static int base_attr (char *tag, char *value)
 /* create_schema_file: This function creates schema file and
    attribute definitions directory for a slave authority area */
 int
-create_schema_file(aa, server)
-  auth_area_struct *aa;
-  server_struct    *server;
+create_schema_file(
+  auth_area_struct *aa,
+  server_struct    *server)
 {
   int          sockfd;
   int          not_done             = TRUE;
--- a/server/ssoa.c
+++ b/server/ssoa.c
@@ -17,9 +17,9 @@ static int create_soa_file_record PROTO((FILE         *fp,
 /* create_soa_file_record: This function maps an RWhois server
    response into an SOA file record */
 static int
-create_soa_file_record(fp, response)
-  FILE         *fp;
-  dl_list_type *response;
+create_soa_file_record(
+  FILE         *fp,
+  dl_list_type *response)
 {
   int  not_done;
   char *str;
@@ -82,9 +82,9 @@ create_soa_file_record(fp, response)
 /* create_soa_file: This function creates SOA file for a
    slave authority area */
 int
-create_soa_file(aa, server)
-  auth_area_struct *aa;
-  server_struct    *server;
+create_soa_file(
+  auth_area_struct *aa,
+  server_struct    *server)
 {
   int          sockfd;
   int          not_done             = TRUE;
--- a/server/sstate.c
+++ b/server/sstate.c
@@ -14,9 +14,10 @@ static int          childstatus;
 static int
 destroy_slave_state_data PROTO((slave_state_struct *slave_state));
 
-static void sigalrm_handler();
+static void sigalrm_handler (int signo);
 
-static void sigchld_handler();
+
+static void sigchld_handler (int signo);
 
 
 /* ------------------- LOCAL FUNCTIONS -------------------- */
@@ -25,8 +26,8 @@ static void sigchld_handler();
 /* destroy_slave_state_data: This function frees a slave state
    structure */
 static int
-destroy_slave_state_data(slave_state)
-  slave_state_struct *slave_state;
+destroy_slave_state_data(
+  slave_state_struct *slave_state)
 {
   if (!slave_state)
   {
@@ -91,8 +92,8 @@ int set_slave_state (char *name, int pid, int action, int status)
 
 /* get_slave_state: This function gets slave authority area state */
 slave_state_struct *
-get_slave_state(name)
-  char *name;
+get_slave_state(
+  char *name)
 {
   slave_state_struct *slave_state;
   int                not_done;
@@ -117,8 +118,8 @@ get_slave_state(name)
 /* init_slave_state_list: This function initializes slave
    authority area state list */
 void
-init_slave_state_list(slave_aa_list)
-  dl_list_type *slave_aa_list;
+init_slave_state_list(
+  dl_list_type *slave_aa_list)
 {
   auth_area_struct   *aa;
   slave_state_struct *slave_state;
--- a/server/state.c
+++ b/server/state.c
@@ -49,8 +49,8 @@ get_rwhois_state()
 }
 
 int
-set_rwhois_state(s)
-  rwhois_state_type s;
+set_rwhois_state(
+  rwhois_state_type s)
 {
   state_info.state = s;
 
@@ -191,8 +191,8 @@ get_register_action()
 }
 
 void
-set_register_action(action)
-  register_action_type action;
+set_register_action(
+  register_action_type action)
 {
   state_info.register_action = action;
 }
--- a/server/sxfer.c
+++ b/server/sxfer.c
@@ -63,9 +63,9 @@ static int class_in_xfer_arg PROTO((class_struct    *class,
 /* create_data_file_record: This function maps an RWhois server
    response into a data file record */
 static int
-create_data_file_record(aa, response)
-  auth_area_struct *aa;
-  dl_list_type     *response;
+create_data_file_record(
+  auth_area_struct *aa,
+  dl_list_type     *response)
 {
   int         not_done;
   int         first_str        = TRUE;
@@ -155,10 +155,10 @@ create_data_file_record(aa, response)
 
 /* create_data_file_line: This function creates a data file line */
 static void
-create_data_file_line(fp, tag, value)
-  FILE *fp;
-  char *tag;
-  char *value;
+create_data_file_line(
+  FILE *fp,
+  char *tag,
+  char *value)
 {
   if (STR_EQ(tag, "Class-Name"))
   {
@@ -233,9 +233,9 @@ static void xfer_split_av (char *str, char *attr, char *value)
 /* xfer_parse_args: This function parses the xfer-arg parameter for
    partial replication */
 static xfer_arg_struct * 
-xfer_parse_args(str, aa)
-  char             *str;
-  auth_area_struct *aa;
+xfer_parse_args(
+  char             *str,
+  auth_area_struct *aa)
 {
   xfer_arg_struct   *xs;
   xfer_class_struct *cur_xclass = NULL;
@@ -315,9 +315,9 @@ xfer_parse_args(str, aa)
 /* class_in_xfer_arg: This function checks if a class is in
    the xfer-arg parameter for partial replication */
 static int
-class_in_xfer_arg(class, xs)
-  class_struct    *class;
-  xfer_arg_struct *xs;
+class_in_xfer_arg(
+  class_struct    *class,
+  xfer_arg_struct *xs)
 {
   xfer_class_struct *xfer_class;
   class_struct      *c;
@@ -348,10 +348,10 @@ class_in_xfer_arg(class, xs)
 /* create_data_files: This function creates data files for a
    slave authority area */
 int
-create_data_files(aa, server, initial)
-  auth_area_struct *aa;
-  server_struct    *server;
-  int              initial;
+create_data_files(
+  auth_area_struct *aa,
+  server_struct    *server,
+  int              initial)
 {
   int             sockfd;
   int             not_done             = TRUE;
@@ -465,9 +465,9 @@ create_data_files(aa, server, initial)
 /* index_data_files_by_suffix: This function indexes data files
    by suffix */
 int
-index_data_files_by_suffix(aa, suffix)
-  auth_area_struct *aa;
-  char             *suffix;
+index_data_files_by_suffix(
+  auth_area_struct *aa,
+  char             *suffix)
 {
   schema_struct   *schema;
   dl_list_type    *class_list;
--- a/server/xfer.c
+++ b/server/xfer.c
@@ -57,8 +57,8 @@ typedef struct xfer_arg_struct
 
 
 static int
-destroy_xfer_class_data(xclass)
-  xfer_class_struct *xclass;
+destroy_xfer_class_data(
+  xfer_class_struct *xclass)
 {
   if (!xclass) return TRUE;
 
@@ -259,9 +259,9 @@ static xfer_arg_struct *xfer_parse_args (char *str)
      attributes; if the xfer_class's attribute list is empty, assume
      that we want all attributes */
 static int
-attr_in_xfer_class(attr, xfer_class)
-  attribute_struct  *attr;
-  xfer_class_struct *xfer_class;
+attr_in_xfer_class(
+  attribute_struct  *attr,
+  xfer_class_struct *xfer_class)
 {
   dl_list_type     *attr_list;
   attribute_struct *a;
@@ -287,9 +287,9 @@ attr_in_xfer_class(attr, xfer_class)
 }
 
 static int
-is_record_new(rec, serial_no)
-  record_struct *rec;
-  char          *serial_no;
+is_record_new(
+  record_struct *rec,
+  char          *serial_no)
 {
   av_pair_struct *av;
 
@@ -312,10 +312,10 @@ is_record_new(rec, serial_no)
      displays only those fields which match the attributes given in
      curr_class.  It returns TRUE if any data is displayed. */
 static int 
-xfer_display_record(rec, class, curr_class)
-  record_struct     *rec;
-  class_struct      *class;
-  xfer_class_struct *curr_class;
+xfer_display_record(
+  record_struct     *rec,
+  class_struct      *class,
+  xfer_class_struct *curr_class)
 {
   av_pair_struct *av_pair;
   int            not_done;
@@ -352,12 +352,12 @@ xfer_display_record(rec, class, curr_class)
      of curr_class in authority area aa, depending on the value of serial_no.
      It returns TRUE if any data is xferred. */ 
 static int 
-xfer_file_xfer(aa, curr_file, class, curr_class, serial_no)
-  auth_area_struct  *aa;
-  file_struct       *curr_file; 
-  class_struct      *class;
-  xfer_class_struct *curr_class;
-  char              *serial_no;
+xfer_file_xfer(
+  auth_area_struct  *aa,
+  file_struct       *curr_file,
+  class_struct      *class,
+  xfer_class_struct *curr_class,
+  char              *serial_no)
 {
   record_struct    *rec;
   FILE             *fp;
@@ -393,11 +393,11 @@ xfer_file_xfer(aa, curr_file, class, curr_class, serial_no)
    authority area aa, depending upon the value of the serial number.  It
    returns TRUE on successful xfer of data. */
 static int 
-xfer_class(aa, class, curr_class, serial_no)
-  auth_area_struct  *aa;
-  class_struct      *class;
-  xfer_class_struct *curr_class; 
-  char              *serial_no;
+xfer_class(
+  auth_area_struct  *aa,
+  class_struct      *class,
+  xfer_class_struct *curr_class,
+  char              *serial_no)
 {
   int          not_done;
   int          found_data       = 0;
@@ -446,9 +446,9 @@ xfer_class(aa, class, curr_class, serial_no)
      authority area aa, depending upon the value of serial number.  It
      returns TRUE if data is transferred.  */
 static int 
-xfer_all_classes(aa, serial_no)
-  auth_area_struct *aa;
-  char             *serial_no;
+xfer_all_classes(
+  auth_area_struct *aa,
+  char             *serial_no)
 {
   int          not_done;
   int          found_data = 0;
--- a/tools/tcpd_wrapper/clean_exit.c
+++ b/tools/tcpd_wrapper/clean_exit.c
@@ -13,6 +13,7 @@ static char sccsid[] = "@(#) clean_exit.c 1.4 94/12/28 17:42:19";
 #endif
 
 #include <stdio.h>
+#include <unistd.h>
 
 extern void exit();
 
--- a/tools/tcpd_wrapper/eval.c
+++ b/tools/tcpd_wrapper/eval.c
@@ -31,6 +31,8 @@ static char sccsid[] = "@(#) eval.c 1.3 95/01/30 19:51:45";
 
 #include "tcpd.h"
 
+char *eval_hostaddr (struct host_info *host);
+
  /*
   * When a string has the value STRING_UNKNOWN, it means: don't bother, I
   * tried to look up the data but it was unavailable for some reason. When a
--- a/tools/tcpd_wrapper/fix_options.c
+++ b/tools/tcpd_wrapper/fix_options.c
@@ -29,8 +29,7 @@ static char sccsid[] = "@(#) fix_options.c 1.6 97/04/08 02:29:19";
 
 /* fix_options - get rid of IP-level socket options */
 
-fix_options(request)
-struct request_info *request;
+void fix_options(struct request_info *request)
 {
 #ifdef IP_OPTIONS
     unsigned char optbuf[BUFFER_SIZE / 3], *cp;
--- a/tools/tcpd_wrapper/hosts_access.c
+++ b/tools/tcpd_wrapper/hosts_access.c
@@ -23,6 +23,7 @@ static char sccsid[] = "@(#) hosts_access.c 1.21 97/02/12 02:13:22";
 
 /* System libraries. */
 
+#define _XOPEN_SOURCE 500
 #include <sys/types.h>
 #include <sys/param.h>
 #include <netinet/in.h>
@@ -33,12 +34,13 @@ static char sccsid[] = "@(#) hosts_access.c 1.21 97/02/12 02:13:22";
 #include <errno.h>
 #include <setjmp.h>
 #include <string.h>
+#include <stdlib.h>
 
 #ifndef HAVE_UCHAR_T
 typedef unsigned char uchar_t;
 #endif
 
-extern char *fgets();
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream);
 extern int errno;
 
 #ifndef	INADDR_NONE
@@ -79,15 +81,15 @@ int     resident = (-1);		/* -1, 0: unknown; +1: yes */
 
 /* Forward declarations. */
 
-static int table_match();
-static int list_match();
-static int server_match();
-static int client_match();
-static int host_match();
-static int string_match();
-static int masked_match();
+static int table_match (char *table, struct request_info *request);
+static int list_match (char *list, struct request_info *request, int (*match_fn)(char *tok, struct request_info *req));
+static int server_match (char *tok, struct request_info *request);
+static int client_match (char *tok, struct request_info *request);
+static int host_match (char *tok, struct host_info *host);
+static int string_match (char *tok, char *string);
+static int masked_match (char *net_tok, char *mask_tok, char *string);
 #ifdef HAVE_IPV6
-static void ipv6_mask();
+static void ipv6_mask (struct in6_addr *in6p, int maskbits);
 #endif
 
 /* Size of logical line buffer. */
--- a/tools/tcpd_wrapper/misc.c
+++ b/tools/tcpd_wrapper/misc.c
@@ -19,7 +19,7 @@ static char sccsic[] = "@(#) misc.c 1.2 96/02/11 17:01:29";
 
 #include "tcpd.h"
 
-extern char *fgets();
+extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream);
 
 #ifndef	INADDR_NONE
 #define	INADDR_NONE	(-1)		/* XXX should be 0xffffffff */
--- a/tools/tcpd_wrapper/mystdarg.h
+++ b/tools/tcpd_wrapper/mystdarg.h
@@ -16,4 +16,4 @@
 #define VAEND(ap)              va_end(ap);}
 #endif
 
-extern char *percent_m();
+extern char *percent_m(char *obuf, char *ibuf);
--- a/tools/tcpd_wrapper/myvsyslog.c
+++ b/tools/tcpd_wrapper/myvsyslog.c
@@ -14,20 +14,17 @@ static char sccsid[] = "@(#) myvsyslog.c 1.1 94/12/28 17:42:33";
 #ifdef vsyslog
 
 #include <stdio.h>
+#include <syslog.h>
 
 #include "tcpd.h"
 #include "mystdarg.h"
-
-myvsyslog(
-int     severity,
-char   *format,
-va_list ap)
+void myvsyslog(int __pri, const char *__fmt, __gnuc_va_list __ap)
 {
     char    fbuf[BUFSIZ];
     char    obuf[3 * STRING_LENGTH];
 
-    vsprintf(obuf, percent_m(fbuf, format), ap);
-    syslog(severity, "%s", obuf);
+    vsprintf(obuf, percent_m(fbuf, __fmt), __ap);
+    syslog(__pri, "%s", obuf);
 }
 
 #endif
--- a/tools/tcpd_wrapper/options.c
+++ b/tools/tcpd_wrapper/options.c
@@ -47,6 +47,7 @@ static char sccsid[] = "@(#) options.c 1.17 96/02/11 17:01:31";
 #include <ctype.h>
 #include <setjmp.h>
 #include <string.h>
+#include <unistd.h>
 
 #ifndef MAXPATHNAMELEN
 #define MAXPATHNAMELEN  BUFSIZ
@@ -66,31 +67,31 @@ extern jmp_buf tcpd_buf;		/* tcpd_jump() support */
 static char whitespace_eq[] = "= \t\r\n";
 #define whitespace (whitespace_eq + 1)
 
-static char *get_field();		/* chew :-delimited field off string */
-static char *chop_string();		/* strip leading and trailing blanks */
+static char *get_field (char *string);		/* chew :-delimited field off string */
+static char *chop_string (char *string);/* strip leading and trailing blanks */
 
 /* List of functions that implement the options. Add yours here. */
 
-static void user_option();		/* execute "user name.group" option */
-static void group_option();		/* execute "group name" option */
-static void umask_option();		/* execute "umask mask" option */
-static void linger_option();		/* execute "linger time" option */
-static void keepalive_option();		/* execute "keepalive" option */
-static void spawn_option();		/* execute "spawn command" option */
-static void twist_option();		/* execute "twist command" option */
-static void rfc931_option();		/* execute "rfc931" option */
-static void setenv_option();		/* execute "setenv name value" */
-static void nice_option();		/* execute "nice" option */
-static void severity_option();		/* execute "severity value" */
-static void allow_option();		/* execute "allow" option */
-static void deny_option();		/* execute "deny" option */
-static void banners_option();		/* execute "banners path" option */
+static void user_option (char *value, struct request_info *request);/* execute "user name.group" option */
+static void group_option (char *value, struct request_info *request);/* execute "group name" option */
+static void umask_option (char *value, struct request_info *request);/* execute "umask mask" option */
+static void linger_option (char *value, struct request_info *request);/* execute "linger time" option */
+static void keepalive_option (char *value, struct request_info *request);/* execute "keepalive" option */
+static void spawn_option (char *value, struct request_info *request);/* execute "spawn command" option */
+static void twist_option (char *value, struct request_info *request);/* execute "twist command" option */
+static void rfc931_option (char *value, struct request_info *request);/* execute "rfc931" option */
+static void setenv_option (char *value, struct request_info *request);/* execute "setenv name value" */
+static void nice_option (char *value, struct request_info *request);/* execute "nice" option */
+static void severity_option (char *value, struct request_info *request);/* execute "severity value" */
+static void allow_option (char *value, struct request_info *request);/* execute "allow" option */
+static void deny_option (char *value, struct request_info *request);/* execute "deny" option */
+static void banners_option (char *value, struct request_info *request);/* execute "banners path" option */
 
 /* Structure of the options table. */
 
 struct option {
     char   *name;			/* keyword name, case is ignored */
-    void  (*func) ();			/* function that does the real work */
+    void  (*func) (char* c, struct request_info *req);			/* function that does the real work */
     int     flags;			/* see below... */
 };
 
@@ -240,7 +241,7 @@ static void banners_option (char *value, struct request_info *request)
 static void group_option (char *value, struct request_info *request)
 {
     struct group *grp;
-    struct group *getgrnam();
+    struct group *getgrnam(const char *__name);
 
     if ((grp = getgrnam(value)) == 0)
 	tcpd_jump("unknown group: \"%s\"", value);
@@ -257,7 +258,7 @@ static void group_option (char *value, struct request_info *request)
 static void user_option (char *value, struct request_info *request)
 {
     struct passwd *pwd;
-    struct passwd *getpwnam();
+    struct passwd *getpwnam(const char *__name);
     char   *group;
 
     if ((group = split_at(value, '.')) != 0)
@@ -511,6 +512,7 @@ static int severity_map (struct syslog_names *table, char *name)
 	    return (t->value);
     tcpd_jump("bad syslog facility or severity: \"%s\"", name);
     /* NOTREACHED */
+    return 0;
 }
 
 /* severity_option - change logging severity for this event (Dave Mitchell) */
@@ -570,7 +572,7 @@ static char *get_field (char *string)
 
 /* chop_string - strip leading and trailing blanks from string */
 
-static char *chop_string (register char *string)
+static char *chop_string (char *string)
 {
     char   *start = 0;
     char   *end;
--- a/tools/tcpd_wrapper/percent_x.c
+++ b/tools/tcpd_wrapper/percent_x.c
@@ -19,6 +19,7 @@ static char sccsid[] = "@(#) percent_x.c 1.4 94/12/28 17:42:37";
 #include <stdio.h>
 #include <syslog.h>
 #include <string.h>
+#include <unistd.h>
 
 extern void exit();
 
--- a/tools/tcpd_wrapper/refuse.c
+++ b/tools/tcpd_wrapper/refuse.c
@@ -22,8 +22,7 @@ static char sccsid[] = "@(#) refuse.c 1.5 94/12/28 17:42:39";
 
 /* refuse - refuse request */
 
-void    refuse(request)
-struct request_info *request;
+void    refuse(struct request_info *request)
 {
     syslog(deny_severity, "refused connect from %s", eval_client(request));
     clean_exit(request);
--- a/tools/tcpd_wrapper/rfc931.c
+++ b/tools/tcpd_wrapper/rfc931.c
@@ -23,6 +23,7 @@ static char sccsid[] = "@(#) rfc931.c 1.10 95/01/02 16:11:34";
 #include <setjmp.h>
 #include <signal.h>
 #include <string.h>
+#include <unistd.h>
 
 /* Local stuff. */
 
--- a/tools/tcpd_wrapper/setenv.c
+++ b/tools/tcpd_wrapper/setenv.c
@@ -10,22 +10,26 @@
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
+#include <stdio.h>
+#include <string.h>
 #ifndef lint
 static char sccsid[] = "@(#) setenv.c 1.1 93/03/07 22:47:58";
 #endif
 
+#include <stdlib.h>
+
 /* setenv - update or insert environment (name,value) pair */
 
-int setenv (char *name, char *value, int clobber)
+int setenv (const char *__name, const char *__value, int __replace)
 {
-    char   *malloc();
-    char   *getenv();
+    void   *malloc(size_t size);
+    char   *getenv(const char *name);
     char   *cp;
 
-    if (clobber == 0 && getenv(name) != 0)
+    if (__replace == 0 && getenv(__name) != 0)
 	return (0);
-    if ((cp = malloc(strlen(name) + strlen(value) + 2)) == 0)
+    if ((cp = malloc(strlen(__name) + strlen(__value) + 2)) == 0)
 	return (1);
-    sprintf(cp, "%s=%s", name, value);
+    sprintf(cp, "%s=%s", __name, __value);
     return (putenv(cp));
 }
--- a/tools/tcpd_wrapper/shell_cmd.c
+++ b/tools/tcpd_wrapper/shell_cmd.c
@@ -20,6 +20,9 @@ static char sccsid[] = "@(#) shell_cmd.c 1.5 94/12/28 17:42:44";
 #include <stdio.h>
 #include <syslog.h>
 #include <string.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <fcntl.h>
 
 extern void exit();
 
@@ -29,7 +32,7 @@ extern void exit();
 
 /* Forward declarations. */
 
-static void do_child();
+static void do_child (char *command);
 
 /* shell_cmd - execute shell command */
 
--- a/tools/tcpd_wrapper/socket.c
+++ b/tools/tcpd_wrapper/socket.c
@@ -29,11 +29,12 @@ static char sccsid[] = "@(#) socket.c 1.15 97/03/21 19:27:24";
 #include <stdio.h>
 #include <syslog.h>
 #include <string.h>
-#ifdef bsdi
+#define _BSD_SOURCE
 #include <arpa/inet.h>
-#endif
+extern const char *inet_ntop(int af, const void *restrict src,
+                             char *restrict dst, socklen_t size);
 
-extern char *inet_ntoa();
+extern char *inet_ntoa(struct in_addr in);
 
 /* Local stuff. */
 
@@ -41,7 +42,7 @@ extern char *inet_ntoa();
 
 /* Forward declarations. */
 
-static void sock_sink();
+static void sock_sink (int fd);
 
 #ifdef APPEND_DOT
 
@@ -131,7 +132,6 @@ void sock_hostaddr (struct host_info *host)
 
     if (sin != 0)
 #ifdef HAVE_IPV6
-	
 	(void) inet_ntop(SGFAM(sin), SGADDRP(sin), host->addr, sizeof(host->addr));
 #else
 	STRN_CPY(host->addr, inet_ntoa(sin->sg_sin.sin_addr), sizeof(host->addr));
@@ -252,8 +252,7 @@ static void sock_sink (int fd)
  * If we receive a V4 connection on a V6 socket, we pretend we really
  * got a V4 connection.
  */
-void sockgen_simplify(sg)
-sockaddr_gen *sg;
+void sockgen_simplify(sockaddr_gen *sg)
 {
 #ifdef HAVE_IPV6
     if (sg->sg_family == AF_INET6 &&
--- a/tools/tcpd_wrapper/tcpd.h
+++ b/tools/tcpd_wrapper/tcpd.h
@@ -11,6 +11,7 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
+#include <strings.h>
 
 typedef struct sockaddr_gen {
     union {
@@ -29,7 +30,7 @@ typedef union gen_addr {
 #endif
 } gen_addr;
 
-extern void sockgen_simplify();
+void sockgen_simplify(sockaddr_gen *sg);
 
 #define sg_sa		sg_addr._sg_sa
 #define sg_sin		sg_addr._sg_sin
@@ -92,9 +93,9 @@ struct request_info {
     char    pid[10];			/* access via eval_pid(request) */
     struct host_info client[1];		/* client endpoint info */
     struct host_info server[1];		/* server endpoint info */
-    void  (*sink) ();			/* datagram sink function or 0 */
-    void  (*hostname) ();		/* address to printable hostname */
-    void  (*hostaddr) ();		/* address to printable address */
+    void  (*sink) (int fd);			/* datagram sink function or 0 */
+    void  (*hostname) (struct host_info *);		/* address to printable hostname */
+    void  (*hostaddr) (struct host_info *);		/* address to printable address */
     void  (*cleanup) ();		/* cleanup function or 0 */
     struct netconfig *config;		/* netdir handle */
 };
@@ -137,20 +138,20 @@ extern void fromhost();			/* get/validate client host info */
 #define fromhost sock_host		/* no TLI support needed */
 #endif
 
-extern int hosts_access();		/* access control */
-extern void shell_cmd();		/* execute shell command */
-extern char *percent_x();		/* do %<char> expansion */
-extern void rfc931();			/* client name from RFC 931 daemon */
-extern void clean_exit();		/* clean up and exit */
-extern void refuse();			/* clean up and exit */
-extern char *xgets();			/* fgets() on steroids */
-extern char *split_at();		/* strchr() and split */
-extern unsigned long dot_quad_addr();	/* restricted inet_addr() */
-extern int numeric_addr();		/* IP4/IP6 inet_addr (restricted) */
-extern struct hostent *tcpd_gethostbyname();
-					/* IP4/IP6 gethostbyname */
+extern int hosts_access(struct request_info *request);		/* access control */
+extern void shell_cmd(char *command);		/* execute shell command */
+extern char *percent_x(char *result, int result_len, char *string, struct request_info *request);		/* do %<char> expansion */
+extern void rfc931(struct sockaddr_gen *rmt_sin, struct sockaddr_gen *our_sin, char *dest);			/* client name from RFC 931 daemon */
+extern void clean_exit (struct request_info *request);/* clean up and exit */
+extern void    refuse(struct request_info *request);/* clean up and exit */
+extern char *xgets(char *ptr, int len, FILE *fp);			/* fgets() on steroids */
+extern char *split_at(char *string, int delimiter);		/* strchr() and split */
+extern unsigned long dot_quad_addr(char *str);	/* restricted inet_addr() */
+extern int numeric_addr(char *str, union gen_addr *addr, int *af, int *len);		/* IP4/IP6 inet_addr (restricted) */
+extern struct hostent *tcpd_gethostbyname(char *host, int af);/* IP4/IP6 gethostbyname */
+extern int setenv (char *name, char *value, int clobber);
 #ifdef HAVE_IPV6
-extern char *skip_ipv6_addrs();		/* skip over colons in IPv6 addrs */
+extern char *skip_ipv6_addrs(char *str);		/* skip over colons in IPv6 addrs */
 #else
 #define skip_ipv6_addrs(x)	x
 #endif
@@ -196,20 +197,20 @@ extern struct request_info *request_set();	/* update request structure */
   * host_info structures serve as caches for the lookup results.
   */
 
-extern char *eval_user();		/* client user */
-extern char *eval_hostname();		/* printable hostname */
-extern char *eval_hostaddr();		/* printable host address */
-extern char *eval_hostinfo();		/* host name or address */
-extern char *eval_client();		/* whatever is available */
-extern char *eval_server();		/* whatever is available */
+extern char *eval_user(struct request_info *request);		/* client user */
+extern char *eval_hostname(struct host_info *host);		/* printable hostname */
+extern char *eval_hostaddr(struct host_info *host);		/* printable host address */
+extern char *eval_hostinfo(struct host_info *host);		/* host name or address */
+extern char *eval_client(struct request_info *request);		/* whatever is available */
+extern char *eval_server(struct request_info *request);		/* whatever is available */
 #define eval_daemon(r)	((r)->daemon)	/* daemon process name */
 #define eval_pid(r)	((r)->pid)	/* process id */
 
 /* Socket-specific methods, including DNS hostname lookups. */
 
-extern void sock_host();		/* look up endpoint addresses */
-extern void sock_hostname();		/* translate address to hostname */
-extern void sock_hostaddr();		/* address to printable address */
+extern void sock_host(struct request_info *request);		/* look up endpoint addresses */
+extern void sock_hostname(struct host_info *host);		/* translate address to hostname */
+extern void sock_hostaddr(struct host_info *host);		/* address to printable address */
 #define sock_methods(r) \
 	{ (r)->hostname = sock_hostname; (r)->hostaddr = sock_hostaddr; }
 
@@ -257,7 +258,7 @@ extern struct tcpd_context tcpd_context;
   * behavior.
   */
 
-extern void process_options();		/* execute options */
+extern void process_options(char *options, struct request_info *request);		/* execute options */
 extern int dry_run;			/* verification flag */
 
 /* Bug workarounds. */
@@ -269,7 +270,7 @@ extern long fix_inet_addr();
 
 #ifdef BROKEN_FGETS			/* partial reads from sockets */
 #define fgets fix_fgets
-extern char *fix_fgets();
+extern char *fix_fgets (char *buf, int len, FILE *fp);
 #endif
 
 #ifdef RECVFROM_BUG			/* no address family info */
@@ -279,7 +280,7 @@ extern int fix_recvfrom();
 
 #ifdef GETPEERNAME_BUG			/* claims success with UDP */
 #define getpeername fix_getpeername
-extern int fix_getpeername();
+extern int fix_getpeername(int sock, struct sockaddr *sa, int *len);
 #endif
 
 #ifdef SOLARIS_24_GETHOSTBYNAME_BUG	/* lists addresses as aliases */
@@ -294,5 +295,5 @@ extern char *fix_strtok();
 
 #ifdef LIBC_CALLS_STRTOK		/* libc calls strtok() */
 #define strtok	my_strtok
-extern char *my_strtok();
+extern char *my_strtok(char *buf, char *sep);
 #endif
--- a/tools/tcpd_wrapper/update.c
+++ b/tools/tcpd_wrapper/update.c
@@ -13,6 +13,7 @@
   * Author: Wietse Venema, Eindhoven University of Technology, The Netherlands.
   */
 
+#include <unistd.h>
 #ifndef lint
 static char sccsid[] = "@(#) update.c 1.1 94/12/28 17:42:56";
 #endif
--- a/common/directive_conf.c
+++ b/common/directive_conf.c
@@ -447,7 +447,7 @@ add_directive (
     item->program = xstrdup(program);
   }
   
-  item->function = func;
+  item->function = (int (*)(char *))func;
   item->disabled_flag = disabled_flag;
   if (item->disabled_flag) 
   { 
--- a/tools/rwhois_deleter/rwhois_deleter.c
+++ b/tools/rwhois_deleter/rwhois_deleter.c
@@ -38,8 +38,8 @@
 
 /* usage: prints the usage statement */
 static int
-usage(prog_name)
-  char *prog_name;
+usage(
+  char *prog_name)
 {
   fprintf(stderr, "usage:\n");
   fprintf(stderr,
@@ -59,9 +59,9 @@ usage(prog_name)
 }
 
 char *
-assemble_query_string(argc, argv)
-  int argc;
-  char **argv;
+assemble_query_string(
+  int argc,
+  char **argv)
 {
   int i;
   char buf[MAX_LINE];
@@ -97,10 +97,10 @@ assemble_query_string(argc, argv)
 }
 
 static dl_list_type *
-query_for_records(query_string, limit, total)
-  char *query_string;
-  int  limit;
-  int  *total;
+query_for_records(
+  char *query_string,
+  int  limit,
+  int  *total)
 {
   query_struct query;
   int   num_recs;
@@ -132,9 +132,9 @@ query_for_records(query_string, limit, total)
   return record_list;
 }
 
-void show_result_list(record_list, total)
-  dl_list_type *record_list;
-  int total;
+void show_result_list(
+  dl_list_type *record_list,
+  int total)
 {
   int not_done;
   record_struct *rec;
@@ -170,9 +170,9 @@ void show_result_list(record_list, total)
 }
 
 int
-main(argc, argv)
-  int  argc;
-  char *argv[];
+main(
+  int  argc,
+  char *argv[])
 {
   extern char   *optarg;
 #ifndef optind
@@ -256,7 +256,7 @@ main(argc, argv)
 
   if (!quiet || fake)
   {
-    show_result_list(record_list);
+    show_result_list(record_list, 10);
   }
 
   if (!fake && !quiet && total > 0)
--- a/tools/rwhois_indexer/rwhois_indexer.c
+++ b/tools/rwhois_indexer/rwhois_indexer.c
@@ -60,9 +60,9 @@ static int usage (char *prog_name)
 }
 
 static int
-delete_index_files(class, auth_area)
-  class_struct     *class;
-  auth_area_struct *auth_area;
+delete_index_files(
+  class_struct     *class,
+  auth_area_struct *auth_area)
 {
   dl_list_type master_file_list;
   dl_list_type index_file_list;
@@ -154,12 +154,12 @@ static int run_file_index (char *class_name, char *auth_area_name, int validate_
 }
 
 static int
-run_suffix_index_class(class, auth_area, validate_flag, init_flag, suffix)
-  class_struct     *class;
-  auth_area_struct *auth_area;
-  int              validate_flag;
-  int              init_flag;
-  char             *suffix;
+run_suffix_index_class(
+  class_struct     *class,
+  auth_area_struct *auth_area,
+  int              validate_flag,
+  int              init_flag,
+  char             *suffix)
 {
   if (init_flag)
   {
@@ -174,13 +174,12 @@ run_suffix_index_class(class, auth_area, validate_flag, init_flag, suffix)
 }
 
 static int
-run_suffix_index_auth_area(auth_area, class_name, validate_flag, init_flag,
-                           suffix)
-  auth_area_struct *auth_area;
-  char             *class_name;
-  int              validate_flag;
-  int              init_flag;
-  char             *suffix;
+run_suffix_index_auth_area(
+  auth_area_struct *auth_area,
+  char             *class_name,
+  int              validate_flag,
+  int              init_flag,
+  char             *suffix)
 {
   class_struct *class;
   dl_list_type *class_list;
--- a/tools/rwhois_repack/rwhois_repack.c
+++ b/tools/rwhois_repack/rwhois_repack.c
@@ -55,8 +55,8 @@ static int usage (char *prog_name)
 }
 
 static void
-print_config(options)
-  repack_options_struct *options;
+print_config(
+  repack_options_struct *options)
 {
   fprintf(stderr, "rwhois conf file:  %s\n",
           SAFE_STR(options->config_file, "default"));
--- a/tools/tcpd_wrapper/tcpd.h
+++ b/tools/tcpd_wrapper/tcpd.h
@@ -149,7 +149,7 @@ extern char *split_at(char *string, int delimiter);		/* strchr() and split */
 extern unsigned long dot_quad_addr(char *str);	/* restricted inet_addr() */
 extern int numeric_addr(char *str, union gen_addr *addr, int *af, int *len);		/* IP4/IP6 inet_addr (restricted) */
 extern struct hostent *tcpd_gethostbyname(char *host, int af);/* IP4/IP6 gethostbyname */
-extern int setenv (char *name, char *value, int clobber);
+extern int setenv (const char *__name, const char *__value, int __replace);
 #ifdef HAVE_IPV6
 extern char *skip_ipv6_addrs(char *str);		/* skip over colons in IPv6 addrs */
 #else
--- a/server/daemon.c
+++ b/server/daemon.c
@@ -105,6 +105,7 @@ sigchld_handler(
   /* reset the signal handler -- some older systems remove the signal
      handler upon use.  POSIX systems should not do this */
   signal(SIGCHLD, (__sighandler_t)sigchld_handler);
+  return 0;
 }
 
 static RETSIGTYPE
@@ -113,6 +114,7 @@ sighup_handler(
 {
   hup_recvd = TRUE;
   signal(SIGHUP, (__sighandler_t)sighup_handler);
+  return 0;
 }
 
 static RETSIGTYPE
@@ -122,6 +124,7 @@ exit_handler(
   log(L_LOG_NOTICE, UNKNOWN, "Exiting");
   delpid();
   exit(0);
+  return 0;
 }
 
 static void set_sighup (void)
